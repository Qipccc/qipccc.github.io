<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>STL 容器记录</title>
    <url>/2019/11/04/STL%E5%AE%B9%E5%99%A8%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>主要涉及到c++中STL容器的一些用法：vector,set,stack,queue,map,deque及Algorithm，不记得时可以随时查漏补缺。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">转载自@author 鲁伟林</span><br><span class="line">gitHub地址：https://github.com/thinkingfioa/Notes/blob/master/TechFiles/STL_Usage.md</span><br></pre></td></tr></table></figure>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="push-back-函数"><a href="#push-back-函数" class="headerlink" title="push_back()函数"></a>push_back()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector;</span><br><span class="line">myVector.push_back(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="pop-back-函数"><a href="#pop-back-函数" class="headerlink" title="pop_back()函数"></a>pop_back()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从后往前pop</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector;</span><br><span class="line">myVector.push_back(<span class="number">100</span>);</span><br><span class="line">myVector.push_back(<span class="number">200</span>);</span><br><span class="line">myVector.push_back(<span class="number">300</span>);</span><br><span class="line"><span class="comment">//执行前: 100, 200, 300</span></span><br><span class="line">myVector.pop_back();</span><br><span class="line"><span class="comment">//执行后: 100, 200</span></span><br></pre></td></tr></table></figure></p>
<h3 id="insert-函数"><a href="#insert-函数" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">3</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">  <span class="comment">//执行前: 100, 100, 100</span></span><br><span class="line">  it = myvector.begin();</span><br><span class="line">  it = myvector.insert ( it , <span class="number">200</span> );</span><br><span class="line">  <span class="comment">//执行后: 200, 100, 100, 100</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//执行前: 200, 100, 100, 100</span></span><br><span class="line">  myvector.insert (it,<span class="number">2</span>,<span class="number">300</span>);</span><br><span class="line">  <span class="comment">//执行后: 300, 300, 200, 100, 100, 100</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// "it" no longer valid, get a new one:</span></span><br><span class="line">  it = myvector.begin();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行前: 300, 300, 200, 100, 100, 100</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; anothervector (<span class="number">2</span>,<span class="number">400</span>);</span><br><span class="line">  myvector.insert (it+<span class="number">2</span>,anothervector.begin(),anothervector.end());</span><br><span class="line">  <span class="comment">//执行后: 300, 300, 400, 400, 200, 100, 100, 100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myarray [] = &#123; <span class="number">501</span>,<span class="number">502</span>,<span class="number">503</span> &#125;;</span><br><span class="line">  <span class="comment">//执行前: 300, 300, 400, 400, 200, 100, 100, 100</span></span><br><span class="line">  myvector.insert (myvector.begin(), myarray, myarray+<span class="number">3</span>);</span><br><span class="line">  <span class="comment">//执行后: 501, 502, 503, 300, 300, 400, 400, 200, 100, 100, 100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数"><a href="#erase-函数" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">	myVector.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 6, 7, 8, 9</span></span><br><span class="line">myVector.erase(myVector.begin() +<span class="number">5</span>); <span class="comment">// 移除下标为5的数,也就是myVector[5]=6</span></span><br><span class="line"><span class="comment">//执行后: 1, 2, 3, 4, 5, 7, 8, 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 7, 8, 9</span></span><br><span class="line">myVector.erase(myVector.begin(), myVector.begin() + <span class="number">3</span>);</span><br><span class="line"><span class="comment">//执行后: 4, 5, 7, 8, 9</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数"><a href="#swap-函数" class="headerlink" title="swap()函数"></a>swap()函数</h3><p> 代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">3</span>,<span class="number">100</span>);   <span class="comment">// three ints with a value of 100</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar (<span class="number">5</span>,<span class="number">200</span>);   <span class="comment">// five ints with a value of 200</span></span><br><span class="line"><span class="comment">//执行前: foo: [100, 100, 100]</span></span><br><span class="line"><span class="comment">//       bar: [200, 200, 200, 200, 200]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">//执行后: foo: [200, 200, 200, 200, 200]</span></span><br><span class="line"><span class="comment">//       bar: [100, 100, 100]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>迭代器遍历:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (it=myvector.begin(); it&lt;myvector.end(); it++)&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C++中的Set是一个有序-去重集合</span><br></pre></td></tr></table></figure>
<h3 id="insert-函数-1"><a href="#insert-函数-1" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator,<span class="keyword">bool</span>&gt; ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; ++i) myset.insert(i*<span class="number">10</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 30, 40, 50</span></span><br><span class="line">ret = myset.insert(<span class="number">20</span>);  <span class="comment">// no new element inserted</span></span><br><span class="line"><span class="comment">//执行后: 10, 20, 30, 40, 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret.second==<span class="literal">false</span>) it=ret.first;  <span class="comment">// "it" now points to element 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 30, 40, 50</span></span><br><span class="line">myset.insert (it,<span class="number">25</span>);                 <span class="comment">// max efficiency inserting</span></span><br><span class="line">myset.insert (it,<span class="number">24</span>);                 <span class="comment">// max efficiency inserting</span></span><br><span class="line">myset.insert (it,<span class="number">26</span>);                 <span class="comment">// no max efficiency inserting</span></span><br><span class="line"><span class="comment">//执行后: 10, 20, 24, 25, 26, 30, 40, 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 24, 25, 26, 30, 40, 50</span></span><br><span class="line"><span class="keyword">int</span> myints[]= &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>&#125;;              <span class="comment">// 10 already in set, not inserted</span></span><br><span class="line">myset.insert (myints,myints+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//执行后: 5, 10, 15, 20, 24, 25, 26, 30, 40, 50</span></span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数-1"><a href="#erase-函数-1" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert some values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; i++) myset.insert(i*<span class="number">10</span>);  <span class="comment">// 10 20 30 40 50 60 70 80 90</span></span><br><span class="line"></span><br><span class="line">it = myset.begin();</span><br><span class="line">++it;                                         <span class="comment">// "it" points now to 20</span></span><br><span class="line"><span class="comment">// 执行前: 10, 20, 30, 40, 50, 60, 70, 80, 90; //(*it) = 20</span></span><br><span class="line">myset.erase (it);</span><br><span class="line"><span class="comment">//执行后: 10, 30, 40, 50, 60, 70, 80, 90; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 30, 40, 50, 60, 70, 80, 90;</span></span><br><span class="line">myset.erase (<span class="number">40</span>);</span><br><span class="line"><span class="comment">//执行后: 10, 30, 50, 60, 70, 80, 90; </span></span><br><span class="line"></span><br><span class="line">it = myset.find (<span class="number">60</span>);</span><br><span class="line"><span class="comment">//执行前: 10, 30, 50, 60, 70, 80, 90; </span></span><br><span class="line">myset.erase (it, myset.end());</span><br><span class="line"><span class="comment">//执行后: 10, 30, 50;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-1"><a href="#swap-函数-1" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[]=&#123;<span class="number">12</span>,<span class="number">75</span>,<span class="number">10</span>,<span class="number">32</span>,<span class="number">20</span>,<span class="number">25</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; first (myints,myints+<span class="number">3</span>);     <span class="comment">// 10,12,75</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; second (myints+<span class="number">3</span>,myints+<span class="number">6</span>);  <span class="comment">// 20,25,32</span></span><br><span class="line"><span class="comment">//执行前: first [10, 12, 75]</span></span><br><span class="line"><span class="comment">//        second [20, 25, 32]</span></span><br><span class="line">first.swap(second);</span><br><span class="line"><span class="comment">//执行后: first [20, 25, 32]</span></span><br><span class="line"><span class="comment">//       second [10, 12, 75]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="find-函数"><a href="#find-函数" class="headerlink" title="find()函数"></a>find()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) myset.insert(i*<span class="number">10</span>);    <span class="comment">// set: 10 20 30 40 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行前: 10, 20, 30, 40, 50</span></span><br><span class="line">it=myset.find(<span class="number">20</span>);</span><br><span class="line">myset.erase (it);</span><br><span class="line"><span class="comment">// 执行后: 10, 30, 40, 50</span></span><br></pre></td></tr></table></figure></p>
<h3 id="count-函数"><a href="#count-函数" class="headerlink" title="count()函数"></a>count()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由于set集合不重复，所以count(val)返回的结果只有0或者1.</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">5</span>; ++i) myset.insert(i*<span class="number">3</span>);    <span class="comment">// set: 3 6 9 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结果是: 1</span></span><br><span class="line">myset.count(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//返回结果是: 0</span></span><br><span class="line">myset.count(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">75</span>,<span class="number">23</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset (myints,myints+<span class="number">5</span>); <span class="comment">//13, 23, 42, 65, 75</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=myset.begin(); it!=myset.end(); ++it)&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="top-函数"><a href="#top-函数" class="headerlink" title="top()函数"></a>top()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line">mystack.push(<span class="number">10</span>);</span><br><span class="line">mystack.push(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">mystack.top() -= <span class="number">5</span>; <span class="comment">//mystack.top() 的值为20</span></span><br></pre></td></tr></table></figure></p>
<h3 id="push-函数"><a href="#push-函数" class="headerlink" title="push()函数"></a>push()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) mystack.push(i);</span><br></pre></td></tr></table></figure></p>
<h3 id="pop-函数"><a href="#pop-函数" class="headerlink" title="pop()函数"></a>pop()函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">弹出栈的最上面</span><br></pre></td></tr></table></figure>
<h3 id="swap-函数-2"><a href="#swap-函数-2" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; foo,bar;</span><br><span class="line">foo.push (<span class="number">10</span>); foo.push(<span class="number">20</span>); foo.push(<span class="number">30</span>);</span><br><span class="line">bar.push (<span class="number">111</span>); bar.push(<span class="number">222</span>);</span><br><span class="line"><span class="comment">// 执行前: foo [10, 20, 30]</span></span><br><span class="line"><span class="comment">//        bar [111, 222]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">// 执行后: foo [111, 222]</span></span><br><span class="line"><span class="comment">//        bar [10, 20, 30]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Popping out elements..."</span>;</span><br><span class="line"><span class="keyword">while</span> (!mystack.empty())</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; mystack.top();</span><br><span class="line">   mystack.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c++ 中的map是默认按照key的排序。所以每次插入都会做调整。</span><br></pre></td></tr></table></figure>
<h3 id="insert-函数-2"><a href="#insert-函数-2" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first insert function version (single parameter):</span></span><br><span class="line">mymap.insert ( <span class="built_in">std</span>::pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;(<span class="string">'a'</span>,<span class="number">100</span>) );</span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数-2"><a href="#erase-函数-2" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert some values:</span></span><br><span class="line">mymap[<span class="string">'a'</span>]=<span class="number">10</span>;</span><br><span class="line">mymap[<span class="string">'b'</span>]=<span class="number">20</span>;</span><br><span class="line">mymap[<span class="string">'c'</span>]=<span class="number">30</span>;</span><br><span class="line">mymap[<span class="string">'d'</span>]=<span class="number">40</span>;</span><br><span class="line">mymap[<span class="string">'e'</span>]=<span class="number">50</span>;</span><br><span class="line">mymap[<span class="string">'f'</span>]=<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">it=mymap.find(<span class="string">'b'</span>);</span><br><span class="line"><span class="comment">//执行前: a-&gt;10, b-&gt;20, c-&gt;30, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line">mymap.erase (it);                   <span class="comment">// erasing by iterator</span></span><br><span class="line"><span class="comment">//执行后: a-&gt;10, c-&gt;30, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: a-&gt;10, c-&gt;30, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line">mymap.erase (<span class="string">'c'</span>);                  <span class="comment">// erasing by key</span></span><br><span class="line"><span class="comment">//执行后: a-&gt;10, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line"></span><br><span class="line">it=mymap.find (<span class="string">'e'</span>);</span><br><span class="line"><span class="comment">//执行前: a-&gt;10, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line">mymap.erase ( it, mymap.end() );    <span class="comment">// erasing by range</span></span><br><span class="line"><span class="comment">//执行后: a-&gt;10, d-&gt;40</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-3"><a href="#swap-函数-3" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; foo,bar;</span><br><span class="line"></span><br><span class="line">foo[<span class="string">'x'</span>]=<span class="number">100</span>;</span><br><span class="line">foo[<span class="string">'y'</span>]=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">bar[<span class="string">'a'</span>]=<span class="number">11</span>;</span><br><span class="line">bar[<span class="string">'b'</span>]=<span class="number">22</span>;</span><br><span class="line">bar[<span class="string">'c'</span>]=<span class="number">33</span>;</span><br><span class="line"><span class="comment">// 执行前: foo [x-&gt;100, y-&gt;200]</span></span><br><span class="line"><span class="comment">//        bar [a-&gt;11, b-&gt;22, c-&gt;33]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">// 执行前: foo [a-&gt;11, b-&gt;22, c-&gt;33]</span></span><br><span class="line"><span class="comment">//        bar [x-&gt;100, y-&gt;200]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-3"><a href="#遍历-3" class="headerlink" title="遍历"></a>遍历</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=foo.begin(); it!=foo.end(); ++it) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="push-函数-1"><a href="#push-函数-1" class="headerlink" title="push()函数"></a>push()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; myqueue;</span><br><span class="line">myqueue.push (myint);</span><br></pre></td></tr></table></figure></p>
<h3 id="pop-函数-1"><a href="#pop-函数-1" class="headerlink" title="pop()函数"></a>pop()函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">弹出最后一个数。</span><br></pre></td></tr></table></figure>
<h3 id="swap-函数-4"><a href="#swap-函数-4" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; foo,bar;</span><br><span class="line">foo.push (<span class="number">10</span>); foo.push(<span class="number">20</span>); foo.push(<span class="number">30</span>);</span><br><span class="line">bar.push (<span class="number">111</span>); bar.push(<span class="number">222</span>);</span><br><span class="line"><span class="comment">// 执行前: foo[10, 20, 30]</span></span><br><span class="line"><span class="comment">//        bar[111, 222]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">// 执行后: foo[111, 222]</span></span><br><span class="line"><span class="comment">//        bar[10, 20, 30]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="back-函数"><a href="#back-函数" class="headerlink" title="back()函数"></a>back()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">队列的最后一位</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myqueue.push(<span class="number">12</span>);</span><br><span class="line">myqueue.push(<span class="number">75</span>);   <span class="comment">// this is now the back</span></span><br><span class="line"><span class="comment">//执行前: 12, 75</span></span><br><span class="line">myqueue.back() -= myqueue.front();</span><br><span class="line"><span class="comment">//执行后: 12, 63</span></span><br></pre></td></tr></table></figure></p>
<h3 id="front-函数"><a href="#front-函数" class="headerlink" title="front()函数"></a>front()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">队列的队首</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myqueue.push(<span class="number">77</span>);</span><br><span class="line">myqueue.push(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//执行前: 77, 16</span></span><br><span class="line">myqueue.front() -= myqueue.back();    <span class="comment">// 77-16=61</span></span><br><span class="line"><span class="comment">//执行后: 61, 16</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-4"><a href="#遍历-4" class="headerlink" title="遍历"></a>遍历</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myqueue contains: "</span>;</span><br><span class="line"><span class="keyword">while</span> (!myqueue.empty())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myqueue.front();</span><br><span class="line">  myqueue.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">双向队列</span><br></pre></td></tr></table></figure>
<h3 id="front-函数-1"><a href="#front-函数-1" class="headerlink" title="front()函数"></a>front()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回队首</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line">mydeque.push_front(<span class="number">77</span>);</span><br><span class="line">mydeque.push_back(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//执行前: 77, 20</span></span><br><span class="line">mydeque.front() -= mydeque.back();</span><br><span class="line"><span class="comment">//执行后: 57, 20</span></span><br></pre></td></tr></table></figure></p>
<h3 id="back-函数-1"><a href="#back-函数-1" class="headerlink" title="back()函数"></a>back()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">双向队列的尾部</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line">mydeque.push_back(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (mydeque.back() != <span class="number">0</span>)</span><br><span class="line">  mydeque.push_back ( mydeque.back() <span class="number">-1</span> );</span><br></pre></td></tr></table></figure></p>
<h3 id="push-back-函数-1"><a href="#push-back-函数-1" class="headerlink" title="push_back()函数"></a>push_back()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"><span class="comment">//执行前: []</span></span><br><span class="line">mydeque.push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//执行后: [1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: [1]</span></span><br><span class="line">mydeque.push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//执行后: [1,2]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="push-front-函数"><a href="#push-front-函数" class="headerlink" title="push_front()函数"></a>push_front()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque (<span class="number">2</span>,<span class="number">100</span>);     <span class="comment">// two ints with a value of 100</span></span><br><span class="line"><span class="comment">//执行前: 100, 100</span></span><br><span class="line">mydeque.push_front (<span class="number">200</span>);</span><br><span class="line"><span class="comment">//执行后: 200, 100, 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 200, 100, 100</span></span><br><span class="line">mydeque.push_front (<span class="number">300</span>);</span><br><span class="line"><span class="comment">//执行前: 300, 200, 100, 100</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pop-back-函数-1"><a href="#pop-back-函数-1" class="headerlink" title="pop_back()函数"></a>pop_back()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行前: </span></span><br><span class="line">mydeque.push_back (<span class="number">10</span>);</span><br><span class="line">mydeque.push_back (<span class="number">20</span>);</span><br><span class="line">mydeque.push_back (<span class="number">30</span>);</span><br><span class="line"><span class="comment">//执行后: 10, 20, 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 30</span></span><br><span class="line">mydeque.pop_back(); </span><br><span class="line"><span class="comment">//执行后: 10, 20</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pop-front-函数"><a href="#pop-front-函数" class="headerlink" title="pop_front()函数"></a>pop_front()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行前: </span></span><br><span class="line">mydeque.push_back (<span class="number">100</span>);</span><br><span class="line">mydeque.push_back (<span class="number">200</span>);</span><br><span class="line">mydeque.push_back (<span class="number">300</span>);</span><br><span class="line"><span class="comment">//执行后: 100, 200, 300</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 100, 200, 300</span></span><br><span class="line">mydeque.pop_front();</span><br><span class="line"><span class="comment">//执行后: 200, 300</span></span><br></pre></td></tr></table></figure></p>
<h3 id="insert-函数-3"><a href="#insert-函数-3" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++) mydeque.push_back(i); <span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = mydeque.begin();</span><br><span class="line">++it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5</span></span><br><span class="line">it = mydeque.insert (it,<span class="number">10</span>); </span><br><span class="line"><span class="comment">//执行后: 1, 10, 2, 3, 4, 5</span></span><br><span class="line"><span class="comment">// "it" now points to the newly inserted 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 10, 2, 3, 4, 5</span></span><br><span class="line">mydeque.insert (it,<span class="number">2</span>,<span class="number">20</span>);                     <span class="comment">// 1 20 20 10 2 3 4 5</span></span><br><span class="line"><span class="comment">//执行后: 1, 20, 20, 10, 2, 3, 4, 5</span></span><br><span class="line"><span class="comment">// "it" no longer valid!</span></span><br><span class="line"></span><br><span class="line">it = mydeque.begin()+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 20, 20, 10, 2, 3, 4, 5</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">2</span>,<span class="number">30</span>);</span><br><span class="line">mydeque.insert (it,myvector.begin(),myvector.end());</span><br><span class="line"><span class="comment">//执行后: 1, 20, 30, 30, 20, 10, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数-3"><a href="#erase-函数-3" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set some values (from 1 to 10)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) mydeque.push_back(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// erase the 6th element</span></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</span></span><br><span class="line">mydeque.erase (mydeque.begin()+<span class="number">5</span>);</span><br><span class="line"><span class="comment">//执行后: 1, 2, 3, 4, 5, 7, 8, 9, 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// erase the first 3 elements:</span></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 7, 8, 9, 10</span></span><br><span class="line">mydeque.erase (mydeque.begin(),mydeque.begin()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//执行后: 4, 5, 7, 8, 9, 10</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-5"><a href="#swap-函数-5" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">3</span>,<span class="number">100</span>);   <span class="comment">// three ints with a value of 100</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; bar (<span class="number">5</span>,<span class="number">200</span>);   <span class="comment">// five ints with a value of 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: foo [100, 100, 100]</span></span><br><span class="line"><span class="comment">//       bar [200, 200, 200, 200, 200]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">//执行后: foo [200, 200, 200, 200, 200]</span></span><br><span class="line"><span class="comment">//       bar [100, 100, 100]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-5"><a href="#遍历-5" class="headerlink" title="遍历"></a>遍历</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = mydeque.begin(); it!=mydeque.end(); ++it) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!mydeque.empty()) &#123;</span><br><span class="line">  sum+=mydeque.back();</span><br><span class="line">  mydeque.pop_back(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><h3 id="find-函数-1"><a href="#find-函数-1" class="headerlink" title="find()函数"></a>find()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中查询</span></span><br><span class="line"><span class="keyword">int</span> myints[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">std</span>::find (myints, myints+<span class="number">4</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (p != myints+<span class="number">4</span>)</span><br><span class="line">  <span class="comment">//输出: 30</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element not found in myints\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector中查询</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints,myints+<span class="number">4</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">it = find (myvector.begin(), myvector.end(), <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myvector.end())</span><br><span class="line">  <span class="comment">//输出: 30</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element not found in myvector\n"</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="copy-函数"><a href="#copy-函数" class="headerlink" title="copy()函数"></a>copy()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">7</span>);</span><br><span class="line"><span class="comment">//执行前: myvector: </span></span><br><span class="line"><span class="built_in">std</span>::copy ( myints, myints+<span class="number">7</span>, myvector.begin() );</span><br><span class="line"><span class="comment">//执行前: myvector: 10, 20, 30, 40, 50, 60, 70</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-6"><a href="#swap-函数-6" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>, y=<span class="number">20</span>;                              <span class="comment">// x:10 y:20</span></span><br><span class="line"><span class="comment">//执行前: x:10, y:20</span></span><br><span class="line"><span class="built_in">std</span>::swap(x,y);                              <span class="comment">// x:20 y:10</span></span><br><span class="line"><span class="comment">//执行后: x:20, y:10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">4</span>,x), bar (<span class="number">6</span>,y);       <span class="comment">// foo:4x20 bar:6x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: foo[20, 20, 20, 20]</span></span><br><span class="line"><span class="comment">//       bar[10, 10, 10, 10]</span></span><br><span class="line"><span class="built_in">std</span>::swap(foo,bar);                          <span class="comment">// foo:6x10 bar:4x20</span></span><br><span class="line"><span class="comment">//执行前: foo[20, 20, 20, 20]</span></span><br><span class="line"><span class="comment">//       bar[10, 10, 10, 10]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="count-函数-1"><a href="#count-函数-1" class="headerlink" title="count()函数"></a>count()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;   <span class="comment">// 8 elements</span></span><br><span class="line"><span class="comment">//记录数组myints中，10的个数</span></span><br><span class="line"><span class="keyword">int</span> mycount = <span class="built_in">std</span>::count (myints, myints+<span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//输出结果 mycount = 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);</span><br><span class="line"><span class="comment">//记录数组myvector中，20的个数</span></span><br><span class="line">mycount = <span class="built_in">std</span>::count (myvector.begin(), myvector.end(), <span class="number">20</span>);</span><br><span class="line"><span class="comment">//记录数组myvector中，20的个数</span></span><br></pre></td></tr></table></figure></p>
<h3 id="replace-函数"><a href="#replace-函数" class="headerlink" title="replace()函数"></a>replace()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">//执行前: myvector: []</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);            </span><br><span class="line"><span class="comment">//执行后: myvector: 10, 20, 30, 30, 20, 10, 10, 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: myvector: 10, 20, 30, 30, 20, 10, 10, 20</span></span><br><span class="line"><span class="built_in">std</span>::replace (myvector.begin(), myvector.end(), <span class="number">20</span>, <span class="number">99</span>); </span><br><span class="line"><span class="comment">//执行前: myvector: 10, 99, 30, 30, 99, 10, 10, 99</span></span><br></pre></td></tr></table></figure></p>
<h3 id="fill-函数"><a href="#fill-函数" class="headerlink" title="fill()函数"></a>fill()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行前 myvector: []</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">8</span>);                      </span><br><span class="line"><span class="comment">//执行后 myvector: 0,0,0,0,0,0,0,0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前 myvector: 0,0,0,0,0,0,0,0</span></span><br><span class="line"><span class="built_in">std</span>::fill (myvector.begin(),myvector.begin()+<span class="number">4</span>,<span class="number">5</span>);   </span><br><span class="line"><span class="comment">//执行后 myvector: 5,5,5,5,0,0,0,0</span></span><br><span class="line"><span class="comment">//执行后 myvector: 5,5,5,5,0,0,0,0</span></span><br><span class="line">  <span class="built_in">std</span>::fill (myvector.begin()+<span class="number">3</span>,myvector.end()<span class="number">-2</span>,<span class="number">8</span>); </span><br><span class="line"><span class="comment">//执行后 myvector: 5,5,5,8,8,8,0,0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="reverse-函数"><a href="#reverse-函数" class="headerlink" title="reverse()函数"></a>reverse()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; ++i) myvector.push_back(i);   <span class="comment">// 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1,2,3,4,5,6,7,8,9</span></span><br><span class="line"><span class="built_in">std</span>::reverse(myvector.begin(),myvector.end());    <span class="comment">// 9 8 7 6 5 4 3 2 1</span></span><br><span class="line"><span class="comment">//执行后: 9,8,7,6,5,4,3,2,1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort()函数"></a>sort()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j);&#125;</span><br><span class="line">&#125; myobject;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">32</span>,<span class="number">71</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">26</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">33</span>&#125;;</span><br><span class="line">  <span class="comment">//执行前: myvector: []</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);             </span><br><span class="line">  <span class="comment">//执行后: myvector: 32,71,12,45,26,80,53,33</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//缺省的排序是升序(&lt;)</span></span><br><span class="line">  <span class="comment">//执行前: 32,71,12,45,26,80,53,33</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin(), myvector.begin()+<span class="number">4</span>);          </span><br><span class="line">  <span class="comment">//执行后: 12,32,45,71,26,80,53,33</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行前: 12,32,45,71,26,80,53,33 using function as comp</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin()+<span class="number">4</span>, myvector.end(), myfunction); </span><br><span class="line">  <span class="comment">//执行后: 12,32,45,71,26,33,53,80</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// using object as comp</span></span><br><span class="line">  <span class="comment">//执行后: 12,32,45,71,26,33,53,80</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin(), myvector.end(), myobject);   </span><br><span class="line">  <span class="comment">//执行后: 12,26,32,33,45,53,71,80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="merge函数"><a href="#merge函数" class="headerlink" title="merge函数"></a>merge函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将两个有序的组合sort1[], sort2[]。归并成一个新的有序组合。</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> first[] = &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> second[] = &#123;<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort (first,first+<span class="number">5</span>);</span><br><span class="line"><span class="built_in">std</span>::sort (second,second+<span class="number">5</span>);</span><br><span class="line"><span class="comment">//执行前: first: 5,10,15,20,25</span></span><br><span class="line"><span class="comment">//       second: 10,20,30,40,50</span></span><br><span class="line"><span class="comment">//       v:[]</span></span><br><span class="line"><span class="built_in">std</span>::merge (first,first+<span class="number">5</span>,second,second+<span class="number">5</span>,v.begin());</span><br><span class="line"><span class="comment">//执行后: first: 5,10,15,20,25</span></span><br><span class="line"><span class="comment">//       second: 10,20,30,40,50</span></span><br><span class="line"><span class="comment">//       v:5,10,10,15,20,20,25,30,40,50</span></span><br></pre></td></tr></table></figure></p>
<h3 id="min-函数"><a href="#min-函数" class="headerlink" title="min()函数"></a>min()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出: 1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min(1,2)=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>  </span><br><span class="line"><span class="comment">//输出: 1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min(2,1)=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="number">2</span>,<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 'a'</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min('a','z')=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="string">'a'</span>,<span class="string">'z'</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 2.72</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min(3.14,2.72)=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="number">3.14</span>,<span class="number">2.72</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="max-函数"><a href="#max-函数" class="headerlink" title="max()函数"></a>max()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出: 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(1,2)=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>  </span><br><span class="line"><span class="comment">//输出: 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(2,1)=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="number">2</span>,<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 'z'</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max('a','z')=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="string">'a'</span>,<span class="string">'z'</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 3.14</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(3.14,2.72)=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="number">3.14</span>,<span class="number">2.72</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>图论算法记录</title>
    <url>/2019/11/03/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>主要以有向加权图为主，涉及到 <strong>图的几种常见表示方法</strong>、<strong>拓扑排序</strong>、<strong>弗洛伊德算法(Floyd)算法</strong>、 <strong>狄克斯特拉(dijkstra)算法</strong>、 <strong>SPFA算法</strong>、<strong>贝尔曼-福特(Bellman-Ford)算法</strong></p>
<a id="more"></a>
<h2 id="图的常见表示方法"><a href="#图的常见表示方法" class="headerlink" title="图的常见表示方法"></a>图的常见表示方法</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151010.png" heigt='400' width='400'/></p>
<h3 id="1-邻接矩阵："><a href="#1-邻接矩阵：" class="headerlink" title="1. 邻接矩阵："></a>1. 邻接矩阵：</h3><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151027.png" heigt='400' width='400'/></p>
<h3 id="2-邻接表："><a href="#2-邻接表：" class="headerlink" title="2. 邻接表："></a>2. 邻接表：</h3><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151035.png" heigt='400' width='400'/></p>
<h3 id="3-边缘列表"><a href="#3-边缘列表" class="headerlink" title="3. 边缘列表"></a>3. 边缘列表</h3><p>在刷题的时候经常以这种形式给出，可以将其转换乘邻接表或者邻接矩阵</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151044.png" heigt='350' width='350'/></p>
<p><a href="https://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">完整</a></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/ca22fa351d5278e95c4c8c94aba6da42ae45d465ff3e8e82149777274293e194-0210.gif" alt=""></p>
<p>其简单思路就是先找到入度为0 的节点，并将该节点放入队列中，同时将与他相邻的节点的入度减一，以此往复，如果最后所有节点的入度都为零则说明可以完成拓扑排序，否则该图不能进行拓扑排序</p>
<p>具体的算法流程如下：</p>
<ol>
<li><p>在算法开始前，扫描对应的存储空间(使用邻接表)，将入度为 0 的节点放入队列中</p>
</li>
<li><p>只要队列非空，就从队首取出入度为0 的节点，并且将这个结点的所有邻接结点（它指向的结点）的入度减1，在减 1 以后，如果这个被减 1 的结点的入度为 0 ，就继续入队。</p>
</li>
<li><p>队列为空时，检查结果集是否满足要求</p>
</li>
</ol>
<p>除了需要保存入度为0 的队列，还需要两个辅助的数据结构：</p>
<pre><code>1). 邻接表：通过节点的索引，能够得到这个节点的后继节点；

2). 入度数组：通过节点的索引能够得到指向这个节点的节点个数
</code></pre><h3 id="leetcode207-课程表"><a href="#leetcode207-课程表" class="headerlink" title="leetcode207 课程表"></a>leetcode207 课程表</h3><ul>
<li>题目描述：</li>
</ul>
<p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p>
<ul>
<li><p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）</p>
</li>
</ul>
<p>链接：<a href="https://leetcode-cn.com/problems/course-schedule" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule</a></p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<ul>
<li>解题</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//输入prerequisites是边缘列表</span></span><br><span class="line">    <span class="keyword">int</span> clen = prerequisites.size(); <span class="comment">//课程的长度</span></span><br><span class="line">    <span class="keyword">if</span> (clen == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 课程长度为零，所以肯定可以学习完</span></span><br><span class="line">    <span class="comment">//1.初始化入度的数组 和 邻接表数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses); <span class="comment">//入度数组，初始化为0</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(numCourses); <span class="comment">//邻接表数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clen; ++i) &#123;</span><br><span class="line">        indegree[prerequisites[i][<span class="number">0</span>]] += <span class="number">1</span>;  <span class="comment">//统计每个顶点的度</span></span><br><span class="line">        adj[prerequisites[i][<span class="number">1</span>]].push_back(prerequisites[i][<span class="number">0</span>]); <span class="comment">// 创建邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 创建队列，在拓扑排序之前，将所有入度为0的顶点存入队列中</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; myqueue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">            myqueue.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 开始拓扑排序，主要是遍历前面的邻接表，然后找到表中顶点对应的入度，对入度减一操作，若检测到入度为0时则推入队列中，准备输出（删除）</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!myqueue.empty()) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">int</span> top = myqueue.front(); <span class="comment">// 得到首元素</span></span><br><span class="line">        myqueue.pop();  <span class="comment">//删除首元素</span></span><br><span class="line">        <span class="comment">//vector&lt;int&gt; tmp = adj[top];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = adj[top].begin(); iter != adj[top].end(); ++iter) &#123;</span><br><span class="line">            --indegree[*iter];</span><br><span class="line">            <span class="keyword">if</span> (indegree[*iter] == <span class="number">0</span>)</span><br><span class="line">                myqueue.push(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode210-课程表2"><a href="#leetcode210-课程表2" class="headerlink" title="leetcode210 课程表2"></a>leetcode210 课程表2</h3><p>和前面一样不同的是需要把课程表输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisities) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">//1. 初始化入度数组和邻接表'</span></span><br><span class="line">    <span class="keyword">if</span> (prerequisities.size() == <span class="number">0</span>) &#123;  <span class="comment">// 如果prerequisities大小为零，没有特别说明课程完成的先后顺序，则所有课程都能完成</span></span><br><span class="line">        <span class="keyword">while</span>(numCourses &gt;<span class="number">0</span>)</span><br><span class="line">            res.push_back(--numCourses);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses); <span class="comment">//入度数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(numCourses); <span class="comment">//邻接表数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisities.size(); ++i) &#123;</span><br><span class="line">        indegree[prerequisities[i][<span class="number">0</span>]] += <span class="number">1</span>;  <span class="comment">// 入度+1</span></span><br><span class="line">        adj[prerequisities[i][<span class="number">1</span>]].push_back(prerequisities[i][<span class="number">0</span>]); <span class="comment">// 扩展邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 创建队列，将度为0的元素推入队列中</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Myqueue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">            Myqueue.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 统计每个顶点的度，判断是否为零，减一和push进入队列中</span></span><br><span class="line">    <span class="keyword">while</span> (!Myqueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = Myqueue.front();</span><br><span class="line">        res.push_back(top);</span><br><span class="line">        Myqueue.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = adj[top].begin(); iter != adj[top].end(); ++iter) &#123;</span><br><span class="line">            --indegree[*iter];</span><br><span class="line">            <span class="keyword">if</span> (indegree[*iter] == <span class="number">0</span>)</span><br><span class="line">                Myqueue.push(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.size() != numCourses)</span><br><span class="line">        res = &#123;&#125;;  <span class="comment">// 输出空数组</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="弗洛伊德算法-Floyd"><a href="#弗洛伊德算法-Floyd" class="headerlink" title="弗洛伊德算法(Floyd)"></a>弗洛伊德算法(Floyd)</h2><p>弗洛伊德算法是经典的 <strong>多源最短路径</strong> 算法，可以正确处理有向图或有向图的负权，但不可存在负权回路的最短路径问题，同时也被用于计算有向图的传递闭包。 </p>
<ul>
<li>大概思路：</li>
</ul>
<p>定义两个二维矩阵D和P， D记录顶点间的最小路径，P记录顶点间最小路径中的中转点<br>通过三重循环，k为中转点，v为起点，w为终点，循环比较D[v][w] 和 D[v][k]+D[k][w]最小值，如果后者更小则替换前者</p>
<ul>
<li>具体：</li>
</ul>
<p>矩阵 D 记录顶点间的最小路径<br>例如 D[0][3]= 10，说明顶点 0  到  3  的最短路径为 10；<br>矩阵 P 记录顶点间最小路径中的中转点<br>例如 P[0][3]= 1  说明，0  到  3 的最短路径轨迹为：0 -&gt; 1 -&gt; 3。<br>它通过 3 重循环，k 为中转点，v 为起点，w 为终点，循环比较 D[v][w]  和  D[v][k] + D[k][w]最小值，如果 D[v][k] + D[k][w]  为更小值，则把 D[v][k] + D[k][w]  覆盖保存在 D[v][w]中。</p>
<ul>
<li>步骤演示：</li>
</ul>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/Floyd算法.PNG" height='800' width='400'/></p>
<p><a href="https://www.cnblogs.com/dzzy/p/5097009.html" target="_blank" rel="noopener">图片来源</a></p>
<h3 id="leetcode743-网络延迟时间"><a href="#leetcode743-网络延迟时间" class="headerlink" title="leetcode743 网络延迟时间"></a>leetcode743 网络延迟时间</h3><p>输入： times[i] = (u,v,w)，分别表示源节点、目标节点、它们之间的传递时间；  N：网络节点的个数， K表示测试时的起始节点<br>范围： N:[1,100], K:[1,N], times:[1,6000], 1 &lt;= u,v&lt;= N ,0 &lt;= w &lt;= 100<br>输出： 如果可以使所有节点都收到信号则返回总的时间，如果不能则返回-1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime_Floyd</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建二维稀疏矩阵表示 ==&gt; 邻接矩阵</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">-1</span>)); <span class="comment">// 创建二维vector 并初始化为-1表示永远不会到达</span></span><br><span class="line">    <span class="comment">//填充邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        v[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">        v[times[i][<span class="number">0</span>]][times[i][<span class="number">1</span>]] = times[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接下来进入Floyd算法的三重循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N ; ++k) &#123;  <span class="comment">//这里的小k表示的就是中间节点，尝试使用每个中间节点进行替换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">                <span class="comment">//当满足下面的条件时，使用中间节点进行替换</span></span><br><span class="line">                <span class="comment">//1. 中间节点不为-1，即i -&gt; k 和 k -&gt; j 这条有向边是存在的</span></span><br><span class="line">                <span class="comment">//2. 在满足条件1 的基础上，经过中间节点花费的时间可以比原来小，或者 原来的有向边不存在</span></span><br><span class="line">                <span class="keyword">if</span> (v[i][k] != <span class="number">-1</span> &amp;&amp; v[k][j] != <span class="number">-1</span> &amp;&amp; (v[i][j] &gt; v[i][k] + v[k][j] || v[i][j] == <span class="number">-1</span>))</span><br><span class="line">                    v[i][j] = v[i][k] + v[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过上面的三重循环，就将每个节点之间的最短通路找到了（如果存在的话）</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//因为最后的结果是要返回从该节点K出发遍历所有节点所花费的时间</span></span><br><span class="line">    <span class="comment">//所以首先判断是否为-1以此判断K是否可以联通所有节点，如果存在存在-1说明此路不通直接返回-1；</span></span><br><span class="line">    <span class="comment">//否则，将最大的那个值输出，因为最大值表示从K出发经过了所有的节点累加得到的路径长度，符合最后的要求</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[K][i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//说明这个节点是走不通的</span></span><br><span class="line">        res = max(res, v[K][i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="狄克斯特拉算法-Dijkstra"><a href="#狄克斯特拉算法-Dijkstra" class="headerlink" title="狄克斯特拉算法(Dijkstra)"></a>狄克斯特拉算法(Dijkstra)</h2><p>最经典的 <strong>单源最短路径</strong> (一个点到其余各个顶点的最短路径)算法，适用于边权为正的无向和有向图，不适用于有负边权的图.</p>
<p>基本思想：</p>
<p>每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。</p>
<p>基本步骤：</p>
<ol>
<li><p>将所有顶点分为两部分：已知最短路程的顶点集合P和未知最短路程的顶点集合Q。最开始，已知最短路径的顶点集合P中只有源点一个顶点。这里使用一个book[i]数组来记录哪些点在集合P中。例如对于某个顶点i，如果book[i]=1则表示这个顶点在集合P中，book[i]=0则表示这个顶点在集合Q中；</p>
</li>
<li><p>设置源点s到自己的最短路径为0即dis=0。若存在源点能直接到达顶点i，则把dis[i]设为e[s][i]，同时把所有其它（源点不能直接到达的）顶点的最短路径设置为 $ \infty$；</p>
</li>
<li><p>在集合Q的所有顶点选择一个离源点s最近的顶点u（即dis[u]最小）加入到集合P。并考察所有以点u为起点的边，对每一条边进行松弛操作。例如存在一条边从 u到v的边，那么可以通过将边 u -&gt; v添加到尾部来拓展一条从s 到v的路径，这条路径的长度是 dis[u]+e[u][v]，如果这个值比目前已知的dis[v]的值要小，可以用这个新值代替dis[v]中的值；</p>
</li>
<li><p>重复第三步，如果集合Q为空，算法结束。最终dis 数组中的值就是源点到所有顶点的最短路径。</p>
</li>
</ol>
<ul>
<li>步骤演示：</li>
</ul>
<p>给出下图：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.1.png" alt=""></p>
<p>创建邻接矩阵：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.2.png" alt=""></p>
<p>使用一个一维数组dis存储1号顶点到其余各个顶点的初始路程:</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.3.png" alt=""></p>
<p>找到离1号顶点最近的顶点，首先就是其本身，因为其操作没有特殊性，直接参考后续步骤。然后找到的最近顶点为2，然后查看2号顶点的出边有： 2-&gt;3, 2-&gt;4这两条边。先讨论2-&gt;3这条边能否让1号顶点到3号顶点的路程变短，也就是比较dis[3] 和 dis[2] + e[2][3]的大小，发现 12 &gt; 1+9，所以dis[3]更新为10,同理分析 2-&gt;4这条边， dis[4] = $ \infty$ &gt; dis[2] + e[2][4] = 4 所以dis[4] = 4，dis更新如下：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.4.png" alt=""></p>
<p>继续在 3,4,5,6顶点中查找离1号顶点最近的点，发现是4号顶点，其出边为 4-&gt;3, 4-&gt;5, 4-&gt;6。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于4 -&gt;3 ,dis[3] = 10 &gt; dis[4] + e[4][3] = 8,故 dis[3]更新为8;</span><br><span class="line">对于4-&gt;5, dis[5] = inf &gt; dis[4] + e[4][5] = 17, 故 dis[5] = 17;</span><br><span class="line">同理 dis[6] = 19</span><br></pre></td></tr></table></figure><br>所以dis更新如下：<br><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.5.png" alt=""></p>
<p>继续在3,5,6中查找离1号顶点最近的点，发现是3号顶点，其出边为 3-&gt;5。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 -&gt; 5， dis[5] = 17 &gt; dis[3] + e[3][5] = 13，故dis[5] = 13</span><br></pre></td></tr></table></figure><br>所以dis更新如下：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.6.png" alt="">（图中6号节点对应的19，背景应该是白色的）</p>
<p>继续在5,6中查找，最近点为5，其出边为 5-&gt;6：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5-&gt;6, dis[6] = 19 &gt; dis[5] + e[5][6] = 17，dis[6] = 17</span><br></pre></td></tr></table></figure></p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.7.png" alt=""></p>
<p>最后对顶点6进行松弛，发现没有出边故不处理，最终dis数组如下，这便是1号顶点到其余各个顶点的最短路径：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.8.png" alt=""></p>
<p><a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="leetcode743-网络延时时间"><a href="#leetcode743-网络延时时间" class="headerlink" title="leetcode743 网络延时时间"></a>leetcode743 网络延时时间</h3><p>前面使用了Floyd算法求解，这里使用Dijkstra算法求解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime_Dijkstra</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建邻接矩阵</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">-1</span>)); <span class="comment">//使用-1代替无穷大值，可能会有些许麻烦，之后尝试替换为 MAX_INT</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">        v[times[i][<span class="number">0</span>]][times[i][<span class="number">1</span>]] = times[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; S(N + <span class="number">1</span>, <span class="number">-1</span>), T(N + <span class="number">1</span>, <span class="number">-1</span>); <span class="comment">//S为确定数组，T为估计数组</span></span><br><span class="line">    <span class="comment">//根据单源节点填充数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[K][i] != <span class="number">-1</span>)</span><br><span class="line">            T[i] = v[K][i];</span><br><span class="line">    &#125;</span><br><span class="line">    T[K] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到距离单元节点最短距离的节点</span></span><br><span class="line">    <span class="keyword">int</span> minVal = <span class="number">-1</span>,minIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; ++c) &#123;</span><br><span class="line">        minVal = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (T[i] != <span class="number">-1</span> &amp;&amp; S[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minVal == <span class="number">-1</span> || T[i] &lt; minVal) &#123;</span><br><span class="line">                    minVal = T[i];</span><br><span class="line">                    minIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        S[minIndex] = minVal; <span class="comment">// 确定值</span></span><br><span class="line">        <span class="comment">// 以这个节点(minIndex)出发，找到其每个出边，并和原始距离进行比较，更新数组 T(估计数组)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[minIndex][i] != <span class="number">-1</span> &amp;&amp; (minVal + v[minIndex][i] &lt; T[i] || T[i] == <span class="number">-1</span>))</span><br><span class="line">                T[i] = minVal + v[minIndex][i]; <span class="comment">// 估计值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        res = max(res, S[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里使用-1 代替了 inf ，后续尝试修改成inf</span></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/network-delay-time/solution/c-bellman-forddijkstrafloydspfa-by-gez1994/" target="_blank" rel="noopener">解题参考</a></p>
<h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>SPFA算法是 <strong>单源最短路径</strong> 算法，是Bellman-ford队列优化，和BFS的关系密切，相较于狄克斯特拉算法，<strong>边的权重可以是负数</strong>、实现简单，但是时间复杂度过高。</p>
<ul>
<li>基本思路：</li>
</ul>
<p>使用一个先进先出的队列保存待优化的节点，优化时每次取出队首的节点 u ，并且对于 u 的所有出边所指向的节点v进行松弛操作，如果 v 点的最短路径估计值有所调整且v 点不在当前队列中，就将 v 点放入队尾。这样不断从队列中取出节点来进行松弛操作，直至队列为空。</p>
<ul>
<li>步骤：</li>
</ul>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103124821.png"/></p>
<h3 id="leetcode743-网络延时时间-1"><a href="#leetcode743-网络延时时间-1" class="headerlink" title="leetcode743 网络延时时间"></a>leetcode743 网络延时时间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networdDelay_SPFA</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T(N + <span class="number">1</span>, <span class="number">-1</span>);  <span class="comment">//估计值</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Flag(N + <span class="number">1</span>, <span class="number">-1</span>);  <span class="comment">// 用来标记节点是否在队列中</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Myqueue;  <span class="comment">//队列</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">        v[times[i][<span class="number">0</span>]][times[i][<span class="number">1</span>]] = times[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i)</span><br><span class="line">        v[i][i] = <span class="number">0</span>;</span><br><span class="line">    T[K] = <span class="number">0</span>;</span><br><span class="line">    Myqueue.push(K);  </span><br><span class="line">    Flag[K] = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">while</span> (!Myqueue.empty()) &#123;  <span class="comment">//只要队列不为空就一直循环</span></span><br><span class="line">        <span class="keyword">int</span> u = Myqueue.front();</span><br><span class="line">        Myqueue.pop();</span><br><span class="line">        Flag[u] = <span class="number">-1</span>; <span class="comment">//此时tmp 不在队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[u][i] != <span class="number">-1</span> &amp;&amp;( T[i] &gt; T[u] + v[u][i]  ||  T[i] == <span class="number">-1</span>))&#123;</span><br><span class="line">                T[i] = T[u] + v[u][i];</span><br><span class="line">                <span class="keyword">if</span> (Flag[i] == <span class="number">-1</span>) &#123;<span class="comment">//说明此时这个节点i不在队列中</span></span><br><span class="line">                    Myqueue.push(i);</span><br><span class="line">                    Flag[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        res = max(res, T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="贝尔曼-福特算法-Bellman-Ford"><a href="#贝尔曼-福特算法-Bellman-Ford" class="headerlink" title="贝尔曼-福特算法(Bellman-Ford)"></a>贝尔曼-福特算法(Bellman-Ford)</h2><p><a href="https://juejin.im/post/5b77fec1e51d4538cf53be68" target="_blank" rel="noopener">参考</a></p>
<p>其原理是对图进行最多n-1次松弛操作，得到所有可能的最短路径。其边的权重可以是负数，实现简单但是复杂度过高，复杂度为$O(NE)$ 其中N为顶点个数，E为边数。</p>
<p>基本思路：</p>
<ol>
<li><p>初始化时将起点s 到各顶点v的距离dis(s-&gt;v)赋值为 $\infty$，dis(s-&gt;s)赋值为0；</p>
</li>
<li><p>后续进行最多n-1 次遍历，对所有边进行松弛操作；</p>
</li>
<li><p>遍历都结束，若再进行一次遍历，还能得到s 到某些节点更短路径的话，就说明存在负环路（负环路会随着遍历次数的增加而不断减小）</p>
</li>
</ol>
<p>思路上与狄克斯特拉算法最大的不同是每次都是从源点s 重新出发进行 “松弛”更新操作，而狄克斯特拉算法则是从源点出发向外扩逐个处理相邻（最近）的节点。</p>
<h3 id="leetcode743-网络延时时间-2"><a href="#leetcode743-网络延时时间-2" class="headerlink" title="leetcode743 网络延时时间"></a>leetcode743 网络延时时间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. Bellman-Ford算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networdDelay_BellmanFord</span><span class="params">(<span class="built_in">vector</span> &lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T(N + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    T[K] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N - <span class="number">1</span>; ++c) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> src = times[i][<span class="number">0</span>], target = times[i][<span class="number">1</span>], dis = times[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (T[src] != <span class="number">-1</span> &amp;&amp; (T[src] + dis &lt; T[target] || T[target] == <span class="number">-1</span>)) &#123;</span><br><span class="line">                T[target] = T[src] + dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        res = max(res, T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
