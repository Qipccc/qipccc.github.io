<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>URVision</title>
    <url>/2019/12/01/URVision/</url>
    <content><![CDATA[<p>利用计算机视觉技术，对贴砖过程的进行实时校准</p>
<a id="more"></a>
<h1 id="0-基于视觉的UR10机器人贴砖系统"><a href="#0-基于视觉的UR10机器人贴砖系统" class="headerlink" title="0. 基于视觉的UR10机器人贴砖系统"></a>0. 基于视觉的UR10机器人贴砖系统</h1><p>前言: 利用计算机视觉技术，对贴砖过程的进行实时校准。当前文档记录的机器人还是处在固定位置，还没有移动底座，以及视觉相关的算法。接下主要包含两个部分，一个是<a href="##1.UR控制">UR控制部分</a>，一个是<a href="##2.UR视觉">UR视觉部分</a>。控制部分主要按照两个部分来介绍，一个是接收数据部分，接收数据部分现在是通过TCP/IP直接在Processing中读取机箱中的相关数值；另一个是机器人路径规划以及发送数据，控制机器人运动和IO相关的部分，这部分主要在Grasshopper中完成，之后也会脱离GH。</p>
<h1 id="1-UR控制"><a href="#1-UR控制" class="headerlink" title="1.UR控制"></a>1.UR控制</h1><p>UR的脚本编程语言很简单，相关文档可以参考<a href="https://s3-eu-west-1.amazonaws.com/ur-support-site/18679/scriptmanual_en.pdf" target="_blank" rel="noopener">英文文档</a>,<a href="https://github.com/Qipccc/learning-note/blob/master/URControl/doc/%E8%84%9A%E6%9C%AC%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87_3.1%20.pdf" target="_blank" rel="noopener">中文文档</a>。在这里因为是直接利用taco，所以没有太多的涉及。</p>
<h2 id="1-1读取数据"><a href="#1-1读取数据" class="headerlink" title="1.1读取数据"></a>1.1读取数据</h2><p>通过UR的30001或30002或30003特定的编程端口，可以与机器人控制器建立TCP/IP连接，这样我们就可以在上位机上按照URScript语言的格式编写脚本程序，直接发送给机器人控制器，机器人就可以直接执行程序了。可以参考<a href="http://www.ecnc.org.cn/equipment/robot/2015/2015311793_2.html" target="_blank" rel="noopener">这里</a>，但是其中的字节顺序表是存在问题的，可以参考<a href="https://github.com/Qipccc/learning-note/blob/master/URControl/doc/UR%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80.xlsx" target="_blank" rel="noopener">官方的字节顺序表</a>。</p>
<p>下面给出python和java的两个例子：</p>
<blockquote>
<p>python</p>
</blockquote>
<p>主要先用socket读取机箱数据，然后使用struct库对获得的数据流进行解包。struct相关例子可以参考<a href="https://www.cnblogs.com/gala/archive/2011/09/22/2184801.html" target="_blank" rel="noopener">这里</a>。简单的读取UR机箱数据例子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> socket, math, time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">HOST = <span class="string">"10.10.30.2"</span>   <span class="comment">#机箱的IP地址</span></span><br><span class="line">PORT_30003 = <span class="number">30003</span></span><br><span class="line">joins = []</span><br><span class="line">coordinates = []</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    print(<span class="string">"start"</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">     s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">     s.settimeout(<span class="number">10</span>)</span><br><span class="line">     s.connect((HOST, PORT_30003))</span><br><span class="line">     time.sleep(<span class="number">1.00</span>)</span><br><span class="line">     packet_1 = s.recv(<span class="number">12</span>) </span><br><span class="line">     <span class="comment">#Joint A1</span></span><br><span class="line">     packet_3 = s.recv(<span class="number">8</span>)       </span><br><span class="line">     a1 = struct.unpack(<span class="string">'!d'</span>, packet_3)[<span class="number">0</span>]</span><br><span class="line">     joins.append(a1) </span><br><span class="line">     <span class="comment">#Joint A2</span></span><br><span class="line">     packet_4 = s.recv(<span class="number">8</span>)</span><br><span class="line">     a2 = struct.unpack(<span class="string">'!d'</span>, packet_4)[<span class="number">0</span>]</span><br><span class="line">     joins.append(a2)</span><br><span class="line">     <span class="comment">#Joint A3</span></span><br><span class="line">     packet_5 = s.recv(<span class="number">8</span>)</span><br><span class="line">     a3 = struct.unpack(<span class="string">'!d'</span>, packet_5)[<span class="number">0</span>]</span><br><span class="line">     joins.append(a3)</span><br><span class="line">     <span class="comment">#Joint A4</span></span><br><span class="line">     packet_6 = s.recv(<span class="number">8</span>)</span><br><span class="line">     a4 = struct.unpack(<span class="string">'!d'</span>, packet_6)[<span class="number">0</span>]</span><br><span class="line">     joins.append(a4)</span><br><span class="line">     <span class="comment">#Joint A5</span></span><br><span class="line">     packet_7 = s.recv(<span class="number">8</span>)</span><br><span class="line">     a5 = struct.unpack(<span class="string">'!d'</span>, packet_7)[<span class="number">0</span>]</span><br><span class="line">     joins.append(a5)</span><br><span class="line">     <span class="comment">#Joint A6</span></span><br><span class="line">     packet_8 = s.recv(<span class="number">8</span>)</span><br><span class="line">     a6 = struct.unpack(<span class="string">'!d'</span>, packet_8)[<span class="number">0</span>]</span><br><span class="line">     joins.append(a6)            </span><br><span class="line">     <span class="comment">#Skip</span></span><br><span class="line">     packet_9 = s.recv(<span class="number">528</span>)</span><br><span class="line">     <span class="comment">#X</span></span><br><span class="line">     packet_20 = s.recv(<span class="number">8</span>)</span><br><span class="line">     x = struct.unpack(<span class="string">'!d'</span>, packet_20)[<span class="number">0</span>]</span><br><span class="line">     x *= <span class="number">1000</span></span><br><span class="line">     coordinates.append(x)</span><br><span class="line">     <span class="comment">#Y</span></span><br><span class="line">     packet_21 = s.recv(<span class="number">8</span>)</span><br><span class="line">     y = struct.unpack(<span class="string">'!d'</span>, packet_21)[<span class="number">0</span>]</span><br><span class="line">     y *= <span class="number">1000</span></span><br><span class="line">     coordinates.append(y)</span><br><span class="line">     <span class="comment">#Z</span></span><br><span class="line">     packet_22 = s.recv(<span class="number">8</span>)</span><br><span class="line">     z = struct.unpack(<span class="string">'!d'</span>, packet_22)[<span class="number">0</span>]</span><br><span class="line">     z *= <span class="number">1000</span></span><br><span class="line">     coordinates.append(z)</span><br><span class="line">     <span class="comment">#RX</span></span><br><span class="line">     packet_23 = s.recv(<span class="number">8</span>)</span><br><span class="line">     rx = struct.unpack(<span class="string">'!d'</span>, packet_23)[<span class="number">0</span>]            </span><br><span class="line">     coordinates.append(rx)</span><br><span class="line">     <span class="comment">#RY</span></span><br><span class="line">     packet_24 = s.recv(<span class="number">8</span>)</span><br><span class="line">     ry = struct.unpack(<span class="string">'!d'</span>, packet_24)[<span class="number">0</span>]</span><br><span class="line">     coordinates.append(ry)</span><br><span class="line">     <span class="comment">#RZ</span></span><br><span class="line">     packet_25 = s.recv(<span class="number">8</span>)</span><br><span class="line">     rz = struct.unpack(<span class="string">'!d'</span>, packet_25)[<span class="number">0</span>]</span><br><span class="line">     coordinates.append(rz)      </span><br><span class="line">     UR_Joints = joins</span><br><span class="line">     UR_TCP = coordinates</span><br><span class="line">     s.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">"Error: "</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>java</p>
</blockquote>
<p>这里接收数据流主要使用的是java中的DataInputStream相关函数，processing官方也给出了有关socket的<a href="https://processing.org/reference/libraries/net/Client.html" target="_blank" rel="noopener">介绍</a><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//与UR建立通讯 对其进行控制</span></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URCommunication</span></span>&#123;</span><br><span class="line">  String host;</span><br><span class="line">  <span class="keyword">int</span> port;</span><br><span class="line">  DataInputStream is;</span><br><span class="line">  OutputStream out;</span><br><span class="line">  Socket s;</span><br><span class="line">  ArrayList&lt;Double&gt; get_pose = <span class="keyword">new</span> ArrayList&lt;Double&gt;();<span class="comment">//机器人姿态数据</span></span><br><span class="line">  ArrayList&lt;Double&gt; get_joint = <span class="keyword">new</span> ArrayList&lt;Double&gt;(); <span class="comment">//机器人关节位置</span></span><br><span class="line">  <span class="keyword">int</span> digital_output; <span class="comment">//机器人数字输出</span></span><br><span class="line">  <span class="keyword">float</span> tcp_speed = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">URCommunication</span><span class="params">(String host)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.host = host;</span><br><span class="line">    <span class="keyword">this</span>.port = <span class="number">30003</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      s = <span class="keyword">new</span> Socket(host,port);</span><br><span class="line">      s.setSoTimeout(<span class="number">2000</span>);</span><br><span class="line">      is = <span class="keyword">new</span> DataInputStream(s.getInputStream());</span><br><span class="line">      </span><br><span class="line">      out = s.getOutputStream(); <span class="comment">//向UR写数据</span></span><br><span class="line">      </span><br><span class="line">      is.skipBytes(<span class="number">12</span>); <span class="comment">//跳过前12个字节</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; <span class="number">6</span>;i++)&#123; <span class="comment">//读取6个轴的信息</span></span><br><span class="line">        <span class="keyword">double</span> a = is.readDouble();</span><br><span class="line">        get_joint.add(a);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      is.skipBytes(<span class="number">528</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; <span class="number">6</span>;i++)&#123; <span class="comment">//读取姿态信息的信息</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">3</span>)&#123;</span><br><span class="line">          x = is.readDouble() * <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          x = is.readDouble();</span><br><span class="line">        &#125;</span><br><span class="line">        get_pose.add(x);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> x = is.readDouble();</span><br><span class="line">        <span class="keyword">float</span> x_f = (<span class="keyword">float</span>)x;</span><br><span class="line">        tcp_speed = tcp_speed + x_f*x_f;</span><br><span class="line">      &#125;</span><br><span class="line">      tcp_speed = sqrt(tcp_speed);</span><br><span class="line">      </span><br><span class="line">      is.skipBytes(<span class="number">360</span>); <span class="comment">//跳过456个字节</span></span><br><span class="line">      digital_output = (<span class="keyword">int</span>)is.readDouble(); <span class="comment">//得到数字输出</span></span><br><span class="line">      </span><br><span class="line">    &#125;<span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">   &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closing_io</span><span class="params">(<span class="keyword">int</span> io_num)</span></span>&#123;</span><br><span class="line">    String io_num_str = str(io_num);</span><br><span class="line">    PrintWriter bufw=<span class="keyword">new</span> PrintWriter(out,<span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    bufw.println(<span class="string">"set_digital_out("</span> + io_num_str +<span class="string">",False)"</span>);<span class="comment">//发送数据给服务端</span></span><br><span class="line">    println(<span class="string">"closing success"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeUR</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      s.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">   &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当然其实通过端口30003不仅可以读取数据，也是可以发送数据，以达到控制UR的效果，简单的命令基本通过发送字符串就可以实现，当然在python中还有一个<a href="https://github.com/SintefManufacturing/python-urx" target="_blank" rel="noopener">URX</a>库，可以实现对UR的控制，功能也比较齐全，之后也会使用这个库做些尝试。</p>
<h2 id="1-2发送数据-机器人规划"><a href="#1-2发送数据-机器人规划" class="headerlink" title="1.2发送数据(机器人规划)"></a>1.2发送数据(机器人规划)</h2><p>发送数据即为目前的控制部分，这部分主要是由Grasshopper部分完成，之后会使用python + urx完成控制路径的规划，这里主要介绍一些目前的几个部分，以及控制逻辑。<br>总体流程是：</p>
<ul>
<li><p>信息初始化，生成瓷砖抓取位置，并根据一些初始化信息计算出之后每块瓷砖大概放置位置</p>
</li>
<li><p>放置初始瓷砖，并让机器人移动至下一个位置</p>
</li>
<li><p>到达指定位置后，等待接收processing发出的信号</p>
</li>
<li><p>接收processing的信号，进行下一步移动</p>
</li>
</ul>
<h3 id="1-2-1初始化"><a href="#1-2-1初始化" class="headerlink" title="1.2.1初始化"></a>1.2.1初始化</h3><p>主要进行一下的一些初始化：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/PositionInitialize.jpg"/></p>
<p>需要说明的是 <strong>水平方向点</strong>，该点是瓷砖水平方向上的一个点，通过人为设置，主要用来设置贴砖的方向。<strong>移动平面</strong> 高度是指机器人吸取瓷砖后在这个平面高度移动瓷砖到指定的位置。</p>
<h3 id="1-2-2-生成瓷砖吸取位置"><a href="#1-2-2-生成瓷砖吸取位置" class="headerlink" title="1.2.2 生成瓷砖吸取位置"></a>1.2.2 生成瓷砖吸取位置</h3><p>将初始吸砖位置、排列砖的列数和行数，以及砖的厚度发送到后面的 <code>C#</code> 代码中(代码如下)，可以得到瓷砖的排列高度。这些高度都是以点的形式存在。<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">List&lt;Point3d&gt; listPickPos = <span class="keyword">new</span> List&lt;Point3d&gt;();</span><br><span class="line">    <span class="keyword">int</span> n = width * height;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      listPickPos.Add(<span class="keyword">new</span> Point3d(pickPos.X, pickPos.Y, pickPos.Z + (i * thickness)));</span><br><span class="line">    &#125;</span><br><span class="line">    A = listPickPos;</span><br></pre></td></tr></table></figure><br>有了这些信息，就可以在知道要贴第几块砖的情况下，告诉UR到达指定高度吸取瓷砖。</p>
<h3 id="1-2-3生成放置瓷砖位置"><a href="#1-2-3生成放置瓷砖位置" class="headerlink" title="1.2.3生成放置瓷砖位置"></a>1.2.3生成放置瓷砖位置</h3><p>GH中的电池如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/GetPlacePos.jpg"/></p>
<p>简单来说就是根据在初始瓷砖的基础上，在规定的方向上，每隔一定间隔放置一块瓷砖，这个间隔由前面设置的瓷砖的宽度决定。最后就会输出一些点，这些表示每一块瓷砖应该放置的大概位置。</p>
<h3 id="1-2-4由点生成路径"><a href="#1-2-4由点生成路径" class="headerlink" title="1.2.4由点生成路径"></a>1.2.4由点生成路径</h3><p>在得到吸取瓷砖和放置瓷砖的点集后即可以生成机器人运动路径和I/O控制命令。GH中的电池图如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/GeneratePath.jpg"/></p>
<p><strong>注意</strong> 其中的number，指的是从processing获得的第几块砖的信息。有了这个信息才能准确的生成对应的放置瓷砖的位置。</p>
<p>该段代码目前由<code>C#</code>编写，如下：<br><figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RunScript</span>(<span class="params"><span class="keyword">bool</span> reset, List&lt;Point3d&gt; pickPos, DataTree&lt;Point3d&gt; placePos, <span class="keyword">double</span> height, <span class="keyword">double</span> height2, <span class="keyword">int</span> number, <span class="keyword">ref</span> <span class="keyword">object</span> P, <span class="keyword">ref</span> <span class="keyword">object</span> O, <span class="keyword">ref</span> <span class="keyword">object</span> S</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">int</span> picknum = pickPos.Count;</span><br><span class="line">    List&lt;Point3d&gt; robotPath = <span class="keyword">new</span> List&lt;Point3d&gt;(); <span class="comment">//运动路径</span></span><br><span class="line">    List&lt;<span class="keyword">string</span>&gt; io = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;(); <span class="comment">//io信号控制</span></span><br><span class="line">    List&lt;<span class="keyword">string</span>&gt; sleep = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;(); <span class="comment">//延时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> waitTime = <span class="string">"1"</span>; <span class="comment">//电缸运动时间，用时间控制电缸的行程</span></span><br><span class="line">    <span class="keyword">int</span> last_index = pickPos.Count - <span class="number">1</span>; <span class="comment">// 瓷砖的总高度</span></span><br><span class="line">    <span class="keyword">int</span> BranchCount = placePos.BranchCount; <span class="comment">//放置瓷砖的brach个数,可以理解为行数</span></span><br><span class="line">    <span class="keyword">int</span> ListPointNum = placePos.Branch(<span class="number">0</span>).Count;</span><br><span class="line">    <span class="keyword">int</span> index_row = number / ListPointNum; <span class="comment">//判断现在是第几行</span></span><br><span class="line">    <span class="keyword">int</span> index_col = number % ListPointNum; <span class="comment">//判断现在是第几列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = number;  <span class="comment">//目前贴的是第几块瓷砖</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!reset)&#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">      robotPath = <span class="keyword">new</span> List&lt;Point3d&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;  <span class="comment">//Robot Path for first pannel</span></span><br><span class="line">      Print(<span class="string">"HELLO FIRST PATH"</span>);</span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(pickPos[<span class="number">0</span>].X, pickPos[<span class="number">0</span>].Y, pickPos[<span class="number">0</span>].Z + height)); <span class="comment">//初始位置高度</span></span><br><span class="line">      robotPath.Add(pickPos[last_index]); <span class="comment">//到达第一个瓷砖位置位置</span></span><br><span class="line">      io.Add(<span class="string">"set_digital_out(3,True)"</span>); <span class="comment">// 电缸回收，吸取瓷砖</span></span><br><span class="line">      sleep.Add(<span class="string">"sleep("</span> + waitTime + <span class="string">")"</span>); <span class="comment">//控制行程</span></span><br><span class="line">      io.Add(<span class="string">"set_digital_out(3,False)"</span>); <span class="comment">//电缸结束控制</span></span><br><span class="line"></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(pickPos[<span class="number">0</span>].X, pickPos[<span class="number">0</span>].Y, pickPos[<span class="number">0</span>].Z + height)); <span class="comment">//回到吸瓷砖的初始高度</span></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(placePos.Branch(<span class="number">0</span>)[<span class="number">0</span>].X, placePos.Branch(<span class="number">0</span>)[<span class="number">0</span>].Y, placePos.Branch(<span class="number">0</span>)[<span class="number">0</span>].Z + height2)); <span class="comment">//到达放瓷砖的一个高度位置</span></span><br><span class="line">      robotPath.Add(placePos.Branch(<span class="number">0</span>)[<span class="number">0</span>]); <span class="comment">//到达放瓷砖的位置</span></span><br><span class="line">      io.Add(<span class="string">"set_digital_out(2,True)"</span>); <span class="comment">//电缸伸出，放置瓷砖</span></span><br><span class="line">      sleep.Add(<span class="string">"sleep(1)"</span>);</span><br><span class="line">      io.Add(<span class="string">"set_digital_out(2,False)"</span>);</span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(placePos.Branch(<span class="number">0</span>)[<span class="number">0</span>].X, placePos.Branch(<span class="number">0</span>)[<span class="number">0</span>].Y, placePos.Branch(<span class="number">0</span>)[<span class="number">0</span>].Z + height2)); <span class="comment">//回到放瓷砖的一个高度位置</span></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(pickPos[<span class="number">0</span>].X, pickPos[<span class="number">0</span>].Y, pickPos[<span class="number">0</span>].Z + height));<span class="comment">//回到吸瓷砖的初始高度</span></span><br><span class="line">      robotPath.Add(pickPos[last_index - <span class="number">1</span>]);<span class="comment">//到达第二块瓷砖吸取位置</span></span><br><span class="line">      io.Add(<span class="string">"set_digital_out(3,True)"</span>); <span class="comment">// 电缸回收，吸取瓷砖</span></span><br><span class="line">      sleep.Add(<span class="string">"sleep("</span> + waitTime + <span class="string">")"</span>); <span class="comment">//控制行程</span></span><br><span class="line">      io.Add(<span class="string">"set_digital_out(3,False)"</span>); <span class="comment">//电缸结束控制</span></span><br><span class="line"></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(pickPos[<span class="number">0</span>].X, pickPos[<span class="number">0</span>].Y, pickPos[<span class="number">0</span>].Z + height));</span><br><span class="line"></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(placePos.Branch(<span class="number">0</span>)[<span class="number">1</span>].X, placePos.Branch(<span class="number">0</span>)[<span class="number">1</span>].Y, placePos.Branch(<span class="number">0</span>)[<span class="number">1</span>].Z + height2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span> &amp;&amp; count &lt; pickPos.Count - <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">      robotPath = <span class="keyword">new</span> List&lt;Point3d&gt;(); <span class="comment">//clean path</span></span><br><span class="line">      io = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">      sleep = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">      Print(<span class="string">"GOT POSITION FROM PROCESSING !!"</span>);</span><br><span class="line">      io.Add(<span class="string">"set_digital_out(2,True)"</span>); <span class="comment">//电缸伸出，放置瓷砖</span></span><br><span class="line">      sleep.Add(<span class="string">"sleep(1)"</span>);</span><br><span class="line">      io.Add(<span class="string">"set_digital_out(2,False)"</span>);</span><br><span class="line"></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(placePos.Branch(index_row)[index_col].X, placePos.Branch(index_row)[index_col].Y, placePos.Branch(index_row)[index_col].Z + height2));</span><br><span class="line"></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(pickPos[<span class="number">0</span>].X, pickPos[<span class="number">0</span>].Y, pickPos[<span class="number">0</span>].Z + height));</span><br><span class="line"></span><br><span class="line">      robotPath.Add(pickPos[last_index - count - <span class="number">1</span>]);</span><br><span class="line">      io.Add(<span class="string">"set_digital_out(3,True)"</span>); <span class="comment">// 电缸回收，吸取瓷砖</span></span><br><span class="line">      sleep.Add(<span class="string">"sleep("</span> + waitTime + <span class="string">")"</span>); <span class="comment">//控制行程</span></span><br><span class="line">      io.Add(<span class="string">"set_digital_out(3,False)"</span>); <span class="comment">//电缸结束控制</span></span><br><span class="line"></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(pickPos[<span class="number">0</span>].X, pickPos[<span class="number">0</span>].Y, pickPos[<span class="number">0</span>].Z + height));</span><br><span class="line">      <span class="keyword">if</span>(index_col + <span class="number">1</span> &lt; ListPointNum)&#123;</span><br><span class="line">        robotPath.Add(<span class="keyword">new</span> Point3d(placePos.Branch(index_row)[index_col + <span class="number">1</span>].X, placePos.Branch(index_row)[index_col + <span class="number">1</span>].Y, placePos.Branch(index_row)[index_col + <span class="number">1</span>].Z + height2));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        robotPath.Add(<span class="keyword">new</span> Point3d(placePos.Branch(index_row + <span class="number">1</span>)[<span class="number">0</span>].X, placePos.Branch(index_row + <span class="number">1</span>)[<span class="number">0</span>].Y, placePos.Branch(index_row + <span class="number">1</span>)[<span class="number">0</span>].Z + height2));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count == pickPos.Count - <span class="number">1</span>)&#123;</span><br><span class="line">      robotPath = <span class="keyword">new</span> List&lt;Point3d&gt;(); <span class="comment">//clean path</span></span><br><span class="line">      io = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">      sleep = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">      Print(<span class="string">"GOT POSITION FROM PROCESSING ,the last one!!"</span>);</span><br><span class="line"></span><br><span class="line">      io.Add(<span class="string">"set_digital_out(2,True)"</span>); <span class="comment">//电缸伸出，放置瓷砖</span></span><br><span class="line">      sleep.Add(<span class="string">"sleep(1)"</span>);</span><br><span class="line">      io.Add(<span class="string">"set_digital_out(2,False)"</span>);</span><br><span class="line"></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(pickPos[<span class="number">0</span>].X, pickPos[<span class="number">0</span>].Y, pickPos[<span class="number">0</span>].Z + height)); <span class="comment">//回到吸瓷砖的初始高度</span></span><br><span class="line">    &#125;</span><br><span class="line">    P = robotPath;</span><br><span class="line">    O = io;</span><br><span class="line">    S = sleep;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>最后会输出全部的路径点、I/O信号以及延时信号。<br>关于路径点，简单来说可以分成两个部分，一个部分是贴第一块瓷砖的路径，包含10个点；另一个部分是放下瓷砖后回去取下一个瓷砖并达到指定拍摄位置的路径，这中间包含5个点。</p>
<blockquote>
<p><strong>第一部分</strong></p>
</blockquote>
<p>初始位置是处于较高处的一个平面，最后会停留在第二块瓷砖放置位置的上方进行拍照获得特征信息，由特征信息对机器人姿态进行纠正，到达放置位置，等待放置瓷砖的信号.</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/soogif.gif"/></p>
<p>接收到放置瓷砖的信号后，机器人末端工具头就会放下瓷砖，然后进入第二部分。</p>
<blockquote>
<p><strong>第二部分</strong></p>
</blockquote>
<p>放下瓷砖后，机器人会先进行太高，然后吸取第二块瓷砖，最后到达下一块瓷砖放置位置的上方。</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/urgif.gif"/></p>
<p>之后的每一块瓷砖的放置都是循环第二部分。</p>
<h3 id="1-2-5接收Processing数据"><a href="#1-2-5接收Processing数据" class="headerlink" title="1.2.5接收Processing数据"></a>1.2.5接收Processing数据</h3><p>在接收processing数据部分，目前是设置了两个端口，一个端口用来接收瓷砖的纠正数据，该数据用来旋转或平移瓷砖以达到贴合的目的，但 <strong>注意</strong> 此时的瓷砖还是吸住未放下的状态。另一个端口就是用来接收使吸盘放下瓷砖的信号，同时该信号也包含了该瓷砖的为第几块瓷砖的信息。</p>
<p><strong>纠正数据</strong> 主要包含一下信息：</p>
<blockquote>
<ol>
<li>贴近类型(type)</li>
</ol>
</blockquote>
<p>在之前的多次测试中发现，如果两块瓷砖在相对合适（不是很近也不是很远）的位置进行拍照与靠近时可以达到比较好的效果，所以在这里，会现在processing中判断是否满足条件，如果满足则机器人可以直接贴近，如果不满足则可以适当保持一定的距离。这里使用的盘算条件如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((coord_offset_left &lt; <span class="number">5.2</span>) &amp; (coord_offset_right &lt; <span class="number">0.6</span>) &amp; (angle_delta_real &lt; <span class="number">0.4</span>) &amp; (coord_offset_left &gt; <span class="number">1</span>))&#123;</span><br><span class="line">          send_data_auto(<span class="number">1</span>);  <span class="comment">//说明位置正确可以靠近</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          send_data_auto(<span class="number">2</span>);  <span class="comment">//距离较远 先靠近一点</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>UR机器人当前位置信息(robot_pose)</li>
</ol>
</blockquote>
<p>机器人位置信息（X,Y,Z,RX,RY,RZ）现在是由processing通过TCP/IP实时地从机箱读取,有了该信息，机器人就可以在该信息的基础上进行运动。</p>
<blockquote>
<ol>
<li>角度偏差(angle_delta_real)</li>
</ol>
</blockquote>
<p>在processing中计算得到两块瓷砖的边缘直线的角度偏差，将角度偏差发送给机器人使其纠正，使两块瓷砖尽量保持平行。目前，无论是哪一种位置类型，都是计算y方向的边缘直线方程，以使该边缘平行。</p>
<blockquote>
<ol>
<li>左拐点位置信息(corner_coord_left)</li>
</ol>
</blockquote>
<p>左拐点就是表示UR末端工具头吸取的那块瓷砖的角点。</p>
<blockquote>
<ol>
<li>右拐点位置信息(corner_coord_right)</li>
</ol>
</blockquote>
<p>右拐点指的时前一块已经放置好的瓷砖的角点，该点就是瓷砖贴合时的参考点。</p>
<blockquote>
<ol>
<li>右拐点参考点位置信息(corner_right_refer)</li>
</ol>
</blockquote>
<p>因为需要使瓷砖和瓷砖之间保持间隙，所以间隙的方向就由该点确定，只需要根据前面算出来的边缘直线就可以计算出参考点的信息。</p>
<p><strong>放置信号</strong> 主要包括以下部分：</p>
<p>这部分主要包含当前瓷砖的数量(number)信息，因为目前图像识别部分和机器人规划部分是分别由processing和GH组成，所以需要在processing中对贴瓷砖的次数进行计数，当得到该信号后就表示机器人应该将瓷砖放下并取下一块瓷砖。</p>
<h3 id="1-2-6贴砖策略"><a href="#1-2-6贴砖策略" class="headerlink" title="1.2.6贴砖策略"></a>1.2.6贴砖策略</h3><p>整个贴砖策略流程图如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/贴砖策略示意图.jpg"/></p>
<p>现在放置瓷砖的信号是通过图像来判断，通过点击相关按钮实现瓷砖的放置。</p>
<h3 id="1-2-7-I-O说明"><a href="#1-2-7-I-O说明" class="headerlink" title="1.2.7 I/O说明"></a>1.2.7 I/O说明</h3><p>目前使用的I/O口有：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">io4: 用来打开和关闭相机</span><br><span class="line">io2: 电缸伸出，放置瓷砖</span><br><span class="line">io3：电缸回收，吸取瓷砖</span><br></pre></td></tr></table></figure></p>
<p>在<code>C#</code>中写好何时伸出电缸，何时放置电缸的程序。</p>
<h1 id="2-UR视觉"><a href="#2-UR视觉" class="headerlink" title="2.UR视觉"></a>2.UR视觉</h1><p>该部分主要又两部分组成，一个是手眼标定部分，一个是图像处理部分。</p>
<h2 id="2-1-手眼标定"><a href="#2-1-手眼标定" class="headerlink" title="2.1 手眼标定"></a>2.1 手眼标定</h2><p>机器人的运动控制实际上是基于其基座(base)坐标下的点坐标来进行的，所以当相机采集到图像后，需要将图像上的点转换到世界坐标下才可以使机械臂到达指定位置。他们之间的转换涉及到多个转换矩阵，其中最关键的就是工具头末端和相机之间的转换矩阵，也称为手眼转换矩阵。</p>
<p>手眼标定(Hand-eye claibration problem)，可以分为两种情况:<strong>局部手眼</strong>，<strong>全局手眼</strong>。</p>
<p><strong>局部手眼(eye-in-hand)</strong>：也叫随动手眼,相机随着机器人末端进行移动；</p>
<p><strong>全局手眼(eye-to-hand)</strong>：也叫固定手眼，相机是不动的，观察机器人移动。</p>
<p><img src="https://pic3.zhimg.com/80/v2-7b613c28b0ca55f86b20a5f281d8ddf2_hd.jpg" alt="Hand-eye claibration problem"></p>
<p>因为在这里，机器人位于移动底盘上，所以相机必须要跟着机器人一起移动，所以采用 <strong>局部手眼(eye-in-hand)</strong> 的方式。</p>
<h3 id="2-1-1-转换矩阵的确定"><a href="#2-1-1-转换矩阵的确定" class="headerlink" title="2.1.1 转换矩阵的确定"></a>2.1.1 转换矩阵的确定</h3><p>主要是三个转换矩阵：</p>
<p>注意：下面讲到的所有世界坐标系都是指UR机器人的的基座坐标系。</p>
<ol>
<li>末端工具头坐标系到世界坐标系的转换矩阵。</li>
<li>相机坐标系到像素坐标系之间的转换矩阵。</li>
<li>相机坐标系到末端工具头坐标系之间的转换矩阵。</li>
</ol>
<blockquote>
<p>末端工具头坐标系到世界坐标系转换矩阵($H^{-1}_{rg}$)</p>
</blockquote>
<p>下标中的r就表示机器人世界坐标系，g表示末端工具头坐标系</p>
<p>这一部分的转换矩阵不需要进行标定，只需要读取末端工具头的位置信息，在这里UR的工具头末端信息是X,Y,Z,RX,RY,RZ。X,Y,Z表示的是位置坐标，RX,RY,RZ表示的<a href="https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions" target="_blank" rel="noopener">旋转向量</a>。为了便于转换矩阵的计算，需要将这个6个值转换成描述矩阵的形式:</p>
<script type="math/tex; mode=display">H = \begin{bmatrix}R & T\\\\0 &1\end{bmatrix}</script><p>其中$R$为旋转矩阵($3\times3$)，$T$为平移向量($3\times1$)。<br>旋转矩阵由旋转向量经<a href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula" target="_blank" rel="noopener">罗德里格斯变换</a>可以转换而成。在opencv中直接使用<a href="https://docs.opencv.org/3.4.0/d9/d0c/group__calib3d.html#ga61585db663d9da06b68e70cfbf6a1eac" target="_blank" rel="noopener">rodrigues</a>函数就可以进行转换。</p>
<blockquote>
<p>像素坐标系到相机坐标系转换矩阵($H_{pc}$)</p>
</blockquote>
<p>简单来说就是将图像像素坐标上的点转换到相机坐标系。</p>
<p><strong>图像像素坐标：</strong> 图像像素坐标系是以左上角为零点，水平向右为x正方向，垂直向下为y正方向，如下图所示：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/1517784-14301c0d3f6eed8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/511/format/webp" alt=""></p>
<p>所以像素坐标系与相机坐标系之间的转换关系其实就是计算相机的内部参数矩阵，而这部分是需要通过标定板来进行标定的。关于相机标定，opencv官方就已经由一些<a href="https://docs.opencv.org/3.4.2/d4/d94/tutorial_camera_calibration.html" target="_blank" rel="noopener">解释</a>，同时在官方github中也有了calibrate的<a href="https://github.com/opencv/opencv/blob/3.4/samples/python/calibrate.py" target="_blank" rel="noopener">例子</a>，参考这些就可以把内部参数求解出来。当我们使用相机标定矩阵时，注意标定板应该在固定位置保持不变，使机器人在大概12个不同的位置角度对其进行拍摄。</p>
<p>这里$H_{pc}$是相机内部参数矩阵的增广矩阵:</p>
<script type="math/tex; mode=display">H_{pc} = \begin{bmatrix} cameraMatrix \mid 0\end{bmatrix}_{3 \times 4}</script><blockquote>
<p>相机坐标系到工具头坐标系转换矩阵($H_{cg}$)</p>
</blockquote>
<p>相机坐标系与工具头坐标系之间的转换就是所谓的手眼转换。（前提是相机与工具头之间的关系是固定的）</p>
<p><img src="https://torsteinmyhre.name/snippets/robcam_calibration/images/extrinsic-camera-calibration-eye-in-hand-651px.png" alt="calibrate eye in hand"></p>
<p>手眼标定的主要目的就是标定相机和工具头末端之间的转换矩阵($H_{cg}$)，在上图中为$X$。</p>
<p><strong>求解思路：</strong></p>
<p>为了便于解释，使用如下图：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/calibrate1.png"/></p>
<p>如图所示，</p>
<p>$C_i$：相机的位置坐标（由opencv中的张氏标定可以算出相机的外部参数矩阵，即为相机的位置）</p>
<p>$G_i$：工具头末端位置坐标（可由机箱直接读到此时的位置信息）</p>
<p>$CW$：标定板坐标系</p>
<p>$RW$: 机器人坐标系</p>
<p>上图表示的是工具头和相机分别在$n$个位置对标定板进行拍摄。</p>
<p>进一步的：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/calibrate2.png"/></p>
<p>$H_{ci}$：从$CW$到$C_i$的坐标转换</p>
<p>$H_{gi}$：从$G_i$到$RW$的坐标转换</p>
<p>$H_{gij}$：从$G_i$到$G_j$的坐标转换</p>
<p>$H_{cij}$：从$C_i$到$C_j$的坐标转换</p>
<p>$H_{cg}$：从$C_i$到$G_j$的坐标转换</p>
<p>其中：</p>
<script type="math/tex; mode=display">H = \begin{bmatrix}R & T\\\\0 &1\end{bmatrix}</script><p>$R$为旋转矩阵($3\times3$)，$T$为平移向量($3\times1$)。</p>
<p>因为：</p>
<script type="math/tex; mode=display">
\begin{cases}
H_{gi}=H_{cg}H_{ci} \\\\
H_{gj}=H_{gij}H_{gi} \\\\
H_{cj}=H_{cij}H_{ci}
\end{cases}</script><p>所以可以得到：</p>
<script type="math/tex; mode=display">H_{gij}H_{cg} = H_{cg}H_{cij}</script><p>所以实际只要三个位置就可以计算出手眼转换矩阵$H_{cg}$，但因为通常需要10个位置左右才能得到比较准确的得到相机的外部参数矩阵，所以实际上还是需要在10个以上位置拍摄标定板。</p>
<p>求解$H_{cg}$也是比较麻烦的一个部分，这里我参考的是<a href="https://blog.csdn.net/Xiongchao99/article/details/52850990" target="_blank" rel="noopener">这篇博客</a>中介绍的求解方式。</p>
<p>求解$H_{cg}$的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.opencv.core.*;</span><br><span class="line"><span class="keyword">import</span> org.opencv.imgproc.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math3.linear.Array2DRowRealMatrix;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math3.linear.LUDecomposition;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math3.linear.RealMatrix;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math3.analysis.function.Acos;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math3.analysis.function.Sin;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math3.geometry.euclidean.threed.Vector3D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate_Hcg</span></span>&#123;</span><br><span class="line">  Acos acos;</span><br><span class="line">  Sin sin;</span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt; Hc;<span class="comment">//相机描述矩阵</span></span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt; Hcij;<span class="comment">//相机ij位置的转换矩阵</span></span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt; Hg;<span class="comment">//工具描述矩阵</span></span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt; Hgij;<span class="comment">//相机ij位置的转换矩阵</span></span><br><span class="line">  <span class="keyword">public</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt; Hcg;<span class="comment">//相机ij位置的转换矩阵</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hcg</span><span class="params">(List&lt;Mat&gt; rc_vec,List&lt;Mat&gt; tc_vec,List&lt;Mat&gt; rg_vec,List&lt;Mat&gt; tg_vec)</span></span>&#123;</span><br><span class="line">  <span class="comment">//传入的参数分别是图像的旋转和平移向量，工具手的旋转和平移向量</span></span><br><span class="line">    <span class="keyword">double</span>[][] hcg_temp;</span><br><span class="line">    get_hcij(rc_vec,tc_vec);</span><br><span class="line">    get_hgij(rg_vec,tg_vec);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Hgij.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      hcg_temp = caluate_Hcg(Hcij.get(i),Hcij.get(i+<span class="number">1</span>),Hgij.get(i),Hgij.get(i+<span class="number">1</span>));</span><br><span class="line">      Hcg.add(hcg_temp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> Vector3D <span class="title">caluate_k</span><span class="params">(<span class="keyword">double</span>[][] data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> R[][] = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">        R[i][j] = data[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> w_temp[]= <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">double</span> trace = R[<span class="number">0</span>][<span class="number">0</span>]+R[<span class="number">1</span>][<span class="number">1</span>]+R[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">float</span> trace_f = (<span class="keyword">float</span>) trace;</span><br><span class="line">    <span class="keyword">double</span> q = acos((trace_f - <span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">float</span> q_f = (<span class="keyword">float</span>) q;</span><br><span class="line">    w_temp[<span class="number">0</span>] = q/(<span class="number">2</span>*sin(q_f))*(R[<span class="number">2</span>][<span class="number">1</span>] - R[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    w_temp[<span class="number">1</span>] = q/(<span class="number">2</span>*sin(q_f))*(R[<span class="number">0</span>][<span class="number">2</span>] - R[<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">    w_temp[<span class="number">2</span>] = q/(<span class="number">2</span>*sin(q_f))*(R[<span class="number">1</span>][<span class="number">0</span>] - R[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    Vector3D w = <span class="keyword">new</span> Vector3D(w_temp);</span><br><span class="line">   <span class="keyword">return</span> w;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealMatrix <span class="title">vect2mat</span><span class="params">(Vector3D k1,Vector3D k2,Vector3D k3)</span></span>&#123;  <span class="comment">//向量转换成矩阵</span></span><br><span class="line">    <span class="keyword">double</span> mat[][] = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    mat[<span class="number">0</span>][<span class="number">0</span>] =   k1.getX();</span><br><span class="line">    mat[<span class="number">1</span>][<span class="number">0</span>] =   k1.getY();</span><br><span class="line">    mat[<span class="number">2</span>][<span class="number">0</span>] =   k1.getZ();</span><br><span class="line">    mat[<span class="number">0</span>][<span class="number">1</span>] =   k2.getX();</span><br><span class="line">    mat[<span class="number">1</span>][<span class="number">1</span>] =   k2.getY();</span><br><span class="line">    mat[<span class="number">2</span>][<span class="number">1</span>] =   k2.getZ();</span><br><span class="line">    mat[<span class="number">0</span>][<span class="number">2</span>] =   k3.getX();</span><br><span class="line">    mat[<span class="number">1</span>][<span class="number">2</span>] =   k3.getY();</span><br><span class="line">    mat[<span class="number">2</span>][<span class="number">2</span>] =   k3.getZ();</span><br><span class="line">    RealMatrix realmat = <span class="keyword">new</span> Array2DRowRealMatrix(mat);</span><br><span class="line">    <span class="keyword">return</span> realmat;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealMatrix <span class="title">get_tvec</span><span class="params">(<span class="keyword">double</span>[][] Hij)</span></span>&#123; <span class="comment">//得到平移向量</span></span><br><span class="line">    <span class="keyword">double</span> tvecs[][] = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">    tvecs[<span class="number">0</span>][<span class="number">0</span>] = Hij[<span class="number">0</span>][<span class="number">3</span>];</span><br><span class="line">    tvecs[<span class="number">1</span>][<span class="number">0</span>] = Hij[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    tvecs[<span class="number">2</span>][<span class="number">0</span>] = Hij[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    RealMatrix tvecs_mat = <span class="keyword">new</span> Array2DRowRealMatrix(tvecs);</span><br><span class="line">    <span class="keyword">return</span> tvecs_mat;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealMatrix <span class="title">matrix_sub</span><span class="params">(RealMatrix v1,RealMatrix v2)</span></span>&#123; <span class="comment">//矩阵相减</span></span><br><span class="line">    <span class="keyword">assert</span>(v1.getColumnDimension()== v2.getColumnDimension());</span><br><span class="line">    <span class="keyword">assert</span>(v1.getRowDimension()== v2.getRowDimension());</span><br><span class="line">    <span class="keyword">int</span> row = (<span class="keyword">int</span>) v1.getRowDimension();</span><br><span class="line">    <span class="keyword">int</span> col = (<span class="keyword">int</span>) v1.getColumnDimension();</span><br><span class="line">    <span class="keyword">double</span> sub_mat[][] = <span class="keyword">new</span> <span class="keyword">double</span>[row][col];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">        sub_mat[i][j] = v1.getData()[i][j] - v2.getData()[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RealMatrix sub_realmat = <span class="keyword">new</span> Array2DRowRealMatrix(sub_mat);</span><br><span class="line">    <span class="keyword">return</span> sub_realmat;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealMatrix <span class="title">doublearr_sub_eye</span><span class="params">(<span class="keyword">double</span>[][] H)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> H_size3[][] = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">        H_size3[i][j] = H[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H_size3[<span class="number">0</span>][<span class="number">0</span>] = H_size3[<span class="number">0</span>][<span class="number">0</span>] -<span class="number">1</span>;</span><br><span class="line">    H_size3[<span class="number">1</span>][<span class="number">1</span>] = H_size3[<span class="number">1</span>][<span class="number">1</span>] -<span class="number">1</span>;</span><br><span class="line">    H_size3[<span class="number">2</span>][<span class="number">2</span>] = H_size3[<span class="number">2</span>][<span class="number">2</span>] -<span class="number">1</span>;</span><br><span class="line">    RealMatrix H_mat = <span class="keyword">new</span> Array2DRowRealMatrix(H_size3);</span><br><span class="line">    <span class="keyword">return</span> H_mat;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealMatrix <span class="title">appendmat</span><span class="params">(RealMatrix m1,RealMatrix m2)</span></span>&#123; <span class="comment">//两个矩阵append</span></span><br><span class="line">    <span class="keyword">int</span> row1 = (<span class="keyword">int</span>) m1.getRowDimension();</span><br><span class="line">    <span class="keyword">int</span> row2 = (<span class="keyword">int</span>) m2.getRowDimension();</span><br><span class="line">    <span class="keyword">int</span> col1 = (<span class="keyword">int</span>) m1.getColumnDimension();</span><br><span class="line">    <span class="keyword">int</span> col2 = (<span class="keyword">int</span>) m2.getColumnDimension();</span><br><span class="line">    <span class="keyword">int</span> new_row = row1+row2;</span><br><span class="line">    <span class="keyword">assert</span>(col1==col2);</span><br><span class="line">    <span class="keyword">double</span> new_mat[][] = <span class="keyword">new</span> <span class="keyword">double</span>[row1+row2][col1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;new_row;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i&lt;row1)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;col1;j++)&#123;</span><br><span class="line">          new_mat[i][j] = m1.getData()[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;col1;k++)&#123;</span><br><span class="line">          new_mat[i][k] = m2.getData()[i-row1][k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RealMatrix H_mat = <span class="keyword">new</span> Array2DRowRealMatrix(new_mat);</span><br><span class="line">    <span class="keyword">return</span> H_mat;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span>[][] get_hcg(RealMatrix R,RealMatrix t)&#123; </span><br><span class="line">    <span class="keyword">double</span> Hcg[][] = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;<span class="number">3</span>)&#123;</span><br><span class="line">          Hcg[i][j] = R.getData()[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          Hcg[i][j] = t.getData()[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Hcg[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    Hcg[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    Hcg[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    Hcg[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Hcg;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span>[][] caluate_Hcg(<span class="keyword">double</span>[][] hcij1,<span class="keyword">double</span>[][] hcij2,<span class="keyword">double</span>[][] hgij1,<span class="keyword">double</span>[][] hgij2)&#123;</span><br><span class="line">    Vector3D kc1 = caluate_k(hcij1);  <span class="comment">//3x1列向量</span></span><br><span class="line">    Vector3D kc2 = caluate_k(hcij2);</span><br><span class="line">    Vector3D kd1 = caluate_k(hgij1);</span><br><span class="line">    Vector3D kd2 = caluate_k(hgij2);</span><br><span class="line">    Vector3D kc3 = Vector3D.crossProduct(kc1,kc2); <span class="comment">//1x3</span></span><br><span class="line">    Vector3D kd3 = Vector3D.crossProduct(kd1,kd2);</span><br><span class="line">    RealMatrix a_temp = vect2mat(kc1,kc2,kc3);</span><br><span class="line">    RealMatrix b_temp = vect2mat(kd1,kd2,kd3);</span><br><span class="line">    RealMatrix R = a_temp.multiply(inverseMatrix(b_temp));  <span class="comment">//  旋转矩阵3x3</span></span><br><span class="line">    RealMatrix tc1 = get_tvec(hcij1);</span><br><span class="line">    RealMatrix tc2 = get_tvec(hcij2);</span><br><span class="line">    RealMatrix td1 = get_tvec(hgij1);</span><br><span class="line">    RealMatrix td2 = get_tvec(hgij2);</span><br><span class="line">    RealMatrix c = matrix_sub(R.multiply(td1),tc1); <span class="comment">//3X1</span></span><br><span class="line">    RealMatrix d = matrix_sub(R.multiply(td2),tc2);</span><br><span class="line">    RealMatrix a = doublearr_sub_eye(hcij1);  <span class="comment">//3x3</span></span><br><span class="line">    RealMatrix b = doublearr_sub_eye(hcij2);</span><br><span class="line">    RealMatrix h = appendmat(a,b);</span><br><span class="line">    RealMatrix y = appendmat(c,d);</span><br><span class="line">    RealMatrix t = inverseMatrix(h.transpose().multiply(h)).multiply(h.transpose()).multiply(y); <span class="comment">//平移向量3x1</span></span><br><span class="line">    <span class="keyword">double</span>[][] Hcg = get_hcg(R,t);</span><br><span class="line">    <span class="keyword">return</span> Hcg;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">get_hcij</span><span class="params">(List&lt;Mat&gt; rc_vec,List&lt;Mat&gt; tc_vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] h_temp;<span class="comment">//存放描述矩阵的临时值</span></span><br><span class="line">    RealMatrix hcij;<span class="comment">//计算ij矩阵</span></span><br><span class="line">    Hc = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt;();  <span class="comment">//相机的描述矩阵</span></span><br><span class="line">    Hcij = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt;(); <span class="comment">//相机ij位置的转换矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rc_vec.size();i++)&#123;</span><br><span class="line">      h_temp = getH(rc_vec.get(i),tc_vec.get(i));<span class="comment">//4x4的数组,double[][]类型</span></span><br><span class="line">     <span class="comment">// double htoarray[][]=h_temp.getData();//转换成数组</span></span><br><span class="line">      Hc.add(h_temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;rc_vec.size()-<span class="number">1</span>;j++)&#123;</span><br><span class="line">     <span class="comment">// double[][] b = Hc.get(j);  //还需要将数组转换成矩阵的形式</span></span><br><span class="line">      RealMatrix mat1 = <span class="keyword">new</span> Array2DRowRealMatrix(Hc.get(j));<span class="comment">//还需要将数组转换成矩阵的形式</span></span><br><span class="line">      RealMatrix mat2 = <span class="keyword">new</span> Array2DRowRealMatrix(Hc.get(j+<span class="number">1</span>));</span><br><span class="line">      hcij = mat1.multiply(inverseMatrix(mat2)); <span class="comment">//matrix格式</span></span><br><span class="line">      <span class="keyword">double</span> hcijtoarray[][]=hcij.getData();<span class="comment">//转换成数组</span></span><br><span class="line">      Hcij.add(hcijtoarray);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">get_hgij</span><span class="params">(List&lt;Mat&gt; rg_vec,List&lt;Mat&gt; tg_vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] h_temp;<span class="comment">//存放描述矩阵的临时值</span></span><br><span class="line">    RealMatrix hgij;<span class="comment">//计算ij矩阵</span></span><br><span class="line">    Hg = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt;();  <span class="comment">//机械臂的描述矩阵</span></span><br><span class="line">    Hgij = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt;(); <span class="comment">//机械臂ij位置的转换矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rg_vec.size();i++)&#123;</span><br><span class="line">      h_temp = getH(rg_vec.get(i),tg_vec.get(i));<span class="comment">//4x4的数组,double[][]类型</span></span><br><span class="line">      Hg.add(h_temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;rg_vec.size()-<span class="number">1</span>;j++)&#123;</span><br><span class="line">     <span class="comment">// double[][] b = Hc.get(j);  //还需要将数组转换成矩阵的形式</span></span><br><span class="line">      RealMatrix mat1 = <span class="keyword">new</span> Array2DRowRealMatrix(Hg.get(j));<span class="comment">//还需要将数组转换成矩阵的形式</span></span><br><span class="line">      RealMatrix mat2 = <span class="keyword">new</span> Array2DRowRealMatrix(Hg.get(j+<span class="number">1</span>));</span><br><span class="line">      hgij = inverseMatrix(mat1).multiply(mat2); <span class="comment">//matrix格式</span></span><br><span class="line">      <span class="keyword">double</span> hgijtoarray[][]=hgij.getData();<span class="comment">//转换成数组</span></span><br><span class="line">      Hgij.add(hgijtoarray);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span>[][] getH(Mat rvecs,Mat tvecs) &#123;<span class="comment">//将旋转向量和平移向量转换成矩阵</span></span><br><span class="line">    Mat rota_mat = <span class="keyword">new</span> Mat(<span class="number">3</span>, <span class="number">3</span>, CvType.CV_32FC1);</span><br><span class="line">    <span class="keyword">double</span> [] result;</span><br><span class="line">    Calib3d.Rodrigues(rvecs,rota_mat);</span><br><span class="line">    <span class="keyword">double</span> exterarr[][] = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;<span class="number">3</span>)&#123;</span><br><span class="line">          result = rota_mat.get(i,j);</span><br><span class="line">          exterarr[i][j] = result[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            exterarr[i][j] = tvecs.get(i,<span class="number">0</span>)[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    exterarr[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0</span>;  </span><br><span class="line">    <span class="comment">//extermat = new Array2DRowRealMatrix(exterarr);</span></span><br><span class="line">    <span class="keyword">return</span> exterarr;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealMatrix <span class="title">inverseMatrix</span><span class="params">(RealMatrix A)</span> </span>&#123;<span class="comment">//求逆矩阵</span></span><br><span class="line">    RealMatrix result = <span class="keyword">new</span> LUDecomposition(A).getSolver().getInverse();</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-像素坐标转换到世界坐标"><a href="#2-1-2-像素坐标转换到世界坐标" class="headerlink" title="2.1.2 像素坐标转换到世界坐标"></a>2.1.2 像素坐标转换到世界坐标</h3><p>得到前面三个转换矩阵后，就可以通过下面的公式将图像上的点$(u,v)$转换成世界坐标下的点$(x,y,z)$（注意：高度$z$是给定的）：</p>
<script type="math/tex; mode=display">z \begin{bmatrix}u\\\\v\\\\1\end{bmatrix} = H_{pc}H_{cg}H^{-1}_{rg} \begin{bmatrix}x\\\\y\\\\z\\\\1\end{bmatrix}</script><p>设：</p>
<script type="math/tex; mode=display">H_{pc}H_{cg}H^{-1}_{rg} = \begin{bmatrix}a_0&b_0&c_0&d_0\\\\a_1&b_1&c_1&d_1\\\\a_2&b_2&c_2&d_2\\\\a_3&b_3&c_3&d_3 \end{bmatrix}</script><p>则：</p>
<script type="math/tex; mode=display">\begin{bmatrix} x \\\\y  \end{bmatrix} = \begin{bmatrix} ua_2 - a_0 &ub_2 - b_0 \\\\va_2 - a_1 &vb_2-b_1  \end{bmatrix}^{-1}\begin{bmatrix} d_0-ud_2-(uc_2-c_0)z \\\\d_1-vd_2-(vc_2-c_1)z \end{bmatrix}</script><p>这样就把图像上的点转换到了机器人坐标系下的点。</p>
<h2 id="2-2-瓷砖特征信息提取"><a href="#2-2-瓷砖特征信息提取" class="headerlink" title="2.2 瓷砖特征信息提取"></a>2.2 瓷砖特征信息提取</h2><p><strong>图像算法</strong></p>
<hr>
<ul>
<li><p>输入：</p>
<p>图片src</p>
</li>
<li><p>输出过程</p>
<ol>
<li><p>对<code>图像src预处理</code>（高斯模糊、开操作），及canny边缘检测，得到处理后的图像img_canny</p>
</li>
<li><p>对img_canny进行<code>轮廓检测</code>，得到轮廓点集contours</p>
</li>
<li><p>根据各轮廓面积，对轮廓进行<code>过滤筛选</code>，对保留下的轮廓点集由Hu矩计算得到各轮廓质心</p>
</li>
<li><p>根据轮廓质心得到<code>edge_tile_flag</code>，同时将轮廓点集区分为左右点集（分别表示吸取的和地面的瓷砖）points_left,points_right</p>
</li>
<li><p>对points_left,points_right使用<code>最大距离法</code>计算出轮廓的拐点corner_left,corner_right</p>
</li>
<li><p>由corner_left,corner_right<code>筛选</code>出points_left,points_right中的边缘直线点集line_left,line_right，并由<code>PCA最小二乘法</code>拟合直线</p>
</li>
</ol>
</li>
<li><p>输出</p>
<p>line_left,line_right,corner_left,corner_right</p>
</li>
</ul>
<hr>
<h3 id="2-2-1-图像预处理"><a href="#2-2-1-图像预处理" class="headerlink" title="2.2.1 图像预处理"></a>2.2.1 图像预处理</h3><p>特征信息最关键的地方就在边缘检测，目前使用的是<a href="https://zh.wikipedia.org/wiki/Canny%E7%AE%97%E5%AD%90" target="_blank" rel="noopener">canny边缘检测</a>算法,opencv中可以直接使用<a href="https://docs.opencv.org/3.4.2/dd/d1a/group__imgproc__feature.html#ga2a671611e104c093843d7b7fc46d24af" target="_blank" rel="noopener">canny函数</a>（在写这篇文章时，其实已经发现了一种效果更好的边缘检测算法-<a href="https://www.ipol.im/pub/art/2016/175/" target="_blank" rel="noopener">Unsupervised Smooth Contour Detection</a>，但还时间将其应用在图像识别算法中，之后会再整理）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Mat <span class="title">preprocess_image</span><span class="params">(Mat img)</span></span>&#123; <span class="comment">//图像预处理</span></span><br><span class="line">    Size size = <span class="keyword">new</span> Size(<span class="number">3</span>,<span class="number">3</span>); <span class="comment">//模糊图像用的核函数的尺寸大小</span></span><br><span class="line">    Size size2 = <span class="keyword">new</span> Size(<span class="number">5</span>,<span class="number">5</span>); <span class="comment">//形态学转换的核函数的尺寸大小</span></span><br><span class="line">    Mat img_canny = <span class="keyword">new</span> Mat(); <span class="comment">//存储canny边缘检测后的图片</span></span><br><span class="line">    Mat img_gray = <span class="keyword">new</span> Mat();<span class="comment">//存储灰度图</span></span><br><span class="line">    Imgproc.cvtColor(img,img_gray,Imgproc.COLOR_BGR2GRAY); <span class="comment">//转换成灰度图</span></span><br><span class="line">    Imgproc.blur(img_gray,img_gray,size);   <span class="comment">//图像平滑</span></span><br><span class="line">    Mat element;</span><br><span class="line">    element = Imgproc.getStructuringElement(Imgproc.MORPH_RECT,size2);</span><br><span class="line">    Imgproc.morphologyEx(img_gray,img_gray,<span class="number">1</span>,element); <span class="comment">//形态学转换  1：开操作</span></span><br><span class="line">    Imgproc.Canny(img_gray,img_canny,g_nThresh,g_nThresh*<span class="number">2</span>); <span class="comment">//canny边缘检测</span></span><br><span class="line">    <span class="keyword">return</span> img_canny;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-轮廓检测"><a href="#2-2-2-轮廓检测" class="headerlink" title="2.2.2 轮廓检测"></a>2.2.2 轮廓检测</h3><p>在canny边缘检测算法之后由<a href="https://docs.opencv.org/3.4.2/d3/dc0/group__imgproc__shape.html#ga17ed9f5d79ae97bd4c7cf18403e1689a" target="_blank" rel="noopener">findcontours</a>可以得到其检测到的所有边缘轮廓的点集，接下来利用opencv的<a href="https://docs.opencv.org/3.4.2/d3/dc0/group__imgproc__shape.html#ga3d476a3417130ae5154aea421ca7ead9" target="_blank" rel="noopener">minAreaRect</a>函数可以算出轮廓的最小外接矩形。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cnt_info</span><span class="params">(List&lt;MatOfPoint&gt; contours)</span></span>&#123; <span class="comment">//获得详细的边缘轮廓信息</span></span><br><span class="line">    boxcontours_list = <span class="keyword">new</span> ArrayList&lt;org.opencv.core.Point[]&gt;(); <span class="comment">//轮廓外接矩形的四个定点</span></span><br><span class="line">    area_list = <span class="keyword">new</span> ArrayList&lt;Double&gt;();  <span class="comment">//外接矩形面积</span></span><br><span class="line">    rect_list = <span class="keyword">new</span> ArrayList&lt;RotatedRect&gt;(); <span class="comment">//外接矩形</span></span><br><span class="line">    contours_appro = <span class="keyword">new</span> ArrayList&lt;MatOfPoint&gt;();</span><br><span class="line">    box_appro = <span class="keyword">new</span> ArrayList&lt;org.opencv.core.Point[]&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; contours.size();i++)&#123;</span><br><span class="line">       MatOfPoint cnt = contours.get(i);</span><br><span class="line">       MatOfPoint2f  newcnt = <span class="keyword">new</span> MatOfPoint2f(cnt.toArray()); <span class="comment">//将MatOfPoint转换成MatOfPoint2f</span></span><br><span class="line">       RotatedRect rect = Imgproc.minAreaRect(newcnt);</span><br><span class="line">       Size size_area = rect.size;</span><br><span class="line">       <span class="keyword">double</span> area = size_area.area();</span><br><span class="line">       org.opencv.core.Point vertices[] = <span class="keyword">new</span> org.opencv.core.Point[<span class="number">4</span>];<span class="comment">//定义四个顶点</span></span><br><span class="line">       rect.points(vertices); <span class="comment">//将rect中的定点赋值给vertices</span></span><br><span class="line">       boxcontours_list.add(vertices); <span class="comment">//将四个顶点存入list中</span></span><br><span class="line">       area_list.add(area);</span><br><span class="line">       rect_list.add(rect);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-轮廓筛选与质心计算"><a href="#2-2-3-轮廓筛选与质心计算" class="headerlink" title="2.2.3 轮廓筛选与质心计算"></a>2.2.3 轮廓筛选与质心计算</h3><p>接下来可以先根据轮廓面积过滤掉一些面积小于某一阈值的轮廓。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;Integer&gt; <span class="title">get_indexarea</span><span class="params">(List&lt;MatOfPoint&gt; contours,List&lt;Double&gt; area_list)</span></span>&#123; <span class="comment">//根据轮廓面积进行筛选</span></span><br><span class="line">    ArrayList&lt;Integer&gt; index_area_appro = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; index_area_list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      List&lt;Double&gt; area_list_temp = deepCopy(area_list); <span class="comment">//深拷贝</span></span><br><span class="line">      <span class="keyword">int</span> len = area_list.size(); <span class="comment">//获得此时寻找到的轮廓列表的大小 这里是可以保证len &gt; 2的</span></span><br><span class="line">      <span class="keyword">int</span> index_area;</span><br><span class="line">      Collections.sort(area_list);  <span class="comment">//先升序再降序</span></span><br><span class="line">      Collections.reverse(area_list);</span><br><span class="line">      <span class="keyword">if</span>(len &lt; <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">          Double area = area_list.get(i);</span><br><span class="line">          <span class="keyword">if</span>(area &gt; <span class="number">5000</span>)&#123;</span><br><span class="line">            index_area = area_list_temp.indexOf(area);</span><br><span class="line">            index_area_list.add(index_area);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">          Double area = area_list.get(i);</span><br><span class="line">          <span class="keyword">if</span>(area &gt; <span class="number">5000</span>)&#123;</span><br><span class="line">            index_area = area_list_temp.indexOf(area);</span><br><span class="line">            index_area_list.add(index_area);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">       e.printStackTrace();  </span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">if</span>(index_area_list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> error = -<span class="number">1</span>;</span><br><span class="line">      index_area_appro.add(error);</span><br><span class="line">      <span class="keyword">return</span> index_area_appro;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      index_area_appro = GetCenterPoint(contours,index_area_list);    </span><br><span class="line">      <span class="keyword">return</span> index_area_appro;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在上面函数可以看到还有一个函数<code>GetCenterPoint(contours,index_area_list)</code>，根据得到的轮廓面积，可以由<a href="https://docs.opencv.org/3.4.2/d8/d23/classcv_1_1Moments.html#a0382b98fdb23acdcb05c91a2a44e5a1f" target="_blank" rel="noopener">moments</a>函数得到轮廓<a href="https://blog.csdn.net/chaipp0607/article/details/70256892" target="_blank" rel="noopener">Hu矩</a>，并由Hu矩得到轮廓的质心。</p>
<h3 id="2-2-4-edge-tile-flag"><a href="#2-2-4-edge-tile-flag" class="headerlink" title="2.2.4 edge_tile_flag"></a>2.2.4 edge_tile_flag</h3><p>瓷砖主要会以以下三种情况出现在画面中：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/threetype.PNG"/></p>
<p>所以由各轮廓质心的相对关系可以确定在图像中那一块瓷砖是被机器人吸取的，哪一块是平面上需要去靠近的。同时，有了这些信息才能便于之后的轮廓直线拟合与机器人的运动控制</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;Integer&gt; <span class="title">GetCenterPoint</span><span class="params">(List&lt;MatOfPoint&gt; contours,ArrayList&lt;Integer&gt; index_area_list)</span></span>&#123; <span class="comment">//计算得到轮廓的重心点,并对其进行分类，得到左右轮廓的索引</span></span><br><span class="line">     <span class="comment">//ArrayList&lt;org.opencv.core.Point&gt; gravity_point = new  ArrayList&lt;org.opencv.core.Point&gt;();</span></span><br><span class="line">     ArrayList&lt;Integer&gt; index_appro = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">     <span class="keyword">int</span> len = index_area_list.size();</span><br><span class="line">     <span class="keyword">int</span> max_x = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> max_y = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> index_l = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> index_r = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(len == <span class="number">2</span>)&#123;</span><br><span class="line">       <span class="comment">//这里需要去判断当瓷砖是某一行的第一块转时的情况</span></span><br><span class="line">       MatOfPoint cnt1 = contours.get(index_area_list.get(<span class="number">0</span>));</span><br><span class="line">       Moments p1 = Imgproc.moments(cnt1);</span><br><span class="line">       <span class="keyword">int</span> y1 = (<span class="keyword">int</span>) (p1.get_m01() / p1.get_m00());</span><br><span class="line">       MatOfPoint cnt2 = contours.get(index_area_list.get(<span class="number">1</span>));</span><br><span class="line">       Moments p2 = Imgproc.moments(cnt2);</span><br><span class="line">       <span class="keyword">int</span> y2 = (<span class="keyword">int</span>) (p2.get_m01() / p2.get_m00());</span><br><span class="line">       index_l = (y1 &gt; y2) ? <span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">       index_r = <span class="number">1</span>-index_l;</span><br><span class="line">       MatOfPoint cnt_r = contours.get(index_area_list.get(index_r));</span><br><span class="line">       MatOfPoint cnt_l = contours.get(index_area_list.get(index_l));</span><br><span class="line">       Moments p_r = Imgproc.moments(cnt_r);</span><br><span class="line">       Moments p_l = Imgproc.moments(cnt_l);</span><br><span class="line">       <span class="keyword">int</span> x_r = (<span class="keyword">int</span>) (p_r.get_m10() / p_r.get_m00());</span><br><span class="line">       <span class="keyword">int</span> x_l = (<span class="keyword">int</span>) (p_l.get_m10() / p_l.get_m00());</span><br><span class="line">       <span class="keyword">if</span>(x_r &gt; x_l)&#123;</span><br><span class="line">         edge_tile_flag = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">         edge_tile_flag = <span class="number">1</span>;<span class="comment">//说明此时的位于每行的第一个</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">       edge_tile_flag = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++)&#123;</span><br><span class="line">         MatOfPoint cnt = contours.get(index_area_list.get(i));</span><br><span class="line">         Moments p = Imgproc.moments(cnt);</span><br><span class="line">         <span class="keyword">int</span> x = (<span class="keyword">int</span>) (p.get_m10() / p.get_m00());</span><br><span class="line">         <span class="keyword">int</span> y = (<span class="keyword">int</span>) (p.get_m01() / p.get_m00());</span><br><span class="line">         <span class="keyword">if</span>( y &gt; max_y)&#123;</span><br><span class="line">           max_y = y;</span><br><span class="line">           index_l = i;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>( x &gt; max_x)&#123;</span><br><span class="line">           max_x = x;</span><br><span class="line">           index_r = i;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     index_appro.add(index_area_list.get(index_l));</span><br><span class="line">     index_appro.add(index_area_list.get(index_r));</span><br><span class="line">     <span class="keyword">return</span> index_appro;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>edge_tile_flag</code>变量表示的是一个标记，主要用来标记此时瓷砖是否为每行的首列。因为如果瓷砖在首列时所用的图像算法是不一样的。<br>对于前面的三种形式：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/threetype.PNG"/></p>
<p><code>edge_tile_flag</code>分别为<code>0,1,0</code>，1,0和分别对应如下的贴砖策略：</p>
<p>一类是瓷砖放置位置在首列，另一种是瓷砖放置位置非首列。通过图像识别算法可以判断出当前属于哪一种类型，但是当需要瓷砖与瓷砖之间保持一定的间隙时，需要知道往哪一个方向保持间隙，所以需要知道当前位置的类型。</p>
<p>瓷砖放置位置在首列的情况：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/postype1.jpg"/></p>
<p>这种情况下，瓷砖与瓷砖之间应该在y方向下保持特定间隙，x方向应该尽量减小间隙。</p>
<p>瓷砖放置位置在非首列的情况：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/postype0.jpg"/></p>
<p>在非首列情况下，瓷砖与瓷砖之间应该在x方向下保持特定间隙，y方向应该尽量减小间隙。</p>
<p>有了以上这些信息,就可以将合适的轮廓点集以及各轮廓的最小外接矩形的四个角点信息进行保存输出：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Mat <span class="title">get_contours_info</span><span class="params">(Mat g_srcimg)</span></span>&#123; <span class="comment">//获得轮廓信息的函数</span></span><br><span class="line">    List&lt;MatOfPoint&gt; contours = <span class="keyword">new</span> ArrayList&lt;MatOfPoint&gt;();<span class="comment">//保存轮廓的点集</span></span><br><span class="line">    Mat hierarchy = <span class="keyword">new</span> Mat();</span><br><span class="line">    Mat img_canny = preprocess_image(g_srcimg); <span class="comment">//图像预处理</span></span><br><span class="line">    Imgproc.findContours(img_canny,contours,hierarchy,<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//寻找轮廓</span></span><br><span class="line">    <span class="keyword">if</span>(contours.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">double</span> neg = -<span class="number">1</span>;</span><br><span class="line">      rate.add(neg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      cnt_info(contours);</span><br><span class="line">      <span class="keyword">double</span> rate1,rate2;</span><br><span class="line">        index_area_appro = get_indexarea(contours,area_list); <span class="comment">//这里面是合适的轮廓的索引</span></span><br><span class="line">        <span class="keyword">if</span>(index_area_appro.get(<span class="number">0</span>) == -<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">double</span> neg = -<span class="number">1</span>;</span><br><span class="line">          rate.add(neg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          RotatedRect rect_max_temp = rect_list.get(index_area_appro.get(<span class="number">0</span>));</span><br><span class="line">          RotatedRect rect_max_sec_temp = rect_list.get(index_area_appro.get(<span class="number">1</span>));</span><br><span class="line">          <span class="keyword">if</span>((rect_max_temp.size.width == <span class="number">0</span>) | (rect_max_temp.size.height == <span class="number">0</span>))&#123;</span><br><span class="line">            rate1 = <span class="number">100</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">            rate1 = max_value(rect_max_temp.size.width / rect_max_temp.size.height,rect_max_temp.size.height / rect_max_temp.size.width); <span class="comment">//返回两个数中的较大值</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>((rect_max_sec_temp.size.width == <span class="number">0</span>) | (rect_max_sec_temp.size.height == <span class="number">0</span>))&#123;</span><br><span class="line">            rate2 = <span class="number">100</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">            rate2 = max_value(rect_max_sec_temp.size.width / rect_max_sec_temp.size.height,rect_max_sec_temp.size.height / rect_max_sec_temp.size.width); <span class="comment">//返回两个数中的较大值</span></span><br><span class="line">         &#125;</span><br><span class="line">         rate.add(rate1);</span><br><span class="line">         rate.add(rate2);</span><br><span class="line">         contours_appro.add(contours.get(index_area_appro.get(<span class="number">0</span>)));</span><br><span class="line">         contours_appro.add(contours.get(index_area_appro.get(<span class="number">1</span>)));</span><br><span class="line">         box_appro.add(boxcontours_list.get(index_area_appro.get(<span class="number">0</span>)));</span><br><span class="line">         box_appro.add(boxcontours_list.get(index_area_appro.get(<span class="number">1</span>)));  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> img_canny;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>由之前的代码可以看出来，提取轮廓特征信息只使用两个轮廓点集即可。</p>
<h3 id="2-2-5-最大距离法"><a href="#2-2-5-最大距离法" class="headerlink" title="2.2.5 最大距离法"></a>2.2.5 最大距离法</h3><p>得到合适的轮廓点集之后，就可以计算瓷砖的角点，这里使用最大距离法计算瓷砖的角点。最大距离法的主要思想是，对于一条折现，先找出整个点集的首尾两个点，然后找到整个点集中距离首尾两点连线的距离最大的点。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">get_cornerpoints</span><span class="params">()</span></span>&#123; <span class="comment">//使用最大距离法，获得轮廓点集的拐点</span></span><br><span class="line">    points_left = contours_appro.get(<span class="number">0</span>).toList();</span><br><span class="line">    points_right = contours_appro.get(<span class="number">1</span>).toList();</span><br><span class="line">    Double points_left_arr[][] = get_points_array(points_left); <span class="comment">//转换成数组，用来进行排序</span></span><br><span class="line">    Double points_right_arr[][] = get_points_array(points_right);</span><br><span class="line">    sort(points_left_arr, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>,<span class="number">1</span>&#125;); <span class="comment">//按横坐标升序</span></span><br><span class="line">    sort(points_right_arr, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> len_left = points_left_arr.length;</span><br><span class="line">    <span class="keyword">int</span> len_right = points_right_arr.length;</span><br><span class="line">    org.opencv.core.Point pointl_1 = <span class="keyword">new</span> org.opencv.core.Point(points_left_arr[<span class="number">0</span>][<span class="number">0</span>],points_left_arr[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">// 按横坐标升序，得到第一个点坐标，记为轮廓1的第一个参考点</span></span><br><span class="line">    org.opencv.core.Point pointl_2 = <span class="keyword">new</span> org.opencv.core.Point(points_left_arr[len_left-<span class="number">1</span>][<span class="number">0</span>],points_left_arr[len_left-<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">//继续按横坐标升序，取最后一个点集，作为第二个参考点</span></span><br><span class="line">    sort(points_left_arr, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">0</span>&#125;); <span class="comment">//按纵坐标升序</span></span><br><span class="line">    sort(points_right_arr, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    org.opencv.core.Point pointr_1 = <span class="keyword">new</span> org.opencv.core.Point(points_right_arr[<span class="number">0</span>][<span class="number">0</span>],points_right_arr[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    org.opencv.core.Point pointr_2 = <span class="keyword">new</span> org.opencv.core.Point(points_right_arr[len_right-<span class="number">1</span>][<span class="number">0</span>],points_right_arr[len_right-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((pointl_2.x - pointl_1.x) == <span class="number">0</span>)&#123; <span class="comment">//垂直直线</span></span><br><span class="line">      corner_point_left.x = <span class="number">0</span>;</span><br><span class="line">      corner_point_left.y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">double</span> k1 = (pointl_2.y - pointl_1.y) / (pointl_2.x - pointl_1.x);</span><br><span class="line">      <span class="keyword">double</span> b1 = pointl_2.y - k1 * pointl_2.x;</span><br><span class="line">      <span class="keyword">int</span> index1 = calculate_distance(points_left,k1,b1);</span><br><span class="line">      corner_point_left.x = points_left.get(index1).x;</span><br><span class="line">      corner_point_left.y = points_left.get(index1).y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((pointr_2.x - pointr_1.x) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">double</span> b2 = pointr_1.x;</span><br><span class="line">      <span class="keyword">int</span> index2 = calculate_distance_infinate(points_right,b2);</span><br><span class="line">      corner_point_right.x = points_right.get(index2).x;</span><br><span class="line">      corner_point_right.y = points_right.get(index2).y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">double</span> k2 = (pointr_2.y - pointr_1.y) / (pointr_2.x - pointr_1.x);</span><br><span class="line">      <span class="keyword">double</span> b2 = pointr_2.y - k2 * pointr_2.x;</span><br><span class="line">      <span class="keyword">int</span> index2 = calculate_distance(points_right,k2,b2);</span><br><span class="line">      corner_point_right.x = points_right.get(index2).x;</span><br><span class="line">      corner_point_right.y = points_right.get(index2).y;</span><br><span class="line">    &#125;</span><br><span class="line">    corner_point.add(corner_point_left);</span><br><span class="line">    corner_point.add(corner_point_right);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculate_distance</span><span class="params">(List&lt;org.opencv.core.Point&gt; points,<span class="keyword">double</span> k,<span class="keyword">double</span> b)</span></span>&#123; <span class="comment">//计算到某一直线最大距离的点</span></span><br><span class="line">    <span class="keyword">double</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; points.size();i++)&#123;</span><br><span class="line">      <span class="keyword">double</span> d = FastMath.abs(points.get(i).x * k - points.get(i).y + b);</span><br><span class="line">      <span class="keyword">if</span>(d &gt; max)&#123;</span><br><span class="line">        max = d;</span><br><span class="line">        index = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">calculate_distance_infinate</span><span class="params">(List&lt;org.opencv.core.Point&gt; points,<span class="keyword">double</span> b)</span></span>&#123; <span class="comment">//计算到斜率为无穷大直线最大距离的点</span></span><br><span class="line">    <span class="keyword">double</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; points.size();i++)&#123;</span><br><span class="line">      <span class="keyword">double</span> d = FastMath.abs(points.get(i).x - b);</span><br><span class="line">      <span class="keyword">if</span>(d &gt; max)&#123;</span><br><span class="line">        max = d;</span><br><span class="line">        index = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-6-点集筛选"><a href="#2-2-6-点集筛选" class="headerlink" title="2.2.6 点集筛选"></a>2.2.6 点集筛选</h3><p>得到角点信息后，两个瓷砖可以进行靠近，但是再靠近之前还需要将两块瓷砖调整至平行，实际上调整平行是再瓷砖靠近之前进行的，但是在这里，为了得到合适的边缘直线的直线方程，需要由角点对轮廓点集进行筛选，仅保留有用的轮廓点集,然后有该点集拟合边缘直线，以获得直线角度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;org.opencv.core.Point&gt; roi_points_r(List&lt;org.opencv.core.Point&gt; points)&#123; <span class="comment">//得到新的点集</span></span><br><span class="line">    List&lt;org.opencv.core.Point&gt; points_new = <span class="keyword">new</span> ArrayList&lt;org.opencv.core.Point&gt;();</span><br><span class="line">    <span class="keyword">if</span>(points.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(edge_tile_flag == <span class="number">0</span>)&#123;  <span class="comment">//需要判断是否是该行的第一块瓷砖</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;points.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(points.get(i).y &gt; corner_point_right.y + <span class="number">5</span>)&#123;</span><br><span class="line">            points_new.add(points.get(i));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;points.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(points.get(i).y &lt; corner_point_right.y - <span class="number">5</span>)&#123;</span><br><span class="line">            points_new.add(points.get(i));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      points_new = points;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> points_new;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> List&lt;org.opencv.core.Point&gt; roi_points_l(List&lt;org.opencv.core.Point&gt; points)&#123; <span class="comment">//得到新的点集</span></span><br><span class="line">    List&lt;org.opencv.core.Point&gt; points_new = <span class="keyword">new</span> ArrayList&lt;org.opencv.core.Point&gt;();</span><br><span class="line">    <span class="keyword">if</span>(points.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;points.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.get(i).x &gt; corner_point_left.x + <span class="number">5</span>)&#123;</span><br><span class="line">          points_new.add(points.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      points_new = points;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> points_new;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>roi_points_r</code>和<code>roi_points_l</code>分别表示的地面放置瓷砖的轮廓点集和机器人吸取末端瓷砖的点集。<br>从代码中可以看出来点集为<code>roi_points_r</code>时，当点集的纵坐标大于角点坐标的纵坐标时保留；点集为<code>roi_points_l</code>时，当点集的横坐标大于角点坐标的横坐标时保留。</p>
<h3 id="2-2-7-基于PCA的最小二乘方式"><a href="#2-2-7-基于PCA的最小二乘方式" class="headerlink" title="2.2.7 基于PCA的最小二乘方式"></a>2.2.7 基于PCA的最小二乘方式</h3><p>对于保留的点集接下来既可以进行直线的拟合，这里使用的时基于PCA的最小二乘方式，之所以采用这种算法，可以参考<a href="https://zhuanlan.zhihu.com/p/36429715" target="_blank" rel="noopener">这里</a>，简单的解释如下：</p>
<blockquote>
<p>对于当x被认为是没有误差时的单变量输入的点集时，最小二乘是没有问题的（即使是数据扰动很大的斜椭圆情况）。当变量是两个的情况下，例如由平面点集拟合直线时，由于x和y都可能存在误差，故pca法得到更佳的拟合效果</p>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Double&gt; <span class="title">least_square_pca</span><span class="params">(List&lt;org.opencv.core.Point&gt; points)</span></span>&#123;<span class="comment">//PCA最小</span></span><br><span class="line">    List&lt;Double&gt; Theta = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = points.size();</span><br><span class="line">    <span class="keyword">double</span> k_infinite = <span class="number">99999999</span>; <span class="comment">//表示无穷大的斜率</span></span><br><span class="line">    <span class="keyword">double</span> data [][] = <span class="keyword">new</span> <span class="keyword">double</span>[len][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">double</span> sum_x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum_y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; len;i++)&#123;</span><br><span class="line">      data[i][<span class="number">0</span>] = points.get(i).x;</span><br><span class="line">      data[i][<span class="number">1</span>] = points.get(i).y;</span><br><span class="line">      sum_x = sum_x + points.get(i).x;</span><br><span class="line">      sum_y = sum_y + points.get(i).y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">      data[i][<span class="number">0</span>] = data[i][<span class="number">0</span>] - sum_x/len;</span><br><span class="line">      data[i][<span class="number">1</span>] = data[i][<span class="number">1</span>] - sum_y/len;</span><br><span class="line">    &#125;</span><br><span class="line">    RealMatrix data_matrix = <span class="keyword">new</span> Array2DRowRealMatrix(data);</span><br><span class="line">    RealMatrix datamatrix2 = data_matrix.transpose().multiply(data_matrix);</span><br><span class="line">    RealMatrix u = <span class="keyword">new</span> SingularValueDecomposition(datamatrix2).getU();</span><br><span class="line">    RealMatrix n = u.getColumnMatrix(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">double</span> n_arr[][] = n.getData();</span><br><span class="line">    <span class="keyword">if</span>(n_arr[<span class="number">1</span>][<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">      Theta.add(points.get(<span class="number">0</span>).x);</span><br><span class="line">      Theta.add(k_infinite);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">double</span> k2 = -n_arr[<span class="number">0</span>][<span class="number">0</span>] / n_arr[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">double</span> b2 = sum_y / len - k2 * sum_x / len;</span><br><span class="line">      Theta.add(b2); <span class="comment">//直线方程的截距</span></span><br><span class="line">      Theta.add(k2); <span class="comment">//直线方程的斜率</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Theta;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>直线拟合之后就可以计算出两条直线的角度及其偏差。</p>
]]></content>
      <categories>
        <category>机械臂</category>
      </categories>
      <tags>
        <tag>机械臂</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP并发_04同步并发操作</title>
    <url>/2019/11/24/CPP%E5%B9%B6%E5%8F%91-04%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>C++ 并发编程学习02</p>
<ul>
<li><p>等待事件</p>
</li>
<li><p>带有期望值的等待一次性事件</p>
</li>
<li><p>在限定时间内等待</p>
</li>
<li><p>使用同步操作简化代码</p>
<a id="more"></a>
</li>
</ul>
<h2 id="4-1-等待一个事件或其他条件"><a href="#4-1-等待一个事件或其他条件" class="headerlink" title="4.1 等待一个事件或其他条件"></a>4.1 等待一个事件或其他条件</h2><h3 id="4-1-1-等待条件达成"><a href="#4-1-1-等待条件达成" class="headerlink" title="4.1.1 等待条件达成"></a>4.1.1 等待条件达成</h3><p>使用条件变量唤醒休眠中的线程对其进行处理</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mut;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;data_chunk&gt; data_queue;  <span class="comment">// 1， 在两线程之间传递数据的队列</span></span><br><span class="line"><span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(more_data_to_prepare())</span><br><span class="line">  &#123;</span><br><span class="line">    data_chunk <span class="keyword">const</span> data=prepare_data();</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">    data_queue.push(data);  <span class="comment">// 2 将准备好的数据压入队列中</span></span><br><span class="line">    data_cond.notify_one();  <span class="comment">// 3 对等待的线程（如果有等待线程）进行通知</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理数据的线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 在这个线程中首先对互斥量上锁</span></span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);  <span class="comment">// 4 </span></span><br><span class="line">    <span class="comment">// 传递一个锁和lambda 函数表达式作为等待条件</span></span><br><span class="line">    data_cond.wait(lk,[]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;);  <span class="comment">// 5</span></span><br><span class="line">    data_chunk data=data_queue.front();</span><br><span class="line">    data_queue.pop();</span><br><span class="line">    lk.unlock();  <span class="comment">// 6</span></span><br><span class="line">    process(data);</span><br><span class="line">    <span class="keyword">if</span>(is_last_chunk(data))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wait()会去检查这些条件(通过调用所提供的lambda函数)，当条件满足(lambda函数返回true)时返回。如果条件不满足(lambda函数返回false)，wait()函数将解锁互斥量，并且将这个线程(上段提到的处理数据的线程)置于阻塞或等待状态。</p>
<h3 id="4-1-2-使用条件变量构建线程安全的队列"><a href="#4-1-2-使用条件变量构建线程安全的队列" class="headerlink" title="4.1.2 使用条件变量构建线程安全的队列"></a>4.1.2 使用条件变量构建线程安全的队列</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex mut;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;T&gt; data_queue;</span><br><span class="line">    <span class="built_in">std</span>::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    threadsafe_queue()</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    threadsafe_queue(threadsafe_queue <span class="keyword">const</span>&amp; other)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(other.mut);</span><br><span class="line">        data_queue=other.data_queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">        data_queue.push(new_value);</span><br><span class="line">        data_cond.notify_one();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">        data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;);</span><br><span class="line">        value=data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; wait_and_pop()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">        data_cond.wait(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.empty();&#125;);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_queue.front()));</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">        <span class="keyword">if</span>(data_queue.empty)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        value=data_queue.front();</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; try_pop()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">        <span class="keyword">if</span>(data_queue.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; res(<span class="built_in">std</span>::make_shared&lt;T&gt;(data_queue.front()));</span><br><span class="line">        data_queue.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(mut);</span><br><span class="line">        <span class="keyword">return</span> data_queue.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>不多解释。。。</p>
<h2 id="4-2-使用期望值等待一次性事件"><a href="#4-2-使用期望值等待一次性事件" class="headerlink" title="4.2 使用期望值等待一次性事件"></a>4.2 使用期望值等待一次性事件</h2><blockquote>
<p>假设你乘飞机去国外度假。当你到达机场并办理完各种登机手续后，还需要等待机场广播通知登机时(可能要等很多个小时)，你可能会在候机室里面找一些事情来打发时间，比如：读书，上网，或者来一杯价格不菲的机场咖啡。不过，从根本上来说你就在等待一件事情：机场广播能够登机的时间。之前飞机的班次在之后没有可参考性，因为当你再次度假的时候，可能会选择等待另一班飞机。</p>
</blockquote>
<p>C++标准库模型将这种一次性事件称为 <strong>期望值(future)</strong> 。当线程需要等待特定的一次性事件时，某种程度上来说就需要知道这个事件在未来的期望结果。</p>
<p>之后，这个线程会周期性(较短的周期)的等待或检查，事件是否触发(检查信息板)；检查期间也会执行其他任务(品尝昂贵的咖啡)。另外，等待任务期间它可以先执行另外一些任务，直到对应的任务触发，而后等待期望值的状态会变为就绪(ready)。一个期望值可能是数据相关的(比如，你的登机口编号)，也可能不是。当事件发生时(并且期望状态为就绪)，并且这个期望值就不能被重置。</p>
<h3 id="4-2-1-后台任务的返回值"><a href="#4-2-1-后台任务的返回值" class="headerlink" title="4.2.1 后台任务的返回值"></a>4.2.1 后台任务的返回值</h3><p>当不着急要任务结果时，可以使用<code>std::async</code>启动一个异步任务。与 <code>std::thread</code>对象等待的方式不同， <code>std::async</code>会返回一个<code>std::future</code>对象，这个对象持有最终计算出来的结果。当需要这个值时，只需要调用这个对象的 get() 成员函数；并且会阻塞线程直到期望值状态为就绪为止；之后，返回计算结果。</p>
<p><code>std::async</code>： 函数模板，启动一个异步任务，返回 <code>std::future</code>类模板对象；</p>
<p><code>std::future&lt;T&gt;</code>： 类模板，常用函数，T 是返回结果的类型；</p>
<ul>
<li><p><code>get()</code>： 等待，直到获取子线程返回值，解除堵塞。 <strong>只能使用一次</strong>， 因为get() 是用移动语义实现的，使用 future.get() 后，再次使用 future.get() 将变成 nullptr；</p>
</li>
<li><p><code>wait()</code>： 等待，直到子线程结束，不需要返回值，解除堵塞；</p>
</li>
</ul>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"subThread id: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"...subThread start.\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::chrono::<span class="function">milliseconds <span class="title">time</span><span class="params">(<span class="number">5000</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(time);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"subThread id: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"...subThread end.\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">7</span>; <span class="comment">//线程函数必须要返回值，get()会一直堵塞等待返回值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main Thread id: "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"...run...\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; retVal = <span class="built_in">std</span>::async(myThread); <span class="comment">//线程开始执行，虽然线程函数会延迟5s,但是不会卡在这儿</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"test..."</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//如果线程函数没有执行结束，而是会卡在这里，因为这里需要这个线程函数的返回结果</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"subThread return value: "</span> &lt;&lt; retVal.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出效果：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/thread_out5.gif" width="300"/></p>
<p>虽然线程函数里面有个 5秒的延时操作，主线程并不会等待这个子线程的完成才继续执行下去，只有 <strong>当主线程需要用到子线程的数据时</strong> ，才会等到子线程的结束，比如 <code>retVal.get()</code>会使得主线程必须等到子线程结束。</p>
<p>因此 <code>future</code>，可以理解为让主线程在将来用到子线程返回时才等待，否则不等。这个功能类似于 <code>thread::join()</code>，让主线程等到子线程的完成，但是这个异步性质，可以等价准备的控制等待事件，即，在哪等待，比如：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; retVal = <span class="built_in">std</span>::async(myThread);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"test_1..."</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"\nsubThread return value: "</span>&lt;&lt;retVal.get()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"test_2..."</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span></span><br></pre></td></tr></table></figure>
<p>第一个for循环，会和子线程争夺资源，但是第二个线程必须等子线程结束才能执行，如果使用join()，第一for循环结束，第二个就会执行。使用异步性质，可以控制程序的执行顺序。</p>
<p>可以在函数调用之前向 <code>std:async</code> 传递一个额外的参数，这个参数的类型是<code>std::launch</code>，这是一个枚举类型:</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">launch</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        async = <span class="number">1</span>,</span><br><span class="line">        deferred = <span class="number">2</span></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p><code>std::launch::defered</code>，表明函数调用被延迟到wait()或get()函数调用时才执行；</p>
<p><code>std::launch::async</code>， 表明函数必须在其所在的独立线程上执行；</p>
<h3 id="4-2-2-任务与期望值关联"><a href="#4-2-2-任务与期望值关联" class="headerlink" title="4.2.2 任务与期望值关联"></a>4.2.2 任务与期望值关联</h3><p><code>std::packaged_task</code>是个类模板，模板参数是各种可调用对象，通过<code>std::packaged_task</code>把各种可调用对象包装起来，以作为线程入口函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myThread</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="comment">/***代码***/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> <span class="keyword">const</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"current id: "</span>&lt;&lt;<span class="built_in">std</span>::this_thread::get_id()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; pkg(myThread);</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">trd</span><span class="params">(<span class="built_in">std</span>::ref(pkg), <span class="number">10</span>)</span></span>;</span><br><span class="line">    trd.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">future</span>&lt;<span class="keyword">int</span>&gt; ret = pkg.get_future();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;ret.get()&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Main thread.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-2-3-使用-std-promises"><a href="#4-2-3-使用-std-promises" class="headerlink" title="4.2.3 使用 std::promises"></a>4.2.3 使用 std::promises</h3><blockquote>
<p>当一个应用需要处理很多网络连接时，它会使用不同线程尝试连接每个接口，因为这能使网络尽早联通，尽早执行程序。当连接较少的时候，工作没有问题(也就是线程数量比较少)。不幸的是，随着连接数量的增长，这种方式变的越来越不合适；因为大量的线程会消耗大量的系统资源，还有可能造成线程上下文频繁切换(当线程数量超出硬件可接受的并发数时)，这都会对性能有影响。最极端的例子：系统资源被创建的线程消耗殆尽，系统连接网络的能力会变的极差。因此通过少数线程(可能只有一个)处理网络连接，每个线程同时处理多个连接事件，对需要处理大量的网络连接的应用而言是普遍的做法。</p>
</blockquote>
<p>使用一对 <code>std::promise&lt;bool&gt;/std::future&lt;bool&gt;</code> 实现 <strong>单线程处理多接口</strong>，能够在某个线程中给它赋值，然后在其他线程中，把这个值取出来。</p>
<p>```cpp<br>//这个线程计算<br>void mythread(std::promise<int>&amp; prom, int val){<br>    val++;<br>    //假设这个线程花了2s, 得到了运算结果<br>    prom.set_value(val);<br>    return;<br>}</p>
<p>//这个线程使用上面那个线程的计算结果<br>void myTrd(std::future<int>&amp; future){<br>    int ret = future.get();<br>    std::cout&lt;&lt;”myTrd val: “&lt;<ret<<std::endl;
    return;
}
int main(int argc, char const *argv[]){
    std::promise<int> prom; //int 为保存的数据类型，通过这个prom实现两个线程的数据交互<br>    std::future<int> future = prom.get_future();   // 获取结果值<br>    std::thread trd(mythread, std::ref(prom), 10);<br>    std::thread trd2(myTrd, std::ref(future));    // 传递给第二个线程<br>    std::cout&lt;&lt;”main thread.\n”;<br>    trd.join();<br>    trd2.join();<br>    return 0;<br>}<br>``</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP并发_03线程间共享数据</title>
    <url>/2019/11/24/CPP%E5%B9%B6%E5%8F%91-03%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<p>C++ 并发编程学习03</p>
<ul>
<li><p>共享数据带来的问题</p>
</li>
<li><p>使用互斥量保护数据</p>
</li>
<li><p>数据保护的替代方案</p>
</li>
</ul>
<a id="more"></a>
<h2 id="3-1-共享数据带来的问题"><a href="#3-1-共享数据带来的问题" class="headerlink" title="3.1 共享数据带来的问题"></a>3.1 共享数据带来的问题</h2><p>修改共享数据，致使不变量遭到了破坏，可能会造成并行中常见的错误：  <strong>条件竞争（race condition）</strong></p>
<p>并发中 <strong>条件竞争</strong> 的形成，取决于一个以上的线程的相对执行顺序，每个线程都抢着完成自己的任务。并发中对数据的条件竞争通常表示为 <strong>恶性条件竞争</strong></p>
<h3 id="避免恶性条件竞争"><a href="#避免恶性条件竞争" class="headerlink" title="避免恶性条件竞争"></a>避免恶性条件竞争</h3><p>避免 <strong>恶性条件竞争</strong>，最简单的办法就是对数据结构采用某种保护机制，确保只有进行修改的线程才能看到不变量被破坏时的中间状态。从其他访问线程的角度来看，修改不是已经完成了，就是还没开始。</p>
<p>另一个选择是对数据结构和不变量的设计进行修改，修改完的结构必须能完成一系列不可分割的变化，也就是保证每个不变量保持稳定的状态，这就是所谓的无锁编程。</p>
<p>另一种处理条件竞争的方式是，使用事务的方式去处理数据结构的更新。所需的一些数据和读取都存储在事务日志中，然后将之前的操作合为一步，再进行提交</p>
<h2 id="3-2-使用互斥量保护共享数据"><a href="#3-2-使用互斥量保护共享数据" class="headerlink" title="3.2 使用互斥量保护共享数据"></a>3.2 使用互斥量保护共享数据</h2><p>当访问共享数据前，将数据锁住，在访问结束后，再将数据解锁。线程库需要保证，当一个线程使用特定互斥量锁住共享数据时，其他的线程想要访问锁住的数据，都必须等到之前那个线程对数据进行解锁后才能访问，保证了所有线程可以看到共享数据，而不破坏不变量。</p>
<h3 id="3-2-1-使用互斥量"><a href="#3-2-1-使用互斥量" class="headerlink" title="3.2.1 使用互斥量"></a>3.2.1 使用互斥量</h3><p>通过实例化<code>std::mutex</code>创建 <strong>互斥量实例</strong> ，通过 <strong>成员函数</strong> <code>lock()</code>对互斥量上锁，<code>unlock()</code>进行解锁。</p>
<p>C++标准库为互斥量提供了一个 <strong>RAII语法</strong> 的 <strong>模板类</strong> <code>std::lock_guard</code>，在 <strong>构造</strong> 时就能提供已锁的互斥量，并在 <strong>析构</strong> 的时候进行解锁，从而保证了一个已锁互斥量能被正确解锁。</p>
<p>将互斥量和需要保护的数据放在同一类中时， 当其中一个成员函数 <strong>返回</strong> 的是保护数据的指针或引用时，<strong>会破坏数据</strong> 。具有访问能力的指针或引用可以访问(并可能修改)被保护的数据，而不会被互斥锁限制，所以要确保互斥量能锁住数据的访问，并且 <strong>不留后门</strong> 。</p>
<h3 id="3-2-2-用代码来保护共享数据"><a href="#3-2-2-用代码来保护共享数据" class="headerlink" title="3.2.2 用代码来保护共享数据"></a>3.2.2 用代码来保护共享数据</h3><p>使用 <strong>互斥量</strong> 来保护数据，并不是仅仅在每一个成员函数中都加入一个<code>std::lock_guard</code>对象那么简单，一个 <strong>指针或引用</strong> ，也会让这种保护形同虚设。在确保成员函数 <strong>不会传出</strong> 指针或引用的同时，<strong>检查成员函数是否通过指针或引用的方式来调用也很重要。</strong></p>
<h3 id="3-2-3-定位接口间的条件竞争"><a href="#3-2-3-定位接口间的条件竞争" class="headerlink" title="3.2.3 定位接口间的条件竞争"></a>3.2.3 定位接口间的条件竞争</h3><p><code>STL中</code>的<code>stack类</code>是线程不安全的，当你模仿着想写一个属于自己的线程安全的类<code>Stack</code>时，你在 push 和 pop 等操作得时候，加了互斥锁保护数据。但是在多线程环境下使用使用你的<code>Stack类</code>的时候，却仍然有可能是线程不安全的，为什么？</p>
<p>假设<code>Stack</code>类的接口如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//弹出栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>&amp; <span class="title">top</span><span class="params">()</span></span>; <span class="comment">//获取栈顶元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>;<span class="comment">//将元素放入栈</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data; </span><br><span class="line">    <span class="built_in">std</span>::mutex _mu; <span class="comment">//保护内部数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>类中的每个函数都是线程安全的，但是  <strong>组合起来却不是</strong>。加入栈中有 <code>9,3,8,6</code> 四个元素，现在使用两个线程分别取出栈中的元素进行处理，如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">ThreadA</th>
<th style="text-align:left">ThreadB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>int v = st.top() //6</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>int v = st.top() //6</code></td>
</tr>
<tr>
<td style="text-align:center"><code>st.pop(); //弹出6</code></td>
<td style="text-align:left"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>st.pop(); //弹出8</code></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:left"><code>process(v);//处理6</code></td>
</tr>
<tr>
<td style="text-align:center"><code>process(v);//处理6</code></td>
</tr>
</tbody>
</table>
</div>
<p>可以发现在这种执行顺序下， 栈顶元素被处理了两遍，而且多弹出了一个元素 8 ，导致 8 没有被处理！这就是由于接口设计不当引起的竞争。</p>
<p>解决办法：</p>
<p>选项1. 传入一个引用</p>
<p>选项2. 无异常抛出的拷贝构造函数或移动构造函数</p>
<p>选项3. 返回指向弹出值的指针</p>
<p>选项4.  1+2 或 1 + 3</p>
<h4 id="解决方案1：-将两个接口合并为一个"><a href="#解决方案1：-将两个接口合并为一个" class="headerlink" title="解决方案1： 将两个接口合并为一个"></a>解决方案1： 将两个接口合并为一个</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Stack() &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span>&amp; <span class="title">pop</span><span class="params">()</span></span>; <span class="comment">//弹出栈顶元素并返回</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span>;<span class="comment">//将元素放入栈</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; data; </span><br><span class="line">    <span class="built_in">std</span>::mutex _mu; <span class="comment">//保护内部数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面这样使用就不会发生问题</span></span><br><span class="line"><span class="keyword">int</span> v = st.pop(); <span class="comment">// 6</span></span><br><span class="line">process(v);</span><br></pre></td></tr></table></figure>
<p>但是这样修改之后虽然是 <strong>线程安全</strong> 的，但是 <strong>并不是异常安全</strong> 的。这也是为什么STL中栈的出栈操作分解成了两个步骤的原因。<a href="https://segmentfault.com/a/1190000016201729" target="_blank" rel="noopener">参考</a></p>
<p>具体这个 <strong>异常安全</strong> 问题：如果向上面的代码那样，将 pop() 函数的的“弹出值”同时作为返回值返回到调用函数时，调用函数抛出了一个异常会怎么样？因为在将返回值返回到调用函数时发生了内存的拷贝，但是不能保证每次拷贝都是成功的，一旦失败，那么“弹出值”已经从栈上移除了，这样即没得到这个返回值，还丢失了原来栈上的值。这也就是为什么<code>std::stack</code>将这个操作分成了两步：先获取顶部元素(top())， 然后再从栈中移除(pop())，这样就在 不能安全的将元素拷贝出去的情况下，栈中的数据还依旧存在，没有丢失。<a href="https://chenxiaowei.gitbook.io/c-concurrency-in-action-second-edition-2019/3.0-chinese/3.2-chinese#3-2-3-ding-wei-jie-kou-jian-de-tiao-jian-jing-zheng" target="_blank" rel="noopener">来源</a></p>
<h4 id="解决方案2——线程安全的栈：传入一个引用或者返回指向弹出值的指针（选项一-选项三）"><a href="#解决方案2——线程安全的栈：传入一个引用或者返回指向弹出值的指针（选项一-选项三）" class="headerlink" title="解决方案2——线程安全的栈：传入一个引用或者返回指向弹出值的指针（选项一 + 选项三）"></a>解决方案2——线程安全的栈：传入一个引用或者返回指向弹出值的指针（选项一 + 选项三）</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">empty_stack</span> :</span> <span class="built_in">std</span>::exception</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"empty stack"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stack</span>&lt;T&gt; data;</span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    threadsafe_stack() &#123;&#125;</span><br><span class="line">    threadsafe_stack(<span class="keyword">const</span> threadsafe_stack&amp; other)  <span class="comment">//拷贝构造函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(other.m); <span class="comment">// 使用互斥量确保复制结果的正确性</span></span><br><span class="line">        data = other.data;</span><br><span class="line">    &#125;</span><br><span class="line">    threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>; <span class="comment">//栈不能直接返回，所以删除赋值操作</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m);</span><br><span class="line">        data.push(new_value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; pop()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m);  <span class="comment">//相当于锁住了这个作用域，避免其他线程的竞争</span></span><br><span class="line">        <span class="keyword">if</span> (data.empty()) <span class="keyword">throw</span> empty_stack();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; <span class="function"><span class="keyword">const</span> <span class="title">res</span><span class="params">(<span class="built_in">std</span>::make_shared&lt;T&gt;(data.top()))</span></span>;</span><br><span class="line">        data.pop();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span>  <span class="comment">// 将变量的引用作为参数</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m); <span class="comment">//相当于锁住了这个作用域,避免其他线程的竞争</span></span><br><span class="line">        <span class="keyword">if</span> (data.empty()) <span class="keyword">throw</span> empty_stack();</span><br><span class="line">        value = data.top();</span><br><span class="line">        data.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(m);</span><br><span class="line">        <span class="keyword">return</span> data.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    threadsafe_stack&lt;<span class="keyword">int</span>&gt; si;</span><br><span class="line">    si.push(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">//选项三：返回一个指向弹出元素的指针，而不是直接返回值，指针的优势是自由拷贝，且不会产生异常</span></span><br><span class="line">    <span class="comment">//缺点是返回一个指针需要对对象的内存分配进行管理，对于简单的数据类型（比如：int），内存管理的开销远大于直接返回值</span></span><br><span class="line">    <span class="comment">//使用 std::shared_ptr 不仅能避免内存泄漏，且标准库能完全控制内存分配方案</span></span><br><span class="line">    <span class="comment">//std::shared_ptr&lt;int&gt; ptr = si.pop();  </span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *si.pop() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//输出5</span></span><br><span class="line">    <span class="keyword">if</span> (!si.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"stack is not empty"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">//选项一： 传入一个引用</span></span><br><span class="line">        <span class="comment">// 但是，构造一个栈中类型的实例，用于接收目标值，从时间和资源的角度看都是不划算的</span></span><br><span class="line">        <span class="comment">//对于其他类型一不一定可行，因为构造函数需要的一些参数，在这个阶段的代码不一定可用</span></span><br><span class="line">        <span class="comment">// 很多用户自定义类型可能都不支持赋值操作</span></span><br><span class="line">        <span class="keyword">int</span> x; </span><br><span class="line">        si.pop(x); <span class="comment">// 因为传入的 x 是引用</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">// 这样也可以得到 5</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-4-死锁"><a href="#3-2-4-死锁" class="headerlink" title="3.2.4 死锁"></a>3.2.4 死锁</h3><h3 id="3-2-5-避免死锁的指导"><a href="#3-2-5-避免死锁的指导" class="headerlink" title="3.2.5 避免死锁的指导"></a>3.2.5 避免死锁的指导</h3><h4 id="1-避免嵌套锁"><a href="#1-避免嵌套锁" class="headerlink" title="1. 避免嵌套锁"></a>1. 避免嵌套锁</h4><h4 id="2-避免在持有锁时调用用户提供的代码"><a href="#2-避免在持有锁时调用用户提供的代码" class="headerlink" title="2. 避免在持有锁时调用用户提供的代码"></a>2. 避免在持有锁时调用用户提供的代码</h4><h4 id="3-使用固定顺序获取锁"><a href="#3-使用固定顺序获取锁" class="headerlink" title="3. 使用固定顺序获取锁"></a>3. 使用固定顺序获取锁</h4><h4 id="4-使用锁的层次结构"><a href="#4-使用锁的层次结构" class="headerlink" title="4. 使用锁的层次结构"></a>4. 使用锁的层次结构</h4>]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP并发_02线程管理</title>
    <url>/2019/11/24/CPP%E5%B9%B6%E5%8F%91-02%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>C++ 并发编程学习02 <strong>启动新线程，等待线程与分离线程。</strong></p>
<p>启动一个线程，等待这个线程结束，或放在后台运行。</p>
<p>再看看怎么给已经启动的线程函数传递参数，以及怎么将一个线程的 <strong>所有权</strong> 从当前<code>std::thread</code>对象移交给另一个。</p>
<p>最后，再来确定线程数，以及识别特殊线程。</p>
<a id="more"></a>
<h1 id="02-线程管理"><a href="#02-线程管理" class="headerlink" title="02 线程管理"></a>02 线程管理</h1><h2 id="2-1-线程管理的基础"><a href="#2-1-线程管理的基础" class="headerlink" title="2.1 线程管理的基础"></a>2.1 线程管理的基础</h2><h3 id="等待线程完成"><a href="#等待线程完成" class="headerlink" title="等待线程完成"></a>等待线程完成</h3><p><code>join()</code> 是简单粗暴的等待线程完成或不等待。调用<code>join()</code>还清理了线程相关的存储部分，这样<code>std::thread</code>对象将不再与已经完成的线程有任何关联，这意味着只能对 <strong>一个线程</strong> 使用 <strong>一次</strong> <code>join()</code>，一旦使用过，<code>std::thread</code>对象就不能再次加入。</p>
<h3 id="后台运行线程"><a href="#后台运行线程" class="headerlink" title="后台运行线程"></a>后台运行线程</h3><p>使用<code>detach()</code>会让线程在后台运行，这就意味着主线程不能与之产生直接交互。</p>
<p>分离线程 也被称为 <strong>守护线程(daemon threads)</strong>， UNIX中守护线程是指，没有任何显式的用户接口，并在后台运行的线程。其特点就是长时间运行，线程的生命周期可能会从某一个应用起始到结束，可能会在后台监视文件系统，还有可能对缓存进行清理，亦或对数据结构进行优化。</p>
<p>调用<code>std::thread</code>成员函数detach()来分离一个线程。之后，相应的<code>std::thread</code>对象就与实际执行的线程无关了，并且这个线程也无法加入：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(do_background_work)</span></span>;</span><br><span class="line">t.detach();</span><br><span class="line">assert(!t.joinable());</span><br></pre></td></tr></table></figure>
<p>不能对没有执行线程的<code>std::thread</code>对象使用detach()或者join(),并且要用同样的方式进行检查——当<code>std::thread</code>对象使用<code>t.joinable()</code>返回的是true，就可以使用<code>t.detach()</code>。</p>
<p>使用场景：</p>
<blockquote>
<p>让一个文字处理应用同时编辑多个文档。无论是用户界面，还是在内部应用内部进行，都有很多的解决方法。虽然，这些窗口看起来是完全独立的，每个窗口都有自己独立的菜单选项，但他们却运行在同一个应用实例中。一种内部处理方式是，让每个文档处理窗口拥有自己的线程；每个线程运行同样的的代码，并隔离不同窗口处理的数据。如此这般，打开一个文档就要启动一个新线程。因为是对独立的文档进行操作，所以没有必要等待其他线程完成。因此，这里就可以让文档处理窗口运行在分离的线程上</p>
</blockquote>
<h2 id="2-2-向线程函数传递参数"><a href="#2-2-向线程函数传递参数" class="headerlink" title="2.2 向线程函数传递参数"></a>2.2 向线程函数传递参数</h2><p>在默认情况下，这些参数会被拷贝至 <strong>新线程</strong> 的 <strong>独立内存空间</strong> 中，以供新线程访问，并如同临时变量一样作为右值传递给可调用对象或函数。即使函数中的参数是 <strong>引用</strong> 的形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; s)</span></span>; <span class="comment">// 指针地址不可修改</span></span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(f, <span class="number">3</span>, <span class="string">"hello"</span>)</span></span>; <span class="comment">//向线程函数传递参数</span></span><br></pre></td></tr></table></figure>
<p>如果线程函数期待传入一个引用，可以使用<code>std::ref</code>将参数转换成引用的形式：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_data_for_widget</span><span class="params">(widget_id w,widget_data&amp; data)</span></span>; <span class="comment">//线程函数期待传入一个引用</span></span><br><span class="line">widget_data data;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(update_data_for_widget,w,<span class="built_in">std</span>::ref(data))</span></span>;</span><br></pre></td></tr></table></figure><br>从而，<code>update_data_for_widget</code>就会接收到一个<code>data</code>变量的引用，而非<code>data</code>变量的拷贝副本。</p>
<blockquote>
<p>上面两个例子的区别在于前者期待传入的 常量引用，而后者期待传入引用，即希望可以对其进行修改。</p>
</blockquote>
<p>执行线程的所有权可以多个<code>std::thread</code>实例中互相转移，这是依赖于<code>std::threa</code>实例的 <strong>可移动性</strong> 和 <strong>不可复制性</strong>。<strong>不可复制性</strong> 保证了在同一时间点，一个<code>std::thread</code>实例只能关联一个执行线程； <strong>可移动性</strong> 使得开发者可以自己决定，哪个实例拥有实际执行线程的所有权。 </p>
<h2 id="2-3-转移线程所有权"><a href="#2-3-转移线程所有权" class="headerlink" title="2.3 转移线程所有权"></a>2.3 转移线程所有权</h2><p>假设要写一个在后台启动线程的函数，并想通过新线程返回的所有权去调用这个函数，而不是等待线程结束再去调用。或完全与之相反的想法：创建一个线程，并在函数中转移所有权，都必须要等待线程结束。所以，新线程的所有权都需要转移。</p>
<p>这就需要将 <strong>移动操作</strong> 引入<code>std::thread</code></p>
<p>下面的例子，创建了两个执行线程，并且在<code>std::thread</code>实例之间(t1, t2, t3)转移所有权。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(some_function)</span></span>;            <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">std</span>::thread t2=<span class="built_in">std</span>::move(t1);            <span class="comment">// 2</span></span><br><span class="line">t1=<span class="built_in">std</span>::thread(some_other_function);    <span class="comment">// 3</span></span><br><span class="line"><span class="built_in">std</span>::thread t3;                            <span class="comment">// 4</span></span><br><span class="line">t3=<span class="built_in">std</span>::move(t2);                        <span class="comment">// 5</span></span><br><span class="line">t1=<span class="built_in">std</span>::move(t3);                        <span class="comment">// 6 赋值操作将使程序崩溃</span></span><br></pre></td></tr></table></figure>
<p>1： 新线程开始与t1相关联；<br>2： 显式使用<code>std::move()</code>创建 t2后 ， t1 的所有权就转移给了 t2 ，之后执行线程就和 t2 没有关联了；<br>3： 一个临时<code>std::thread</code>对象相关的线程启动了。为什么不显式调用<code>std::move()</code>转移所有权呢？因为，所有者是一个 <strong>临时对象</strong> ——移动操作将会 <strong>隐式的调用</strong>；<br>4： 使用默认构造方式创建 t3, 没有与任何线程相关联；<br>5： 调用<code>std::move()</code>将与t2关联线程的所有权转移到t3中。因为t2是一个命名对象，需要显式的调用<code>std::move()</code>。移动操作 #5 完成后，t1与执行some_other_function的线程相关联，t2与任何线程都无关联，t3与执行some_function的线程相关联。<br>6： 最后一个移动操作，将<code>some_function</code>线程的所有权转移给t1。不过，t1已经有了一个关联的线程(执行<code>some_other_function</code>的线程)，所以这里系统直接调用<code>std::terminate()</code>终止程序继续运行。</p>
<h2 id="2-4-运行时决定线程数量"><a href="#2-4-运行时决定线程数量" class="headerlink" title="2.4 运行时决定线程数量"></a>2.4 运行时决定线程数量</h2><p><code>std::thread::hardware_concurrency()</code> 这个函数会返回能并发在一个程序中的线程数量。例如，多核系统中，返回值可以是CPU核芯的数量。返回值也仅仅是一个提示，当系统信息无法获取时，函数也会返回0。</p>
<h3 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//模板类，使下面的结构体可以适配更多的数据类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">accumulate_block</span> //结构体</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first, Iterator last, T&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        result = <span class="built_in">std</span>::accumulate(first, last, result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator, <span class="keyword">typename</span> T&gt;  <span class="comment">//typename 就是定义的传入的参数的类型， int,float,string等</span></span><br><span class="line"> <span class="comment">//first 和 last都是迭代器类型，即 vi.begin(), vi.end()</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first, Iterator last, T init)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 计算vector中数据的个数， 前面的long占了 4各字节即32位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> length = <span class="built_in">std</span>::distance(first, last);      </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"num length: "</span> &lt;&lt; length &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!length)</span><br><span class="line">        <span class="keyword">return</span> init;</span><br><span class="line">    <span class="comment">//定义每个线程的最小任务数为 25，可以自己定义</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> min_per_thread = <span class="number">25</span>; </span><br><span class="line">    <span class="comment">// 根据上面的每个线程最小任务数，计算最多需要多少个线程</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> max_threads = (length + min_per_thread - <span class="number">1</span>) / min_per_thread; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max threads: "</span> &lt;&lt; max_threads &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 计算硬件所能支持的线程束</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hardware_threads = <span class="built_in">std</span>::thread::hardware_concurrency();  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"hardware threads : "</span> &lt;&lt; hardware_threads &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">//选择上面两者较小的值作为最后的线程数量</span></span><br><span class="line">    <span class="comment">//因为上下文频繁的切换会降低线程的性能，</span></span><br><span class="line">    <span class="comment">//所以你肯定不想启动的线程数多于硬件支持的线程数量，</span></span><br><span class="line">    <span class="comment">//如果hardware_threads=0，则最好就别进行多线程操作了，选个小的值比如2就行</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> num_threads = <span class="built_in">std</span>::min(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"num threads: "</span> &lt;&lt; num_threads &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 最后更新，每个线程中处理的元素数量，即上面的每个线程的任务数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> block_size = length / num_threads; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"block size: "</span> &lt;&lt; block_size &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; results(num_threads);</span><br><span class="line">    <span class="comment">//存放线程的容器，启动的线程数要比 num_threads，因为启动之前已经有一个主线程了</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt;  threads(num_threads - <span class="number">1</span>);  </span><br><span class="line"></span><br><span class="line">    Iterator block_start = first;</span><br><span class="line">    <span class="comment">// 使用简单的循环启动线程，注意因为最后一个块可能不是完整的，</span></span><br><span class="line">    <span class="comment">//所以计算前 n-1 个，最后一个block 单独计算</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span> i = <span class="number">0</span>; i &lt; (num_threads - <span class="number">1</span>); ++i)  </span><br><span class="line">    &#123;</span><br><span class="line">        Iterator block_end = block_start;</span><br><span class="line">        <span class="comment">// block_end 移动到当前块的末尾，当前块的大小即每个线程中的任务数</span></span><br><span class="line">        <span class="built_in">std</span>::advance(block_end, block_size);  </span><br><span class="line">        <span class="comment">// 启动线程函数，并传入参数</span></span><br><span class="line">        <span class="comment">// 将原来的数据拆分成小的 block 然后多线程进行计算， </span></span><br><span class="line">        <span class="comment">//传入的 block_start 和 block_end 都是迭代器， 最后的结果通过引用保存到 results 中</span></span><br><span class="line">        <span class="comment">// std::ref 就是前面的提到的，将引用作为参数传递的一种方法，目的是用来保存线程计算的结果</span></span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(accumulate_block&lt;Iterator, T&gt;(),block_start, block_end, <span class="built_in">std</span>::ref(results[i]));  </span><br><span class="line">        block_start = block_end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算最后一个 block的结果，因为可能其大小不是 block_size</span></span><br><span class="line">    accumulate_block&lt;Iterator, T&gt;()(block_start, last, results[num_threads - <span class="number">1</span>]); </span><br><span class="line">    <span class="comment">//等待线程完成  std::men_fn 为函数适配器</span></span><br><span class="line">    <span class="built_in">std</span>::for_each(threads.begin(), threads.end(),<span class="built_in">std</span>::mem_fn(&amp;<span class="built_in">std</span>::thread::join));  </span><br><span class="line">    <span class="comment">//for (auto&amp; entry : threads)  //和上面的效果等价</span></span><br><span class="line">    <span class="comment">//	entry.join();  // 10</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// std::accumulate进行累加， begin, end, init, init就是在前面累加结果的基础加上</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::accumulate(results.begin(), results.end(), init);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">60</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vi.push_back(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = parallel_accumulate(vi.begin(), vi.end(), <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum="</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出效果：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191117183930.png" width="300"/></p>
<p>如果 <code>main()</code> 改成如下：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">71</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        vi.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = parallel_accumulate(vi.begin(), vi.end(), <span class="number">5</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sum="</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>结果为：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191117184031.png" width="300"/></p>
<p>主要经历了下面的几个步骤：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/D59F0D8784748F372C5F84D540A62996.png"/></p>
<h2 id="2-5-标识线程"><a href="#2-5-标识线程" class="headerlink" title="2.5 标识线程"></a>2.5 标识线程</h2><p>线程标识类型为<code>std::thread::id</code>，可以通过两种方式进行检索，</p>
<ol>
<li><p>通过调用<code>std::thread</code>对象的成员函数<code>get_id()</code>来获取</p>
</li>
<li><p>当前线程中调用<code>std::this_thread::get_id()</code></p>
</li>
</ol>
<p>线程ID 可以在容器中作为键值，如，容器可以存储其掌控下每个线程的信息，或在多线程中互传信息。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CPP并发_01你好</title>
    <url>/2019/11/24/CPP%E5%B9%B6%E5%8F%91-01%E4%BD%A0%E5%A5%BD/</url>
    <content><![CDATA[<p>C++ 并发编程学习01</p>
<a id="more"></a>
<h2 id="为什么需要并发编程？"><a href="#为什么需要并发编程？" class="headerlink" title="为什么需要并发编程？"></a>为什么需要并发编程？</h2><h3 id="1-分离关注点"><a href="#1-分离关注点" class="headerlink" title="1. 分离关注点"></a>1. 分离关注点</h3><p>将相关的代码与无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能性。使用并发分离出不同的功能区域。例如，独立的线程通常用来执行那些必须在后台持续运行的任务，如，桌面搜索程序中监视文件系统变化的任务。</p>
<h3 id="2-为了性能"><a href="#2-为了性能" class="headerlink" title="2. 为了性能"></a>2. 为了性能</h3><p>两种方式:</p>
<ol>
<li><p><strong>任务并行：</strong>  将一个单一任务分成几部分，且各自并行运行，从而降低总运行时间，每个线程执行不同部分的算法。也被称为 <strong>易并行算法</strong></p>
</li>
<li><p><strong>数据并行：</strong> 每个线程在不同的数据部分上执行相同的操作。</p>
</li>
</ol>
<h3 id="3-什么时候不适用并发？"><a href="#3-什么时候不适用并发？" class="headerlink" title="3. 什么时候不适用并发？"></a>3. 什么时候不适用并发？</h3><p>收益比不上成本，操作系统需要分配内核相关资源和堆栈空间，所以在启动线程时需要开销，然后才能把新线程加入到 <strong>调度器</strong> 中，这都需要时间。</p>
<p>线程的资源有限。如果太多的线程同时运行，则会消耗很多 <strong>操作系统资源</strong> ，从而使得操作系统整体上运行得更加缓慢</p>
<p>每个线程都需要一个 <strong>独立的堆栈空间</strong>，所以运行太多的线程也会耗尽进程的 <strong>可用内存或地址空间</strong>。</p>
<p>运行越多的线程，<strong>操作系统</strong> 就需要越多的 <strong>上下文切换</strong>，每一次切换都需要耗费本可以花在有价值工作上的时间。</p>
<h2 id="并发和多线程"><a href="#并发和多线程" class="headerlink" title="并发和多线程"></a>并发和多线程</h2><h3 id="新标准支持并发"><a href="#新标准支持并发" class="headerlink" title="新标准支持并发"></a>新标准支持并发</h3><p>Boost线程库作为新类库的主要模型，很多类与Boost库中的相关类有着相同名称和结构。随着C++标准的进步，Boost线程库也配合着C++标准在许多方面做出改变，因此之前使用Boost的用户将会发现自己非常熟悉C++11的线程库。</p>
<h3 id="C-线程库的效率"><a href="#C-线程库的效率" class="headerlink" title="C++线程库的效率"></a>C++线程库的效率</h3><p>为了效率，C++类整合了一些底层工具。这样就需要了解相关使用 <strong>高级工具</strong> 和使用 <strong>低级工具</strong> 的开销差，这个开销差就是抽象代价(abstraction penalty)。</p>
<p>C++为了提供足够多的底层工具，伴随着新的内存模型，形成了一个综合的原子操作库，可用于直接控制单个位、字节、内部线程同步，以及对所有变化的可见性。</p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;  // 1</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span>  <span class="comment">// 2</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello Concurrent World\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(hello)</span></span>;  <span class="comment">// 3</span></span><br><span class="line">  t.join();  <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>打印信息的代码被移动到了一个独立的函数中(_2_) 。因为每个线程都必须具有一个初始函数(initial function)，新线程的执行从这里开始。</p>
<p>对于应用程序来说，初始线程是<code>main()</code>，但是对于其他线程，可以在<code>std::thread</code>对象的 <strong>构造函数</strong> 中指定。本例中，被命名为<code>t</code> (_3_)的<code>std::thread</code>对象拥有新函数<code>hello()</code>作为其初始函数。</p>
<p>所以程序启动时，将线程一分为二，初始线程始于 <code>main()</code>，而新线程始于<code>hello()</code></p>
<p>初始线程继续执行。如果它不等待新线程结束，它就将自顾自地继续运行到<code>main()</code>的结束，从而结束程序——有可能发生在新线程运行之前。这就是为什么在(_4_)这里调用<code>join()</code>的原因——这会导致调用线程(在<code>main()</code>中)等待与<code>std::thread</code>对象相关联的线程，即这个例子中的<code>t</code>。</p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Boost多线程学习</title>
    <url>/2019/11/16/Boost%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<p>涉及线程管理、同步（互斥锁、条件变量）以及线程本地存储</p>
<a id="more"></a>
<h2 id="Boost多线程"><a href="#Boost多线程" class="headerlink" title="Boost多线程"></a>Boost多线程</h2><p><a href="http://zh.highscore.de/cpp/boost/" target="_blank" rel="noopener">来源</a></p>
<h3 id="线程管理"><a href="#线程管理" class="headerlink" title="线程管理"></a>线程管理</h3><h4 id="如何等待一个不同的线程"><a href="#如何等待一个不同的线程" class="headerlink" title="如何等待一个不同的线程"></a>如何等待一个不同的线程</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  boost::this_thread::sleep(boost::posix_time::seconds(seconds));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    wait(<span class="number">1</span>); <span class="comment">//为了减缓输出，延迟1秒</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  boost::<span class="function">thread <span class="title">t</span><span class="params">(threadFun)</span></span>;  <span class="comment">// 上面的那个函数</span></span><br><span class="line">  t.join();  <span class="comment">// join() 方法是一个阻塞调用：它可以暂停当前线程，直到调用 join() 的线程运行结束，这就使得 main() 函数一直会等待到 thread() 运行结束</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1秒间隔输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td></tr></table></figure>
<p>一个特定的线程可以通过诸如 t 的变量访问，通过这个变量等待着它的使用 <code>join()</code>方法终止。 上述例子中，使用一个循环把 5 个数字写入标准输出流。使用 <code>wait</code>执行延迟，<code>wait</code>调用<code>sleep</code>函数，<code>sleep</code>来自<code>Boost.thread</code>,位于<code>boost::this_thread</code>命名空间内, <code>sleep()</code>在预计的一段时间或一个特定的时间点后才让线程继续执行。</p>
<p><strong>关于阻塞调用和非阻塞调用：</strong></p>
<p><code>阻塞调用：</code> 调用结果返回前，当前线程会被挂起，调用线程只有在得到结果之后才返回；</p>
<p><code>非阻塞调用：</code> 在不能立刻得到结果之前，该调用不会阻塞当前线程。</p>
<p>例子：</p>
<p><code>打电话给书店老板问有没有《分布式系统》的书，如果是阻塞调用，你会一直把自己“挂起”，直到得到这本书有没有的结果， 如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边玩去了，偶尔过几分钟 check 一下老板有没有结果。</code></p>
<p>这里的阻塞和非阻塞与是否同步异步无关，根老板通过什么方式回答你无关。</p>
<p><strong>同步和异步：</strong></p>
<p>关注的是 <strong>消息通信机制</strong></p>
<p><code>同步：</code> 就是在发布一个 <strong>调用</strong> 时，在没有得到结果之前，该 <strong>调用</strong> 就不返回，但是一旦调用返回，就得到返回值了，也就是调用者 <strong>主动等待</strong>  这个调用结果。</p>
<p><code>异步：</code> <strong>调用发布后，这个调用就直接返回了，所以没有返回结果。</strong> 也就是当一个异步过程调用发出后，调用者不会立刻得到结果，而是在调用发出后，被调用者通过状态、通知来通知调用者，或者通过回调函数处理这个调用。</p>
<p>例子：</p>
<p><code>你打电话问书店老板有没有《分布式系统》这本书，如果是同步通信机制，书店老板会说，你稍等，”我查一下&quot;，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。</code></p>
<p><a href="https://www.zhihu.com/question/19732473" target="_blank" rel="noopener">知乎</a></p>
<h4 id="如何通过中断点让线程中断"><a href="#如何通过中断点让线程中断" class="headerlink" title="如何通过中断点让线程中断"></a>如何通过中断点让线程中断</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> seconds)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  boost::this_thread::sleep(boost::posix_time::seconds(seconds)); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">try</span> </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) </span><br><span class="line">    &#123; </span><br><span class="line">      wait(<span class="number">1</span>); </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">catch</span> (boost::thread_interrupted&amp;) </span><br><span class="line">  &#123; </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"catch thread interrupted"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  boost::<span class="function">thread <span class="title">t</span><span class="params">(threadFun)</span></span>; </span><br><span class="line">  wait(<span class="number">3</span>); </span><br><span class="line">  t.interrupt();  <span class="comment">//在一个线程对象上调用 interrupt() 会中断相应的线程。</span></span><br><span class="line">  t.join(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的流程如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/6CE877CF04C340ED4105E7D75C60279F.jpg"/></p>
<p>由于在main里3秒后调用 interrupt()方法。 因此，相应的线程被中断，并抛出一个 boost::thread_interrupted 异常。 这个异常在线程内也被正确地捕获，<code>threadFun</code>函数也在处理完这个异常后返回，线程被终止，这反过来也将终止整个程序，因为<code>main()</code>一直在等待该线程，所以使用<code>join()</code>终止该线程</p>
<p>所以最后的输出结果为：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111143823.png" width="300"/></p>
<p>在一个线程上调用<code>interrupt()</code>会中断相应的线程，同时，中断意味着一个类型为<code>boost::thread_interrupt</code>的异常，它会在这个线程中抛出，只有在 <strong>线程达到中断点时才会发生</strong>，比如上面代码中的<code>this_thread</code>或者<code>t.join</code>就是线程的中断点。</p>
<p>如果给定的线程中不包含任何中断点，简单调用<code>interrupt()</code>就不会起作用。每当（调用）一个线程中断点，它都会检查<code>interrupt</code>是否被调用，只有被调用了<code>boost::thread_interrupt</code>异常才会相应地抛出。上面例子中的<code>sleep()</code>被调用了 5 次，所以该线程也就检查了五次它是否应该被中断。</p>
<blockquote>
<p>思考，如果上面的程序 <code>threadFun</code> 函数中的 <code>wait(1)</code> 和下面的 <code>cout</code>函数进行位置替换是什么样的？</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">try</span> </span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) </span><br><span class="line">    &#123; </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">      wait(<span class="number">1</span>); </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">catch</span> (boost::thread_interrupted&amp;) </span><br><span class="line">  &#123; </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"catch thread interrupted"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111174003.png" width="300"/></p>
<p>流程图如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/AFFEDC85B7426F302BE5D6BF9EE0638D.jpg"/></p>
<p>因为输出在<code>wait(1)</code>前面，所以先进行了输出再进行等待。</p>
<p><strong>线程中断点：</strong></p>
<p>线程 <strong>并非</strong> 在任何时候都可以中断的，boost的thread库中定义了 <strong>若干中断点</strong>，只有当线程执行到中断点的时候才会被中断，一个线程可以有若干个线程中断点。</p>
<p>thread 库定义了 9 个中断点，它们都是函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread::join();</span><br><span class="line">thread::timed_join();</span><br><span class="line">condition_variable::wait();</span><br><span class="line">condition_variable::timed_wait();</span><br><span class="line">condition_variable_any::wait();</span><br><span class="line">condition_variable_any::timed_wait();</span><br><span class="line">thread::sleep();</span><br><span class="line">this_thread::sleep();</span><br><span class="line">this_thread::interruption_point();</span><br></pre></td></tr></table></figure>
<p>前8个都是某种形式的等待函数，表明线程在阻塞的时候可以被中断。而最后一个<code>this_thread::interruption_point()</code>;则是一个特殊的中断点函数，它并不等待，只是起到一个标签的作用，表示线程执行到这个地方可以被中断。</p>
<p><a href="https://www.cnblogs.com/happykoukou/p/6986203.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>虽然多线程的使用可以提高应用程序的性能，但也增加了复杂性。使用使用线程在同一时间执行几个函数，访问共享资源时必须同步。<code>Boost.Thread</code> 提供了同步线程的类。</p>
<h4 id="boost-mutex-互斥类，lock-和-unlock"><a href="#boost-mutex-互斥类，lock-和-unlock" class="headerlink" title="boost::mutex 互斥类，lock() 和 unlock()"></a>boost::mutex 互斥类，lock() 和 unlock()</h4><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  boost::this_thread::sleep(boost::posix_time::seconds(seconds));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    wait(<span class="number">1</span>);</span><br><span class="line">    mutex.lock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; boost::this_thread::get_id() &lt;&lt; <span class="string">": "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    mutex.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"start"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  boost::<span class="function">thread <span class="title">t1</span><span class="params">(threadFun)</span></span>;</span><br><span class="line">  boost::<span class="function">thread <span class="title">t2</span><span class="params">(threadFun)</span></span>;</span><br><span class="line">  t1.join();</span><br><span class="line">  t2.join();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出效果：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/thread_out1.gif" width="300"/></p>
<p>这里使用互斥对象进行同步， <code>Boost.Thread</code>提供多个互斥类， <code>boost::mutex</code>是最简单的一个，互斥的基本原则是当一个特定的线程拥有资源的时候 <strong>防止</strong> 其他资源夺取其所有权。一旦释放，其他的线程可以取得所有权。 这将导致线程等待至另一个线程完成处理一些操作，从而相应地释放互斥对象的所有权。</p>
<p><code>main()</code> 创建两个线程，同时执行 <code>threadFun()</code>函数。 利用 for 循环，每个线程数到5，因为标准输出流（<code>std::cout</code>）是一个全局性的被所有线程共享的对象，不能保证其可以安全地从多个线程访问。因此，标准输出流必须同步：在任何时候，只有一个线程可以访问 <code>std::out</code></p>
<p>不管哪个线程成功调用 <code>lock()</code> 方法，其他所有线程必须等待，直到 <code>unlock()</code> 被调用。 </p>
<blockquote>
<p>思考：互斥锁放置在不同的位置是否会得到不一样的结果？</p>
</blockquote>
<p>进行如下修改：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  mutex.lock();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    wait(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; boost::this_thread::get_id() &lt;&lt; <span class="string">": "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  mutex.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/thread_out2.gif" width="300"/></p>
<p>感觉这个例子能更好说明问题，虽然是两个线程，但是线程2 需要等待线程1 运行结束之后释放 <code>std::cout</code> 的资源之后才会得到 <code>std::cout</code>的资源，而这正是因为<code>lock</code>和<code>unlock</code>的存在才能保证资源之间不相互抢占。</p>
<blockquote>
<p>疑问： 当注释掉 <code>lock</code> 和<code>unlock</code>之后整体输出和上一个例子效果基本一样，但是当再注释到 <code>wait(1)</code> 之后，就会出现<code>std::cout</code>混乱的现象，猜测是因为等待时间的存在，资源之间的抢占并不严重，但没有这个等待时间，资源之间相互抢占的现象将显现出来。</p>
</blockquote>
<h4 id="boost-lock-guard-——-不直接调用-lock-和-unlock"><a href="#boost-lock-guard-——-不直接调用-lock-和-unlock" class="headerlink" title="boost::lock_guard —— 不直接调用 lock() 和 unlock()"></a>boost::lock_guard —— 不直接调用 lock() 和 unlock()</h4><p><code>boost::lock_guard</code>在其内部构造和析构函数分别自动调用<code>lock()</code>和<code>unlock()</code>函数。</p>
<p>只要修改 <code>threadFun</code> 的部分：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    wait(<span class="number">1</span>);</span><br><span class="line">    boost::lock_guard&lt;boost::mutex&gt; lock(mutex);  <span class="comment">//位置1</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; boost::this_thread::get_id() &lt;&lt; <span class="string">": "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//boost::lock_guard&lt;boost::mutex&gt; lock(mutex);  //位置2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>放在位置1 和 位置2 上看不出区别。</p>
<p>位置1：<br><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/thread_out3.gif" width="250"/></p>
<p>位置2：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191114153751.png" width="140"/></p>
<blockquote>
<p>一直存在的疑问： 从输出看两个线程是达到了同步输出的效果，但是从输出的线程id看，每次输出顺序是不太一样的，不太清楚原因是什么？难道本来就是这样的？本来期望的是每次两个线程输出的顺序也会一直保持一致。</p>
</blockquote>
<h4 id="模板类-Class-template-unique-lock-和-shared-lock"><a href="#模板类-Class-template-unique-lock-和-shared-lock" class="headerlink" title="模板类(Class template): unique_lock 和 shared_lock"></a>模板类(Class template): unique_lock 和 shared_lock</h4><p><a href="https://blog.csdn.net/weixin_30907935/article/details/95182154" target="_blank" rel="noopener">类模板和模板类</a></p>
<h5 id="boost-unique-lock-——独占锁"><a href="#boost-unique-lock-——独占锁" class="headerlink" title="boost::unique_lock() ——独占锁"></a>boost::unique_lock() ——独占锁</h5><p>独占锁意味着一个互斥量同时只能被一个线程获取。 其他线程必须等待，直到互斥体再次被释放。</p>
<p>官方文档介绍：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191114192357.png"/></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">boost::timed_mutex mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    wait(<span class="number">1</span>);</span><br><span class="line">    boost::unique_lock&lt;boost::timed_mutex&gt; lock(mutex, boost::try_to_lock);</span><br><span class="line">    <span class="comment">// try_to_lock 对应的构造函数会调用 try_lock() 方法</span></span><br><span class="line">    <span class="keyword">if</span> (!lock.owns_lock())</span><br><span class="line">      lock.timed_lock(boost::get_system_time() + boost::posix_time::seconds(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; boost::this_thread::get_id() &lt;&lt; <span class="string">": "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    boost::timed_mutex *m = lock.release();</span><br><span class="line">    m-&gt;unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数显示了三种方法获取一个互斥体：</p>
<ol>
<li><p><code>lock()</code> ，一直等待直到获得一个互斥体；</p>
</li>
<li><p><code>try_lock()</code>， 不会等待，只会在互斥体可用的时候才能获得；</p>
</li>
<li><p><code>timed_lock()</code>，试图在一定时间内获取互斥体</p>
</li>
</ol>
<h5 id="boost-shared-lock-——非独占锁"><a href="#boost-shared-lock-——非独占锁" class="headerlink" title="boost::shared_lock() ——非独占锁"></a>boost::shared_lock() ——非独占锁</h5><p>该类 必须和<code>boost::shared_mutex</code>类型的互斥量结合使用</p>
<p>官方文档介绍：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191114192448.png"/></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  boost::this_thread::sleep(boost::posix_time::seconds(seconds));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boost::shared_mutex mutex;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; random_numbers;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::srand(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(<span class="built_in">std</span>::time(<span class="number">0</span>)));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    boost::unique_lock&lt;boost::shared_mutex&gt; lock(mutex);</span><br><span class="line">    random_numbers.push_back(<span class="built_in">std</span>::rand());</span><br><span class="line">    lock.unlock();</span><br><span class="line">    wait(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    wait(<span class="number">1</span>);</span><br><span class="line">    boost::shared_lock&lt;boost::shared_mutex&gt; lock(mutex);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"i : "</span> &lt;&lt; i &lt;&lt; <span class="string">", value: "</span> &lt;&lt; random_numbers.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    wait(<span class="number">1</span>);</span><br><span class="line">    boost::shared_lock&lt;boost::shared_mutex&gt; lock(mutex);</span><br><span class="line">    sum += random_numbers.back();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  boost::<span class="function">thread <span class="title">t1</span><span class="params">(fill)</span></span>;</span><br><span class="line">  boost::<span class="function">thread <span class="title">t2</span><span class="params">(print)</span></span>;</span><br><span class="line">  boost::<span class="function">thread <span class="title">t3</span><span class="params">(count)</span></span>;</span><br><span class="line">  t1.join();</span><br><span class="line">  t2.join();</span><br><span class="line">  t3.join();</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Sum: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/thread_out4.gif" width="300"/></p>
<p>这里多线程的效果就是似乎 <code>fill</code>,<code>print</code>,<code>count</code>似乎是在同一时间一起完成的。</p>
<p>具体：</p>
<p><code>print()</code> 和 <code>count()</code> 都可以只读访问 <code>random_numbers</code> 。 </p>
<p><code>print()</code> 函数把 <code>random_numbers</code> 里的最后一个数写到标准输出；</p>
<p><code>count()</code> 函数把它统计到 <code>sum</code> 变量。 由于两个函数都 <strong>没有修改</strong> <code>random_numbers</code>，所以两个函数都可以在同一时间用 <code>boost::shared_lock</code> 类型的 <strong>非独占锁</strong> 访问它。</p>
<p><code>fill()</code> 函数需要用一个<code>boost::unique_lock</code>类型的独占锁，因为它需要向<code>random_numbers</code>插入新的随机数，在<code>lock</code>显示的调用<code>unlock()</code>释放互斥量后，<code>fill()</code>又等待1秒，保证了容器<code>random_numbers</code>中至少存在一个随机数可以被<code>print()</code>和<code>count()</code>访问。<strong>对应地，</strong> 这两个函数在 for 循环的开始调用了 <code>wait(1)</code>。 </p>
<h4 id="条件变量-condition-variable"><a href="#条件变量-condition-variable" class="headerlink" title="条件变量 condition_variable"></a>条件变量 condition_variable</h4><p>条件变量，可以同步那些独立的线程，使数组的每个元素都被不同的线程立即添加到 <code>number_randoms</code>中。</p>
<p><strong>条件变量的使用总是和互斥体及共享资源联系在一起的。</strong> 线程首先锁住互斥体，然后检验共享资源的状态是否处于可使用的状态。如果不是，那么线程就要等待条件变量。要指向这样的操作就必须在等待的时候将互斥体解锁，以便其他线程可以访问共享资源并改变其状态。它还得保证从等到得线程返回时互斥体是被上锁得。当另一个线程改变了共享资源的状态时，它就要 <strong>通知</strong> 正在等待 <strong>条件变量</strong> 得线程，并将之返回等待的线程。</p>
<p><br/></p>
<h5 id="例子1"><a href="#例子1" class="headerlink" title="例子1"></a>例子1</h5><p>对上面的程序进行改进，为确保正确地处理随机数，需要一个 <strong>允许检查多个线程</strong> 之间 <strong>特定条件</strong> 的 <strong>条件变量</strong> 来 <strong>同步</strong> 每个独立的线程。删除了<code>wait()</code> 和 <code>count()</code>。线程不用在每个循环迭代中等待一秒，而是尽可能快地执行：</p>
<p><a href="http://zh.highscore.de/cpp/boost/" target="_blank" rel="noopener">来源</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; </span></span></span><br><span class="line"></span><br><span class="line">boost::mutex mutex;</span><br><span class="line">boost::condition_variable_any cond;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; random_numbers;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::srand(<span class="keyword">static_cast</span>&lt;<span class="keyword">unsigned</span> <span class="keyword">int</span>&gt;(<span class="built_in">std</span>::time(<span class="number">0</span>)));</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    boost::unique_lock&lt;boost::mutex&gt; lock(mutex);</span><br><span class="line">    random_numbers.push_back(<span class="built_in">std</span>::rand());</span><br><span class="line">    cond.notify_all();</span><br><span class="line">    cond.wait(mutex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="keyword">size_t</span> next_size = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    boost::unique_lock&lt;boost::mutex&gt; lock(mutex);</span><br><span class="line">    <span class="keyword">while</span> (random_numbers.size() != next_size)</span><br><span class="line">      cond.wait(mutex);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; random_numbers.back() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    ++next_size;</span><br><span class="line">    cond.notify_all();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  boost::<span class="function">thread <span class="title">t1</span><span class="params">(fill)</span></span>;</span><br><span class="line">  boost::<span class="function">thread <span class="title">t2</span><span class="params">(print)</span></span>;</span><br><span class="line">  t1.join();</span><br><span class="line">  t2.join();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序运行流程说明：</p>
<p>从<code>main()</code>开始，两个线程<code>t1(fill)</code>和<code>t2(print)</code>，虽然是多线成，但其实两者还是存在 <strong>启动</strong> 执行的先后顺序，<code>t1</code>会比<code>t2</code>先启动一会儿，但这不是问题，现在先 <strong>假设</strong> <code>t1</code>线程先启动（t1启动后t2立马启动）。进入<code>fill()</code>函数，<code>std::srand</code>生成随机数，然后进入循环，在对<code>random_numbers</code>操作前使用<code>boost::unique_lock</code>进行加锁，保证下面<code>push_bak()</code>时不会有其他线程同时操作这个数组引起冲突，等到<code>push_back()</code>结束后，条件变量<code>cond</code>通知其他等待该线程的线程的可以继续运行，然后自己进入<code>wait()</code>状态。</p>
<p>现在看<code>t1</code>运行的时候，<code>t2</code>发生了什么？<code>t2</code>进入<code>print()</code>函数，进入循环执行到<code>while(random_numbers.size() != next_size)</code>时，这时可能<code>t1</code>线程中还没有运行到将随机数<code>push_back</code>到<code>random_numbers</code>这个操作，所以<code>random_numbers.size()</code>不等于<code>next_size</code>，进而进入<code>cond.wait(mutex)</code>等待状态，等到<code>t1</code>运行到<code>cond.notify_all()</code>时才会被唤醒，进而释放互斥量<code>mutex</code>，继续运行到<code>t2</code>线程的<code>cond.notify_all()</code>以通知<code>t1</code>线程，然后循环到<code>while(random_numbers.size() != next_size)</code>发现满足，继续进入<code>wait</code>状态。</p>
<p><code>t1</code>线程此时在<code>wait()</code>状态，收到<code>t2</code>线程的<code>notify_all()</code>后程序才继续运行，然后以此往复，直到三次循环结束。</p>
<p><br/></p>
<h5 id="例子2"><a href="#例子2" class="headerlink" title="例子2"></a>例子2</h5><p><a href="https://segmentfault.com/a/1190000006679917" target="_blank" rel="noopener">来源</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mutex;</span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> data;</span><br><span class="line"><span class="keyword">bool</span> ready = <span class="literal">false</span>;  <span class="comment">// 条件</span></span><br><span class="line"><span class="keyword">bool</span> processed = <span class="literal">false</span>;  <span class="comment">// 条件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Worker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待主线程发送数据。</span></span><br><span class="line">  cv.wait(lock, [] &#123; <span class="keyword">return</span> ready; &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待后，继续拥有锁。</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"工作线程正在处理数据..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="comment">// 睡眠一秒以模拟数据处理。</span></span><br><span class="line">  <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">  data += <span class="string">" 已处理"</span>;</span><br><span class="line">  <span class="comment">// 把数据发回主线程。</span></span><br><span class="line">  processed = <span class="literal">true</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"工作线程通知数据已经处理完毕。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通知前，手动解锁以防正在等待的线程被唤醒后又立即被阻塞。</span></span><br><span class="line">  lock.unlock();</span><br><span class="line"></span><br><span class="line">  cv.notify_one();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">thread <span class="title">worker</span><span class="params">(Worker)</span></span>;  <span class="comment">// 定义工作线程</span></span><br><span class="line">  <span class="comment">// 把数据发送给工作线程。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程正在准备数据..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 睡眠一秒以模拟数据准备。</span></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    data = <span class="string">"样本数据"</span>;</span><br><span class="line">    ready = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"主线程通知数据已经准备完毕。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  cv.notify_one();  <span class="comment">// 通知工作线程</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待工作线程处理数据。</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(mutex);</span><br><span class="line">    cv.wait(lock, [] &#123; <span class="keyword">return</span> processed; &#125;); <span class="comment">//主线程进入等待状态</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"回到主线程，数据 = "</span> &lt;&lt; data &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  worker.join();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出效果:</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191115113144.png" width="300"/></p>
<p>程序运行流程说明：</p>
<p>条件变量被通知后，挂起的线程就被唤醒，但是唤醒也有可能是假唤醒，或者是因为超时等异常情况，所以被唤醒的线程仍要检查条件是否满足，所以 <code>wait</code> 是放在条件循环里面。<code>cv.wait(lock, [] { return ready; });</code> 相当于：<code>while (!ready) { cv.wait(lock); }</code>。</p>
<p><br/></p>
<h5 id="例子3"><a href="#例子3" class="headerlink" title="例子3"></a>例子3</h5><p><a href="http://stlchina.huhoo.net/twiki/bin/view.pl/Main/BoostThread" target="_blank" rel="noopener">来源</a></p>
<p><strong>目的：</strong> 有两个线程被创建，一个在buffer中放入100个整数，另一个将它们从buffer中取出。这个有界的缓存一次只能存放10个整数，所以这两个线程必须周期性的等待另一个线程，函数put和get使用条件变量来保证线程等待完成操作所必须的状态。</p>
<blockquote>
<p>说明： 原始程序感觉是存在问题的，并没有达到预期的效果，所以进行了修改</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/mutex.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/condition.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> BUF_SIZE = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ITERS = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">boost::mutex io_mutex;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">buffer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> boost::mutex::scoped_lock scoped_lock; <span class="comment">// 定义一个 区域锁</span></span><br><span class="line"></span><br><span class="line">  buffer(): p(<span class="number">0</span>), c(<span class="number">0</span>), full(<span class="number">0</span>)  <span class="comment">// 列表初始化</span></span><br><span class="line">  &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">scoped_lock <span class="title">lock</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (full &gt;= BUF_SIZE)</span><br><span class="line">    &#123;	</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="comment">//scoped_lock  区域锁，只在作用内有效，离开作用域自动释放锁，传递参数是锁</span></span><br><span class="line">        boost::mutex::<span class="function">scoped_lock <span class="title">lock</span><span class="params">(io_mutex)</span></span>;  </span><br><span class="line">        <span class="comment">// 目的是防止多个线程抢占这个 cout 造成混乱。</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Buffer is full. Waiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cond.notify_one();  <span class="comment">// 通知线程</span></span><br><span class="line">      <span class="comment">// 将通知线程放在这里目的就是当BUFFER满了以后，告诉get()函数应该来取出数据了</span></span><br><span class="line">      <span class="keyword">while</span> (full == BUF_SIZE)  <span class="comment">// 如果buffer 已经满了</span></span><br><span class="line">        cond.wait(lock);  <span class="comment">// 互斥量加锁，等待信号唤醒</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 buffer 没有满，则往里添加数据</span></span><br><span class="line">    buf[p] = m;</span><br><span class="line">    &#123;  <span class="comment">//局部作用域是一对大括号包围的区域</span></span><br><span class="line">      boost::mutex::<span class="function">scoped_lock <span class="title">lock</span><span class="params">(io_mutex)</span></span>; </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"sending: "</span> &lt;&lt; m &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125; <span class="comment">// 离开这个作用域，自动释放区域互斥锁</span></span><br><span class="line">    p = (p + <span class="number">1</span>) % BUF_SIZE;</span><br><span class="line">    ++full;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">scoped_lock <span class="title">lk</span><span class="params">(mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (full == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      &#123;</span><br><span class="line">        boost::mutex::<span class="function">scoped_lock <span class="title">lock</span><span class="params">(io_mutex)</span></span>;  </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Buffer is empty. Waiting..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      cond.notify_one();  <span class="comment">// BUFFER空了之后，告诉put()函数应该继续填充数据了</span></span><br><span class="line">      <span class="keyword">while</span> (full == <span class="number">0</span>)</span><br><span class="line">        cond.wait(lk);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = buf[c];</span><br><span class="line">    c = (c + <span class="number">1</span>) % BUF_SIZE;</span><br><span class="line">    --full;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  boost::mutex mutex;  <span class="comment">// 互斥体</span></span><br><span class="line">  boost::condition cond;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> p, c, full;</span><br><span class="line">  <span class="keyword">int</span> buf[BUF_SIZE]; <span class="comment">// BUF_SIZE = 10</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">buffer buf;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt;= ITERS; ++n) <span class="comment">// 之所以是 &lt;= ，是为了让 put 函数所在的线程再一次检测BUFFER是否已满，若满则唤醒 get() 函数中的等待线程，读取缓存中的数据</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//&#123; </span></span><br><span class="line">    <span class="comment">//	boost::mutex::scoped_lock lock(io_mutex); </span></span><br><span class="line">    <span class="comment">//	std::cout &lt;&lt; "sending: "&lt;&lt; n &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//	</span></span><br><span class="line">    <span class="comment">//&#125; </span></span><br><span class="line">    buf.put(n);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; ITERS; ++x) <span class="comment">//ITERS = 100</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> n = buf.get();</span><br><span class="line">    &#123;</span><br><span class="line">      boost::mutex::<span class="function">scoped_lock <span class="title">lock</span><span class="params">(io_mutex)</span></span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"received: "</span>&lt;&lt; n &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  boost::<span class="function">thread <span class="title">thrd1</span><span class="params">(&amp;reader)</span></span>;</span><br><span class="line">  boost::<span class="function">thread <span class="title">thrd2</span><span class="params">(&amp;writer)</span></span>;</span><br><span class="line">  thrd1.join();</span><br><span class="line">  thrd2.join();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后效果（部分截图）：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191115114834.png" width="300"/></p>
<p><br/></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191115114848.png" width="300"/></p>
<h3 id="线程本地存储（TLS）"><a href="#线程本地存储（TLS）" class="headerlink" title="线程本地存储（TLS）"></a>线程本地存储（TLS）</h3><p><a href="http://stlchina.huhoo.net/twiki/bin/view.pl/Main/BoostThread" target="_blank" rel="noopener">来源</a></p>
<p>线程本地存储（TLS）是一个只能由一个线程访问的专门的存储区域，TLS变量是一个只对某个特定线程而非整个程序可见的全局变量。</p>
<p>Boost线程库提供了智能指针<code>boost::thread_specific_ptr</code>来访问本地存储线程。每一个线程第一次使用这个智能指针的实例时，它的初值是NULL，所以必须要先检查这个它的只是否为空，并且为它赋值。Boost线程库保证本地存储线程中保存的数据会在线程结束后被清除。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/mutex.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread/tss.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">boost::mutex io_mutex;</span><br><span class="line">boost::thread_specific_ptr&lt;<span class="keyword">int</span>&gt; ptr;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">count</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  count(<span class="keyword">int</span> id) : id(id) &#123; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr.get() == <span class="number">0</span>)</span><br><span class="line">      ptr.reset(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">      (*ptr)++;</span><br><span class="line">      boost::mutex::<span class="function">scoped_lock <span class="title">lock</span><span class="params">(io_mutex)</span></span>;</span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; id &lt;&lt; <span class="string">": "</span> &lt;&lt; *ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> id;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  boost::<span class="function">thread <span class="title">thrd1</span><span class="params">(count(<span class="number">1</span>))</span></span>;</span><br><span class="line">  boost::<span class="function">thread <span class="title">thrd2</span><span class="params">(count(<span class="number">2</span>))</span></span>;</span><br><span class="line">  thrd1.join();</span><br><span class="line">  thrd2.join();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了两个线程来初始化本地存储线程，并有10次循环，每一次都会增加智能指针指向的值，并将其输出到<code>std::cout</code>上（由于<code>std::cout</code>是一个共享资源，所以通过互斥体进行同步）。<code>main</code>线程等待这两个线程结束后就退出。从这个例子输出可以明白的看出每个线程都处理属于自己的数据实例，尽管它们都是使用同一个<code>boost::thread_specific_ptr</code>。</p>
<p>输出：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191115144819.png" width="300"/></p>
<p>显然虽然使用的是全局的<code>boost::thread_specific_ptr</code>智能指针，但是各线程之间的值互不干扰。</p>
<h3 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h3><ol>
<li>关于 <code>mute</code> 和 <code>lock</code></li>
</ol>
<p><code>mutex</code>是一个类，用它可以生成相应的互斥体，然后呢，我们就可以把互斥体加入到我们的线程中去啦。互斥体本身里有<code>lock</code>与<code>unlock</code>的实现， 不过是私有的，只能通过它的友元函数来调用，我们没有办法直接用。想一个简单方法：所以用<code>lock模板类</code>对它进行了封装，用<code>lock模板类</code>生成的对象相进行<code>lock</code>与<code>unlock</code>。对于<code>mutex</code>的使用，多个线程应该对应同一个<code>mutex</code>对象。</p>
<p>对于<code>lock模板类</code>（例如：<code>boost::unique_lock()，boost::shared_lock()</code>）来说，它把对对应类型（指的是<code>muetx类</code>的类型）<code>lock</code>与<code>unlock</code>操作放入到了它的构造与析构函数里了，这样可以自动完成它的使命了。</p>
<ol>
<li>关于<code>boost::condition_variable</code></li>
</ol>
<p>对于<code>notify_one</code>和<code>notify_all</code>的作用就是：把一个线程对的共享资源unlock， <code>notify_one</code>启用一个线程， <code>notify_all</code>激活所有线程。</p>
<p>对于<code>wait</code>，就是本线程得到互斥体后，本线程就给其加锁，然后在后续的操作中发现条件不满足时再把锁打开让给其他的线程，而自己进行阻塞，等待<code>notify</code>，等收到之后再抢得互斥体得<code>lock</code>，继续后续的操作。</p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><p><a href="http://stlchina.huhoo.net/twiki/bin/view.pl/Main/BoostThread" target="_blank" rel="noopener">C++ Boost Thread 编程指南</a></p>
<p><a href="http://zh.highscore.de/cpp/boost/" target="_blank" rel="noopener">The Boost C++ Libraries</a></p>
<p><a href="https://www.runoob.com/w3cnote/cpp-multithread-demo.html" target="_blank" rel="noopener">菜鸟教程- C++ 多线程</a></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>Boost</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA_03理解线程束的执行</title>
    <url>/2019/11/12/CUDA_03%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%9D%9F%E7%9A%84%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>CUDA执行的实质是线程束的执行。</p>
<a id="more"></a>
<p><a href="https://face2ai.com/cuda-f-3-2-%e7%90%86%e8%a7%a3%e7%ba%bf%e7%a8%8b%e6%9d%9f%e6%89%a7%e8%a1%8c%e7%9a%84%e6%9c%ac%e8%b4%a8-p1/" target="_blank" rel="noopener">来源：理解线程束执行的本质(Part I)</a></p>
<p>因为硬件根本不知道每个块谁是谁，也不知道先后顺序，硬件(SM)只知道按照机器码跑，而给他什么，先后顺序，这个就是硬件功能设计的直接体现了。<br>从外表来看，CUDA执行所有的线程，并行的，没有先后次序的，但实际上硬件资源是有限的，不可能同时执行百万个线程，所以从硬件角度来看，物理层面上执行的也只是线程的一部分，而每次执行的这一部分，就是我们前面提到的 <strong>线程束</strong> 。</p>
<h2 id="理解CUDA中的线程束"><a href="#理解CUDA中的线程束" class="headerlink" title="理解CUDA中的线程束"></a>理解CUDA中的线程束</h2><p><a href="https://songpo.wang/" target="_blank" rel="noopener">来源</a></p>
<p>线程束是SM中基本的执行单元， 每个线程束包含了 32 个线程。所以，当我们定义的一个block中含有的线程数量不是 32 的整数倍时，那么该 block 会被分配给 n+1 个线程束， 其中 n 表示的是 线程数量与32 的整数倍，多出来的线程束会有部分线程不活跃，但因为线程束是基本执行单元，所以这个额外的线程束依旧会消耗和其他线程束相同的资源。</p>
<blockquote>
<p>例如： 有一个一维的线程块包含有80个线程，那么映射到 <strong>硬件</strong> 上，系统就会为这个线程块分配 <strong>3个连续</strong> 的线程束，使总共96个硬件线程去支持80个软件线程。其中 <strong>第3个线程束</strong> 中有 <strong>16个线程不活跃</strong>，但是仍然 <strong>消耗</strong> 这系统资源，被浪费掉了。</p>
</blockquote>
<p>每个线程束中的线程按照 <strong>单指令多线程</strong> 的方式执行，也就是说同属于一个线程束的线程均会执行 <strong>同一个指令</strong>。</p>
<h2 id="线程束-warp-和线程块"><a href="#线程束-warp-和线程块" class="headerlink" title="线程束(warp)和线程块"></a>线程束(warp)和线程块</h2><p>执行过程：</p>
<ol>
<li><p>一个网格被启动（网格被启动，等价于一个内核被启动，每个内核对应于自己的网格），网格中包含线程块；</p>
</li>
<li><p>线程块被分配到某一个SM上；</p>
</li>
<li><p>SM上的线程块将分为多个线程束，每个线程束一般是 32 个线程；</p>
</li>
<li><p>在一个线程束中，所有线程按照单指令多线程SIMT的方式执行，每一步执行相同的指令，但是处理的数据是私有数据。</p>
</li>
</ol>
<p>下图，对应 <strong>逻辑</strong> 、<strong>实际</strong> 和 <strong>硬件</strong>：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191112152601.png"/></p>
<p>在块中，每个线程有唯一的编号， threadIdx;</p>
<p>在网格中，每个线程块也有唯一的编号，blockIdx;</p>
<p>所以每个线程就有在网格中的唯一编号。</p>
<p>因为线程块是逻辑层，被定义了一个三维结构，而线程束是硬件层，在硬件结构中是一维排列的，所以它们之间的对应关系就是：</p>
<ol>
<li>对于一个二维的线程块，映射到一维的物理布局上是：</li>
</ol>
<script type="math/tex; mode=display">\text{threadIdx.y} \times \text{blockDim.y} + \text{threadIdx.x}</script><ol>
<li>对于一个三维的线程块，映射到一维的物理布局上是：</li>
</ol>
<script type="math/tex; mode=display">\text{threadIdx.z} \times \text{blockDim.y} \times \text{blockDim.x} + \text{threadIdx.y} \times \text{blockDim.x} + \text{threadIdx.x}</script><h2 id="线程束分化"><a href="#线程束分化" class="headerlink" title="线程束分化"></a>线程束分化</h2><p>线程束是硬件层面的线程集合，线程块是逻辑层面的线程集合。线程束被执行的时候会被分配相同的指令，但是是处理各自私有的数据。如果一个线程束中的不同线程包含不同的控制条件，那么当我们执行到这个控制条件时就会面临不同的选择，同一个线程束中的线程，执行不同的指令就叫做 <strong>线程束的分化。</strong></p>
<p>GPU相较于CPU不时候大量计算逻辑复杂的任务，因为CPU在进行流水线作业时会采用 <strong>分支预测</strong> 的技术（之前有做个测试，如果对一个很大的随机数组在进行if…else逻辑判断前先进行排序会比未排序直接进行逻辑判断速度慢很多）,而GPU这方面就不擅长。</p>
<p>为了解决GPU中 <code>线程束中的所有线程执行相同的指令</code> 和 <code>线程束又是分化的</code> 之间的矛盾，只能让那些不成立的指令进行等待。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分水果，你不爱吃，那你就只能看着别人吃，等大家都吃完了，再进行下一轮（也就是下一个指令）</span><br></pre></td></tr></table></figure>
<p>示意图：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191112162353.png"/></p>
<p>线程束分化会产生严重的性能下降。条件分支越多，并行性削弱越严重。所以应该避免同一个线程束内的线程分化，控制线程块中线程分配到线程束是有规律的而不是随机的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//低效的分支：</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">mathKernel1</span><span class="params">(<span class="keyword">float</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tid = blockIdx.x* blockDim.x + threadIdx.x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (tid % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">100.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">200.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c[tid] = a + b;</span><br><span class="line">&#125;<span class="comment">//奇数偶数分化，每次间隔都要分化一次，分化严重</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调整</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">mathKernel2</span><span class="params">(<span class="keyword">float</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tid = blockIdx.x* blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((tid/warpSize) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">100.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">200.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c[tid] = a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一个线程束内的线程编号tid从0到31，tid/warpSize都等于0，那么就都执行if语句。</span></span><br><span class="line"><span class="comment">//第二个线程束内的线程编号tid从32到63，tid/warpSize都等于1，执行else线程束内没有分支，效率较高。</span></span><br></pre></td></tr></table></figure>
<h2 id="延迟隐藏-效率的最大化"><a href="#延迟隐藏-效率的最大化" class="headerlink" title="延迟隐藏-效率的最大化"></a>延迟隐藏-效率的最大化</h2><p>效率的最大化就是要最大化硬件，尤其是计算部分的硬件跑满，都不闲着的情况下利用率是最高的，即最大化功能单元的利用率，而 <strong>利用率</strong> 和 <strong>常驻线程束</strong> 直接相关。硬件中的线程调度器负责线程束的调度，当每时每刻都有可用的线程束供其调度时，这时候可以达到计算资源的完全利用，<strong>依次来保证通过其他常驻线程束来发布其他指令，并可以隐藏每个指令的延迟。</strong></p>
<p>对于指令的延迟，主要分为两种：</p>
<ol>
<li><p>算数指令延迟：从一个算数操作开始，到产生结果之间的时间，这个时间段内只有某些计算单元处于工作状态，而其他逻辑计算单元处于空闲，10 ~ 20 个时钟周期。</p>
</li>
<li><p>内存指令延迟： 当产生内存访问的时候，计算单元要等数据从内存拿到寄存器，这个周期是非常长的， 400 ~ 800 个时钟周期。</p>
</li>
</ol>
<p><strong>提高并行的两种方式：</strong></p>
<ol>
<li><p>指令集并行（ILP）：一个线程中有很多独立的指令</p>
</li>
<li><p>线程级并行（TLP）：很多并发的符合条件的线程</p>
</li>
</ol>
<p>指令隐藏的关键目的是使用全部的计算资源，而内存读取的延迟隐藏是为了使用全部的内存带宽</p>
<p>内核使用寄存器的数量会影响SM内线程束的数量，<strong>通过调整线程块内线程的多少来提高占用率</strong></p>
<ul>
<li><p>小的线程块： 每个线程块中线程太少，会在所有资源没用完就达到了线程束的最大要求；</p>
</li>
<li><p>大的线程块： 每个线程块中太多线程，会导致每个SM中每个线程可用的硬件资源较少。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA_02执行模型概述</title>
    <url>/2019/11/12/CUDA_02%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>GPU架构学习</p>
<a id="more"></a>
<p><a href="https://face2ai.com/cuda-f-3-1-cuda%e6%89%a7%e8%a1%8c%e6%a8%a1%e5%9e%8b%e6%a6%82%e8%bf%b0/" target="_blank" rel="noopener">参考1: CUDA执行模型概述</a></p>
<p><a href="https://www.cnblogs.com/timlly/p/11471507.html#%E5%9B%9Bgpu%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">参考2: 深入GPU硬件架构及运行机制</a></p>
<h2 id="CUDA-编程模型和硬件模型对应"><a href="#CUDA-编程模型和硬件模型对应" class="headerlink" title="CUDA 编程模型和硬件模型对应"></a>CUDA 编程模型和硬件模型对应</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191112104551.png"/></p>
<p>线程块中通过共享内存和寄存器相互通信协调，寄存器和共享内存的分配可以严重影响性能。</p>
<p>因为SM有限，虽然在编程模型看所有线程都是并行执行，但是在微观上看，所有线程也是分批次在物理层面的机器上执行，线程块(block)里不同的线程可能进度都不一样，但是同一个线程束的线程拥有相同的进度。</p>
<p>并行就会引起竞争，多线程以未定义的顺序访问同一个数据，就导致了不可预测的行为，CUDA只提供了一种块内（块内线程间）同步的方式，块之间没办法同步！</p>
<p>同一个SM上可以有不止一个常驻的线程束，有些在执行，有些在等待，他们之间状态的转换是不需要开销的。<strong>每个SM</strong> 都将 <strong>分配给它的线程块</strong> 划分到包含32个线程（我的理解，这32 个线程就是对应到SM硬件图中的core）的线程束中，然后在可用的硬件资源上调度执行。</p>
<h2 id="Nvidia-Fermi架构"><a href="#Nvidia-Fermi架构" class="headerlink" title="Nvidia Fermi架构"></a>Nvidia Fermi架构</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/7FF8E397A2433A1D7678F72C97558C6A.jpg"/></p>
<p>解释：</p>
<ul>
<li><p>Fermi架构</p>
<ol>
<li><p><strong>L2 Cache:</strong>  768 KB 的二级缓存，被所有SM共享；</p>
</li>
<li><p><strong>DRAM:</strong> 6 个 384-bits 的GDRR5内存接口；</p>
</li>
<li><p><strong>GigaThread引擎：</strong> 全局调度器，分配线程块到SM线程束调度器上；</p>
</li>
<li><p><strong>SM(流多处理器器Stream Multiprocessor):</strong> 16个SM，每个SM支持数百个线程并发执行，当一个核函数的网格被启动的时候，多个block会被同时分配给可用的SM上执行。</p>
</li>
</ol>
</li>
<li><p>SM</p>
<ol>
<li><p><strong>2 个 Warp(线程束):</strong> 采用单指令多线程 SIMT 架构管理执行线程，每个线程束中包括 16个Core， Warp编排器（Warp Scheduler），分发单元（Dispatch Unit）；</p>
</li>
<li><p><strong>Warp编排器(Warp Scheduler)</strong>， 线程束调度器，</p>
</li>
<li><p><strong>分发单元(Dispatch Unit)</strong>， 指令调度（分配）单元，存储两个线程束要执行的命令，</p>
</li>
<li><p><strong>寄存器文件(Register File)</strong></p>
</li>
<li><p><strong>16组加载存储单元（LD/ST）</strong></p>
</li>
<li><p><strong>4 个特殊函数单元（SFU）</strong> 执行固有指令，如正弦、余弦、平方根和差值</p>
</li>
<li><p><strong>共享内存/一级缓存</strong></p>
</li>
<li><p><strong>CUDA核心</strong></p>
</li>
</ol>
</li>
<li><p>CUDA核心</p>
<ol>
<li><p><strong>一个 FP Unit:</strong> 浮点数运算单元FPU；</p>
</li>
<li><p><strong>一个 INT Unit:</strong> 全流水线的整数算数逻辑单元 ALU；</p>
</li>
</ol>
</li>
</ul>
<p><strong>SM 的中文对照：</strong></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191113095019.png" width="400"/></p>
<h2 id="Kepler-架构"><a href="#Kepler-架构" class="headerlink" title="Kepler 架构"></a>Kepler 架构</h2><p>是Fermi的后代</p>
<pre><code>- 强化了SM

- 动态并行

- Hyper-Q 技术
</code></pre><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191112145014.png"/></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191112145117.png"/></p>
<p>SMX是改进的架构，支持动态创建渲染线程，以降低延迟。</p>
<p>Hyper-Q技术主要是CPU和GPU之间的同步硬件连接，以确保CPU在GPU执行的同事做更多的工作。Fermi架构下CPU控制GPU只有一个队列，Kepler架构下可以通过Hyper-Q技术实现多个队列：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191112150046.png"/></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>想要优化速度，先要学好使用使用性能优化工具：</p>
<ul>
<li><p>nvvp</p>
</li>
<li><p>nvprof</p>
</li>
</ul>
<p>限制内核性能的主要包括但不限于y一下因素：</p>
<ul>
<li><p>存储宽带</p>
</li>
<li><p>计算资源</p>
</li>
<li><p>指令和内存延迟</p>
</li>
</ul>
]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>Boost编译与配置</title>
    <url>/2019/11/11/Boost%E7%BC%96%E8%AF%91%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>Boost的下载安装与编译配置</p>
<a id="more"></a>
<p>配置boost时出现缺少“*.lib”文件解决（主要是Boost的安装和编译）</p>
<p><a href="https://www.cnblogs.com/bluedoctor/p/6236905.html" target="_blank" rel="noopener">参考</a></p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ol>
<li>从<a href="https://www.boost.org/users/download/" target="_blank" rel="noopener">官网</a>下载原始文件:</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105000.png"/></p>
<p>这里选择红色框中的文件进行下载</p>
<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><ol>
<li>之后将文件解压，放到任意目录，这里将文件放在C盘根目录下：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105202.png"/></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ol>
<li>进入文件夹，先运行<code>bootstrap.bat</code></li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105340.png"/></p>
<p>运行结束后会生成 <code>b2.exe</code>可执行文件。</p>
<ol>
<li>结束之后开始菜单找到 <code>Visual Studio 2015</code>文件夹，运行目录下面的 <code>VS2015 X86 本机工具命令提示符</code>：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105440.png" height="300"/></p>
<ol>
<li>在命令窗口中定位到刚才解压的<code>boost</code>文件夹下，运行如下命令：</li>
</ol>
<p><code>b2 -j4 --debug-symbols=on --build-type=complete toolset=msvc-14.0 threading=multi runtime-link=shared address-model=32</code></p>
<p>需要等待一段时间，即可生成动态链接库</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li>在VS2015中进行配置</li>
</ol>
<p>在项目属性中进行设置，右键<code>项目</code>—&gt;<code>属性</code>—&gt;<code>配置属性</code></p>
<p>a. <code>VC++目录</code>—&gt;<code>库目录</code> —&gt; 添加路径：<code>C:\boost_1_71_0\stage\lib</code></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111110710.png"/></p>
<p>之前就是这里没有添加动态链接库所以发生了如下报错：</p>
<p><code>LNK1104    无法打开文件 libboost_thread-vc140-mt-gd-x32-1_71.lib</code></p>
<p>b. <code>C/C++</code> —&gt; <code>常规</code> —&gt; <code>附加包含目录</code>  —&gt; 添加路径： <code>C:\boost_1_71_0</code></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111110923.png"/></p>
<blockquote>
<p>注意： 一定要在项目中添加了 <code>C++</code> 文件之后，项目属性设置中才会出现 <code>C/C++</code>的选项。</p>
</blockquote>
<p>接下来程序就可以正常运行了。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>对比程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	boost::this_thread::sleep(boost::posix_time::seconds(seconds));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		wait(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	boost::<span class="function">thread <span class="title">t</span><span class="params">(threadFun)</span></span>;  <span class="comment">// 上面的那个函数</span></span><br><span class="line">	t.join();  <span class="comment">// join() 方法是一个阻塞调用：它可以暂停当前线程，直到调用 join() 的线程运行结束。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>Boost</tag>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>20191109记录</title>
    <url>/2019/11/09/20191109%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>C++句柄、const、Boost配置、复制构造函数、列表初始化</p>
<a id="more"></a>
<h2 id="C-句柄类"><a href="#C-句柄类" class="headerlink" title="C++ 句柄类"></a>C++ 句柄类</h2><p>在容器中保存有继承关系的对象时，如果定义成保存基类对象，则派生类将被切割，如果定义成保存派生类对象，则保存基类对象又成问题（基类对象将被强制转换成派生类对象，而派生类中定义的成员未被初始化）</p>
<blockquote>
<p>注：  上面这句话还是存在疑问，关键在于容器是如何保存对象的？对基类和派生类的影<br>响具体又是什么？</p>
</blockquote>
<p><strong>所以唯一可行的选择是容器中保存对象的指针，但是需要用户管理对象和指针。C++中一个通用的技术是包装类（cover）和句柄类(handle)，使用句柄类存储和管理类指针。</strong></p>
<p>句柄类大体上完成两方面的工作：</p>
<ol>
<li><p>管理指针，这与智能指针的功能类似。</p>
</li>
<li><p>实现多态，利用动态绑定，使得指针既可以指向基类，也可以指向派生类。</p>
</li>
</ol>
<blockquote>
<p>具体的实现呢？稍后补上</p>
</blockquote>
<p><a href="https://www.cnblogs.com/zhoudayang/p/5536630.html" target="_blank" rel="noopener">参考</a></p>
<h2 id="C-构拷贝（复制）造函数"><a href="#C-构拷贝（复制）造函数" class="headerlink" title="C++构拷贝（复制）造函数"></a>C++构拷贝（复制）造函数</h2><p>声明一个类时拷贝构造函数似乎很常见，但总是不太清楚其作用是什么？为什么需要拷贝构造函数？什么情况下需要使用？</p>
<p><a href="https://www.runoob.com/cplusplus/cpp-copy-constructor.html" target="_blank" rel="noopener">参考</a></p>
<p><strong>拷贝构造函数</strong> 是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象，通常用于：</p>
<ul>
<li><p>通过使用另一个同类型的对象来初始化新创建的对象；</p>
</li>
<li><p>复制对象把它作为参数传递给函数（以值传递的方式传入函数参数）；</p>
</li>
<li><p>复制对象，并从函数返回这个对象。  </p>
</li>
</ul>
<p>拷贝构造函数接受一个以引用方式传入的当前类的对象作为参数，这个参数是源对象的别名。</p>
<p>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果 <strong>类带有指针变量，并有动态内存分配，</strong> 则它 <strong>必须</strong> 有一个拷贝构造函数。</p>
<p>常见形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">classname (<span class="keyword">const</span> classname &amp;obj)&#123;</span><br><span class="line">    <span class="comment">//构造函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看一个例子，对比有复制构造函数和没有复制构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数声明</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	Line(<span class="keyword">int</span> len); <span class="comment">//简单的构造函数</span></span><br><span class="line">	<span class="comment">//Line(const Line &amp;obj); // 拷贝构造函数</span></span><br><span class="line">	~Line(); <span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">int</span> len) &#123;  <span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//为指针分配内存</span></span><br><span class="line">	ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*ptr = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Line::Line(const Line &amp;obj) &#123;  // 拷贝构造函数</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; "调用拷贝构造函数并为指针 ptr 分配内存" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//	ptr = new int;</span></span><br><span class="line"><span class="comment">//	*ptr = *obj.ptr;  //拷贝值</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">Line::~Line(<span class="keyword">void</span>) &#123; <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"释放内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Line::getLength(<span class="keyword">void</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Line obj)</span> </span>&#123; <span class="comment">//注意这里对象是以值传递的方式传入函数参数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 大小： "</span> &lt;&lt; obj.getLength() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Line <span class="title">line</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	display(line);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先会有一个输出结果：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191110131651.png" width="150"/></p>
<p>可以看到函数尝试调用两次析构函数以释放内存，但是当调用第二次析构函数时出现下面的情况：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191110131919.png" width="300" /></p>
<p>最终导致程序报错，其原因主要由下图所示：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/FFA170BA5807AF4BE58389AE931B1A71.jpg"/></p>
<p>line作为变量传入到函数 display 中时，因为是浅拷贝所以 display 函数中的形参 obj 和 line 指向了相同的内存空间，而函数中的 obj 在执行完成后释放了形参指向的内存空间，但因为 line 和 obj指向相同内存，所以当程序结束尝试释放 line 指向的内存空间时发现并没有内存可以释放，这就导致了程序的错误，所以解决的办法就是使用拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">classname (<span class="keyword">const</span> classname &amp;obj)&#123;</span><br><span class="line">    <span class="comment">//构造函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看一个例子，对比有复制构造函数和没有复制构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数声明</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	Line(<span class="keyword">int</span> len); <span class="comment">//简单的构造函数</span></span><br><span class="line">	Line(<span class="keyword">const</span> Line &amp;obj); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	~Line(); <span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">int</span> len) &#123;  <span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//为指针分配内存</span></span><br><span class="line">	ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*ptr = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::Line(<span class="keyword">const</span> Line &amp;obj) &#123;  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数并为指针 ptr 分配内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*ptr = *obj.ptr;  <span class="comment">//拷贝值</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::~Line(<span class="keyword">void</span>) &#123; <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"释放内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Line::getLength(<span class="keyword">void</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Line obj)</span> </span>&#123;  <span class="comment">//注意这里对象是以值传递的方式传入函数参数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 大小： "</span> &lt;&lt; obj.getLength() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Line <span class="title">line</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	display(line);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数并为指针 ptr 分配内存</span><br><span class="line">line 大小 : 10</span><br><span class="line">释放内存</span><br><span class="line">释放内存</span><br></pre></td></tr></table></figure>
<p>可以看到成功调用了两次析构函数，一次是obj在 display中进行调用的， 另一次是程序结束 line 进行调用的，没有发生错误，安全退出，其结构如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/922622A538313F7B71563DBC99E76FCF.jpg"/></p>
<p>下面还有一个例子，看一下什么时候程序会调用拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	Line(<span class="keyword">int</span> len);             <span class="comment">// 简单的构造函数</span></span><br><span class="line">	Line(<span class="keyword">const</span> Line &amp;obj);      <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	~Line();                     <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 为指针分配内存</span></span><br><span class="line">	ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*ptr = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::Line(<span class="keyword">const</span> Line &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数并为指针 ptr 分配内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*ptr = *obj.ptr; <span class="comment">// 拷贝值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::~Line(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"释放内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Line::getLength(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Line obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"line 大小 : "</span> &lt;&lt; obj.getLength() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Line <span class="title">line1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"=========================="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Line line2 = line1; <span class="comment">// 这里也调用了拷贝构造函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"=========================="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	display(line1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"=========================="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	display(line2);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"=========================="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后输出：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191110141851.png" width="300"/></p>
<p>在对象进行复制时因为存在拷贝复制函数，所以发生了深层拷贝，最后在析构时依次析构 line1 和 line2。</p>
<h2 id="c-函数前面和后面-使用const-的作用："><a href="#c-函数前面和后面-使用const-的作用：" class="headerlink" title="c++ 函数前面和后面 使用const 的作用："></a>c++ 函数前面和后面 使用const 的作用：</h2><p><a href="https://blog.csdn.net/smf0504/article/details/52311207" target="_blank" rel="noopener">参考</a></p>
<p>前面使用const 表示返回值为const</p>
<p>后面加 const表示函数不可以修改class的成员</p>
<p>对应下面的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue2</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionConst</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    FunctionConst();</span><br><span class="line">    <span class="keyword">virtual</span> ~FunctionConst();</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue2</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FunctionConst::FunctionConst():value(<span class="number">100</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionConst::~FunctionConst() &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated destructor stub</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> FunctionConst::getValue()&#123;</span><br><span class="line">    <span class="keyword">return</span> value;<span class="comment">//返回值是 const, 返回值是指针时，防止函数调用表达式作为左值，使得指针的内容被修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> FunctionConst::getValue2() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">//此函数不能修改class FunctionConst的成员变量 value</span></span><br><span class="line">    value = <span class="number">15</span>;<span class="comment">//错误的, 因为函数后面加 const</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-赋值初始化和列表初始化"><a href="#C-赋值初始化和列表初始化" class="headerlink" title="C++ 赋值初始化和列表初始化"></a>C++ 赋值初始化和列表初始化</h2><p>类的构造函数在初始化成员变量时，主要有两种方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">CSomeClass::CSomeClass() </span><br><span class="line">&#123; </span><br><span class="line">   x=<span class="number">0</span>; </span><br><span class="line">   y=<span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"></span><br><span class="line">CSomeClass::CSomeClass() : x(<span class="number">0</span>), y(<span class="number">1</span>) </span><br><span class="line">&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式一我们可以称为赋值初始化，通过在函数体内进行赋值初始化，在所有数据成员被 <strong>分配内存空间后才进行的。</strong></p>
<p>方式二我们称为列表初始化，在冒号后使用初始化列表进行初始化，<strong>给数据成员分配内存空间时就进行初始化</strong></p>
<p><a href="https://blog.csdn.net/fengxinlinux/article/details/70146347" target="_blank" rel="noopener">具体</a></p>
<h2 id="配置boost时出现缺少“-lib”文件解决（主要是Boost的安装和编译）"><a href="#配置boost时出现缺少“-lib”文件解决（主要是Boost的安装和编译）" class="headerlink" title="配置boost时出现缺少“*.lib”文件解决（主要是Boost的安装和编译）"></a>配置boost时出现缺少“*.lib”文件解决（主要是Boost的安装和编译）</h2><p><a href="https://www.cnblogs.com/bluedoctor/p/6236905.html" target="_blank" rel="noopener">参考</a></p>
<p>主要纪录Boost的正确安装</p>
<ol>
<li>从<a href="https://www.boost.org/users/download/" target="_blank" rel="noopener">官网</a>下载原始文件:</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105000.png"/></p>
<p>这里选择红色框中的文件进行下载</p>
<ol>
<li>之后将文件解压，放到任意目录，这里将文件放在C盘根目录下：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105202.png"/></p>
<ol>
<li>进入文件夹，先运行<code>bootstrap.bat</code></li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105340.png"/></p>
<p>运行结束后会生成 <code>b2.exe</code>可执行文件。</p>
<ol>
<li>结束之后开始菜单找到 <code>Visual Studio 2015</code>文件夹，运行目录下面的 <code>VS2015 X86 本机工具命令提示符</code>：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105440.png" height="300"/></p>
<ol>
<li>在命令窗口中定位到刚才解压的<code>boost</code>文件夹下，运行如下命令：</li>
</ol>
<p><code>b2 -j4 --debug-symbols=on --build-type=complete toolset=msvc-14.0 threading=multi runtime-link=shared address-model=32</code></p>
<p>需要等待一段时间，即可生成动态链接库</p>
<ol>
<li>在VS2015中进行配置</li>
</ol>
<p>在项目属性中进行设置，右键<code>项目</code>—&gt;<code>属性</code>—&gt;<code>配置属性</code></p>
<p>a. <code>VC++目录</code>—&gt;<code>库目录</code> —&gt; 添加路径：<code>C:\boost_1_71_0\stage\lib</code></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111110710.png"/></p>
<p>之前就是这里没有添加动态链接库所以发生了如下报错：</p>
<p><code>LNK1104    无法打开文件 libboost_thread-vc140-mt-gd-x32-1_71.lib</code> </p>
<p>b. <code>C/C++</code> —&gt; <code>常规</code> —&gt; <code>附加包含目录</code>  —&gt; 添加路径： <code>C:\boost_1_71_0</code></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111110923.png"/></p>
<blockquote>
<p>注意： 一定要在项目中添加了 <code>C++</code> 文件之后，项目属性设置中才会出现 <code>C/C++</code>的选项。</p>
</blockquote>
<p>接下来程序就可以正常运行了。</p>
<p>对比程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	boost::this_thread::sleep(boost::posix_time::seconds(seconds));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		wait(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	boost::<span class="function">thread <span class="title">t</span><span class="params">(threadFun)</span></span>;  <span class="comment">// 上面的那个函数</span></span><br><span class="line">	t.join();  <span class="comment">// join() 方法是一个阻塞调用：它可以暂停当前线程，直到调用 join() 的线程运行结束。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA_01组织并行线程</title>
    <url>/2019/11/09/CUDA_01%E7%BB%84%E7%BB%87%E5%B9%B6%E8%A1%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>CUDA编程中最重要的一环就是如何让数据并行计算，要想实现较为高效的并行计算就需要在CUDA编程时手动为每个数据分配线程，这就涉及到如何在不同的grid 和 block 中计算出合适线程的id号。</p>
<a id="more"></a>
<h2 id="CUDA组织并行线程"><a href="#CUDA组织并行线程" class="headerlink" title="CUDA组织并行线程"></a>CUDA组织并行线程</h2><p><a href="https://face2ai.com/cuda-f-2-3-%e7%bb%84%e7%bb%87%e5%b9%b6%e8%a1%8c%e7%ba%bf%e7%a8%8b/" target="_blank" rel="noopener">文章参考</a></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>CUDA编程中最重要的一环就是如何让数据并行计算，要想实现较为高效的并行计算就需要在CUDA编程时手动为每个数据分配线程，这就涉及到如何在不同的grid 和 block 中计算出合适线程的id号。</p>
<p>回顾GPU中一个 kernel 的大致框架：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/b8b1bdfda485204b59c940daf0f2fc7.jpg"/></p>
<p>所在一般在编程时需要事先声明grid, block, thread的大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">4</span>,<span class="number">2</span>)</span></span>;  <span class="comment">// 声明一个 block 其中包含 4 行 2 列 = 8 个线程</span></span><br><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;  <span class="comment">// 声明一个 grid 其中包含 2 行 3 列 = 6 个block</span></span><br><span class="line"><span class="comment">// 所以总共可分配的线程数为： 8 * 6 = 48 个</span></span><br></pre></td></tr></table></figure>
<p>所以在得到一个block中一个线程的索引号（threadIdx）后，需要还需要根据 gridDim. gridIdx, blockDim, blockIdx 计算获得其全局的索引号。详细: <a href="https://blog.csdn.net/hujingshuang/article/details/53097222#commentBox" target="_blank" rel="noopener">grid、block、thread的关系及thread索引的计算</a></p>
<p>这边以简单的二维block为例介绍：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191108160350.png"/></p>
<p>计算方式就如图中所示。</p>
<p>因为CUDA 每一个线程执行相同的代码，就是异构计算中的多线程单指令， 如果每个不同的线程执行同样的代码，又处理同一组数据，CUDA常用的做法是让不同的线程对应不同的数据，也就是用线程的全局全局标号对应不同组的数据。因为无论时设备还是主机内存都是线性存在的，比如二维矩阵 $(8 \times 6)$， 存储在内存中可能就是如下结构：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191108164506.png"/></p>
<p>我们要做的管理就是：</p>
<ul>
<li><p>矩阵和块索引（计算线程的全局索引）；</p>
</li>
<li><p>计算矩阵中给定点的坐标 (ix, iy);</p>
</li>
<li><p>(ix, iy) 对应的线性内存的位置；</p>
</li>
</ul>
<p>线性位置的计算方式：</p>
<script type="math/tex; mode=display">idx = ix + iy \times nx</script><p>这样的分配方式就将数组矩阵中 (ix, iy) 位置处的数据分配到线程标号为 ix,iy 处去计算。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>随机生成一个 6 行 8列的数组，总共有 48 个数字，如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191108170505.png"/></p>
<p>实际内存是一维线性的，如下：</p>
<script type="math/tex; mode=display">[29.6 , ... , 22.16 , 26.49 , ... , 23.45 , 30.92 , ... , ...]</script><p>block 和 grid 的大小为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">blcok</span><span class="params">(<span class="number">4</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个二维block和 二维线程，即使用 2 x 3 个block ，每个 block中再开辟 4x 2 个线程， 则 2 x 3 x 4 x 2 = 48，然后将这48个数字分配进去，每个数字一个线程,就相当于每个线程进行一个数字的操作，进行的计算的并行化。</p>
<p>有如下形式：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/451431f889b05d3ae630d32f175a126.jpg"/></p>
<p>按照下面的方式打印索引：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">printThreadIndex</span><span class="params">(<span class="keyword">float</span> *A, <span class="keyword">const</span> <span class="keyword">int</span> nx, <span class="keyword">const</span> <span class="keyword">int</span> ny)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ix = threadIdx.x + blockIdx.x*blockDim.x;  </span><br><span class="line">	<span class="keyword">int</span> iy = threadIdx.y + blockIdx.y*blockDim.y;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> idx = iy * nx + ix; </span><br><span class="line"><span class="comment">//nx = 8, ny= 6 在进一步计算全局线程标号，是为了将这48个数据分别匹配到不同的线程中去</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread_id(%d,%d) block_id(%d,%d) coordinate(%d,%d)"</span></span><br><span class="line">		<span class="string">"global index %2d ival %2d\n"</span>, threadIdx.x, threadIdx.y,</span><br><span class="line">		blockIdx.x, blockIdx.y, ix, iy, idx, A[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dim3 blcok(4,2);</span></span><br><span class="line"><span class="comment">//dim3 grid(2,3);</span></span><br><span class="line"><span class="comment">//int nx = 8;</span></span><br><span class="line"><span class="comment">//int ny = 6;</span></span><br><span class="line">printThreadIndex &lt;&lt; &lt;grid, block &gt;&gt; &gt; (A_dev, nx, ny);</span><br></pre></td></tr></table></figure>
<p>对应的计算示意图如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/a8de254c0be85b7d778bef29d5b33ca.jpg"/></p>
<p>程序打印输出结果如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191108232742.png"/></p>
<p>设置不同的block或者 grid大小，计算的性能也会不一样的，如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191109132806.png"/></p>
<p>可以看到在GPU上计算明显比CPU上计算快很多。</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>时间计算的比较：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cuda_runtime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"device_launch_parameters.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"freshman.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sumMatrix2D_CPU</span><span class="params">(<span class="keyword">float</span> * MatA, <span class="keyword">float</span> * MatB, <span class="keyword">float</span> * MatC, <span class="keyword">int</span> nx, <span class="keyword">int</span> ny)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> * a = MatA;</span><br><span class="line">	<span class="keyword">float</span> * b = MatB;</span><br><span class="line">	<span class="keyword">float</span> * c = MatC;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ny; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nx; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			c[i] = a[i] + b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		c += nx;</span><br><span class="line">		b += nx;</span><br><span class="line">		a += nx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">sumMatrix</span><span class="params">(<span class="keyword">float</span> * MatA, <span class="keyword">float</span> * MatB, <span class="keyword">float</span> * MatC, <span class="keyword">int</span> nx, <span class="keyword">int</span> ny)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ix = threadIdx.x + blockDim.x*blockIdx.x;</span><br><span class="line">	<span class="keyword">int</span> iy = threadIdx.y + blockDim.y*blockIdx.y;</span><br><span class="line">	<span class="keyword">int</span> idx = ix + iy * ny;</span><br><span class="line">	<span class="keyword">if</span> (ix &lt; nx &amp;&amp; iy &lt; ny)</span><br><span class="line">	&#123;</span><br><span class="line">		MatC[idx] = MatA[idx] + MatB[idx];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"strating...\n"</span>);</span><br><span class="line">	initDevice(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> nx = <span class="number">1</span> &lt;&lt; <span class="number">12</span>;  <span class="comment">//2**12 = 4096</span></span><br><span class="line">	<span class="keyword">int</span> ny = <span class="number">1</span> &lt;&lt; <span class="number">12</span>;  <span class="comment">//2**12 = 4096</span></span><br><span class="line">	<span class="keyword">int</span> nxy = nx * ny;  <span class="comment">// 4096 * 4096</span></span><br><span class="line">	<span class="keyword">int</span> nBytes = nxy * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);  <span class="comment">// nxy 共占用多少个字节</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Malloc</span></span><br><span class="line">	<span class="keyword">float</span>* A_host = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);  <span class="comment">// 分配指针空间</span></span><br><span class="line">	<span class="keyword">float</span>* B_host = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">	<span class="keyword">float</span>* C_host = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">	<span class="keyword">float</span>* C_from_gpu = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">	initialData(A_host, nxy);</span><br><span class="line">	initialData(B_host, nxy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cudaMalloc</span></span><br><span class="line">	<span class="keyword">float</span> *A_dev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">float</span> *B_dev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">float</span> *C_dev = <span class="literal">NULL</span>;</span><br><span class="line">	CHECK(cudaMalloc((<span class="keyword">void</span>**)&amp;A_dev, nBytes));</span><br><span class="line">	CHECK(cudaMalloc((<span class="keyword">void</span>**)&amp;B_dev, nBytes));</span><br><span class="line">	CHECK(cudaMalloc((<span class="keyword">void</span>**)&amp;C_dev, nBytes));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	CHECK(cudaMemcpy(A_dev, A_host, nBytes, cudaMemcpyHostToDevice));</span><br><span class="line">	CHECK(cudaMemcpy(B_dev, B_host, nBytes, cudaMemcpyHostToDevice));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> dimx = <span class="number">32</span>;</span><br><span class="line">	<span class="keyword">int</span> dimy = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cpu compute</span></span><br><span class="line">	cudaMemcpy(C_from_gpu, C_dev, nBytes, cudaMemcpyDeviceToHost);</span><br><span class="line">	<span class="keyword">double</span> iStart = cpuSecond();</span><br><span class="line">	sumMatrix2D_CPU(A_host, B_host, C_host, nx, ny);</span><br><span class="line">	<span class="keyword">double</span> iElaps = cpuSecond() - iStart;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"CPU Execution Time elapsed %f sec\n"</span>, iElaps);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//==================================== 2d block and 2d grid ================================</span></span><br><span class="line">	<span class="function">dim3 <span class="title">block_0</span><span class="params">(dimx, dimy)</span></span>; <span class="comment">// blockDim.x = 32， blockDim.y = 32, threadIdx.x(y) in [0,31]</span></span><br><span class="line">	<span class="comment">// (nx - 1)/ block_0.x + 1 相当于 int(nx/block_0.x)</span></span><br><span class="line">	<span class="function">dim3 <span class="title">grid_0</span><span class="params">((nx - <span class="number">1</span>) / block_0.x + <span class="number">1</span>, (ny - <span class="number">1</span>) / block_0.y + <span class="number">1</span>)</span></span>; <span class="comment">//128， 128，  gridDim.x(y) = 128, blockIdx.x(y) in [0,128]</span></span><br><span class="line">	iStart = cpuSecond();</span><br><span class="line">	sumMatrix &lt;&lt; &lt;grid_0, block_0 &gt;&gt; &gt; (A_dev, B_dev, C_dev, nx, ny);</span><br><span class="line">	CHECK(cudaDeviceSynchronize());</span><br><span class="line">	iElaps = cpuSecond() - iStart;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"GPU Execution configuration grid and block shape: &lt;&lt;&lt;(%d,%d),(%d,%d)&gt;&gt;&gt; Time elapsed %f sec\n"</span>,</span><br><span class="line">		grid_0.x, grid_0.y, block_0.x, block_0.y, iElaps);</span><br><span class="line">	CHECK(cudaMemcpy(C_from_gpu, C_dev, nBytes, cudaMemcpyDeviceToHost));</span><br><span class="line">	checkResult(C_host, C_from_gpu, nxy);</span><br><span class="line">	<span class="comment">//============================================================================================</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//=====================================1d block and 1d grid ==================================</span></span><br><span class="line">	dimx = <span class="number">32</span>;</span><br><span class="line">	<span class="function">dim3 <span class="title">block_1</span><span class="params">(dimx)</span></span>;  <span class="comment">// 32</span></span><br><span class="line">	<span class="function">dim3 <span class="title">grid_1</span><span class="params">((nxy - <span class="number">1</span>) / block_1.x + <span class="number">1</span>)</span></span>;  <span class="comment">// (4096 * 4096 -1)/ 32 + 1 = 524288</span></span><br><span class="line">	iStart = cpuSecond();</span><br><span class="line">	sumMatrix &lt;&lt; &lt;grid_1, block_1 &gt;&gt; &gt; (A_dev, B_dev, C_dev, nx*ny, <span class="number">1</span>);</span><br><span class="line">	CHECK(cudaDeviceSynchronize());</span><br><span class="line">	iElaps = cpuSecond() - iStart;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"GPU Execution configuration grid and block shape: &lt;&lt;&lt;(%d,%d),(%d,%d)&gt;&gt;&gt; Time elapsed %f sec\n"</span>,</span><br><span class="line">		grid_1.x, grid_1.y, block_1.x, block_1.y, iElaps);</span><br><span class="line">	CHECK(cudaMemcpy(C_from_gpu, C_dev, nBytes, cudaMemcpyDeviceToHost));</span><br><span class="line">	checkResult(C_host, C_from_gpu, nxy);</span><br><span class="line">	<span class="comment">//============================================================================================</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//===================================== 2d block and 1d grid =================================</span></span><br><span class="line">	dimx = <span class="number">32</span>;</span><br><span class="line">	<span class="function">dim3 <span class="title">block_2</span><span class="params">(dimx)</span></span>; <span class="comment">// 32</span></span><br><span class="line">	<span class="function">dim3 <span class="title">grid_2</span><span class="params">((nx - <span class="number">1</span>) / block_2.x + <span class="number">1</span>, ny)</span></span>;  <span class="comment">// 128, 4096</span></span><br><span class="line">	iStart = cpuSecond();</span><br><span class="line">	sumMatrix &lt;&lt; &lt;grid_2, block_2 &gt;&gt; &gt; (A_dev, B_dev, C_dev, nx, ny);</span><br><span class="line">	CHECK(cudaDeviceSynchronize());</span><br><span class="line">	iElaps = cpuSecond() - iStart;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"GPU Execution configuration grid and block shape: &lt;&lt;&lt;(%d,%d),(%d,%d)&gt;&gt;&gt; Time elapsed %f sec\n"</span>,</span><br><span class="line">		grid_2.x, grid_2.y, block_2.x, block_2.y, iElaps);</span><br><span class="line">	CHECK(cudaMemcpy(C_from_gpu, C_dev, nBytes, cudaMemcpyDeviceToHost));</span><br><span class="line">	checkResult(C_host, C_from_gpu, nxy);</span><br><span class="line">	<span class="comment">//=============================================================================================</span></span><br><span class="line">	cudaFree(A_dev);</span><br><span class="line">	cudaFree(B_dev);</span><br><span class="line">	cudaFree(C_dev);</span><br><span class="line">	<span class="built_in">free</span>(A_host);</span><br><span class="line">	<span class="built_in">free</span>(B_host);</span><br><span class="line">	<span class="built_in">free</span>(C_host);</span><br><span class="line">	<span class="built_in">free</span>(C_from_gpu);</span><br><span class="line">	cudaDeviceReset();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>20191106记录</title>
    <url>/2019/11/06/20191106%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>堆、判断2的幂次方、Python线程安全</p>
<a id="more"></a>
<h2 id="Python的线程安全"><a href="#Python的线程安全" class="headerlink" title="Python的线程安全"></a>Python的线程安全</h2><p>什么是线程安全？</p>
<p>在一段程序中，如果两个线程t1,t2共享一个全局变量，且这多个线程对同一个全局变量操作会出现资源竞争的问题，从而导致结果会不正确，即遇到线程安全的问题。所以一般采用线程同步或互斥锁机制保证共享数据在任何时刻，最多有一个线程访问，以保证数据的正确性。</p>
<p>其中Python内置类型： ditc, list, tuple是线程安全的。</p>
<p><a href="https://blog.csdn.net/u010649766/article/details/79740873" target="_blank" rel="noopener">参考</a></p>
<h2 id="快速判断一个数是否是-2-的幂次方"><a href="#快速判断一个数是否是-2-的幂次方" class="headerlink" title="快速判断一个数是否是 2 的幂次方"></a>快速判断一个数是否是 2 的幂次方</h2><p>如果将这个数减去1后会发现，仅有的那个1会变为0，而原来的那n个0会变为1；因此将原来的数与去减去1后的数字进行与运算后会发现为零。<br>例如：</p>
<script type="math/tex; mode=display">1000 \& 0111 = 0000</script><p>则8(1000)就是2的幂次方。</p>
<p><a href="https://blog.csdn.net/wanrenwangxuejing/article/details/28940769" target="_blank" rel="noopener">参考</a></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><a href="https://www.cnblogs.com/lanhaicode/p/10546257.html" target="_blank" rel="noopener">来源</a></p>
<p>堆是一种 <strong>非线性结构</strong> ，可以把堆看作一个数组，也可以被看作是一个 <strong>完全二叉树</strong> (若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。)， 堆其实就是 <strong>利用完全二叉树的结构来维护的一维数组。</strong></p>
<p>大顶堆： 每个节点的值都 <strong>大于或等于</strong> 其左右孩子节点的值；</p>
<p>小顶堆： 每个节点的值都 <strong>小于或等于</strong> 其左右孩子节点的值；</p>
<p>堆的这种特性非常有用，常常被当作 <strong>优先队列</strong> 使用，因为可以快速的访问到“最重要”的元素。</p>
<p><strong>堆特点：</strong></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107131510.png"/></p>
<p>对堆中的节点按层进行编号，映射到数组中：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107131622.png"/></p>
<p>所以有如下堆的定义：</p>
<p>大顶堆：</p>
<script type="math/tex; mode=display">arr[i] \geq arr[2i+1] \&\& arr[i] \geq arr[2i+2]</script><p>小定顶堆：</p>
<script type="math/tex; mode=display">a[i] \leq arr[2i+1] \&\& arr[i] \leq arr[2i+2]</script><p><strong>堆排序的过程：</strong></p>
<p>基本思想：</p>
<ol>
<li>将待排序序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根节点。</li>
<li>将其与末尾元素进行交换，此时末尾就为最大值。</li>
<li>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。</li>
<li>如此反复执行，便能得到一个有序序列了，建立最大堆时是从 <strong>最后一个非叶子节点</strong> 开始从下往上调整的。</li>
</ol>
<p>升序 — 大顶堆；<br>降序 — 小顶堆；</p>
<p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">具体步骤:</a></p>
<p><strong>步骤一： 构造初始堆，将给定的无序序列构造成一个大顶堆：</strong></p>
<ol>
<li>给定无序序列如下：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107133021.png" weight='300' height='300'/></p>
<ol>
<li>从最后一个非叶子节点(<code>arr.length/2 -1 = 5/2-1 = 1</code>，也就是下面的 6 节点)，从左至右，从下往上进行调整：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107133334.png"/></p>
<p>节点6先和其左孩子比较<code>a[2 * 1 + 1] = arr[3] =5</code> ,因为6 &gt; 5所以不作调整；<br>和其右孩子比较<code>a[2 * 1 + 2] = arr[4] =9</code>, 因为 9 &gt; 6 ，所以两者进行交换</p>
<ol>
<li>找到下一个非叶子节点，当前坐标-1即 1-1 = 0，即第二个非叶子节点为4, [4,9,8]中9元素最大， 4和9 交换：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107140047.png"/></p>
<ol>
<li>这时，交换导致了子根[4,5,6]混乱，继续调整，[4,5,6]中 6 最大，交换 4 和6：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107140247.png"/></p>
<p><strong>步骤二：将堆顶元素和末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换：</strong></p>
<ol>
<li>将堆顶元素9 和末尾元素4 进行交换：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107140902.png"/></p>
<ol>
<li>重新调整结构，使其继续满足堆定义：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107140951.png"/></p>
<ol>
<li>再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素8：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107141044.png"/></p>
<ol>
<li>后续过程，继续进行调整、交换，如此反复，最终使得整个序列有序：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107141321.png" width="300" /></p>
<p>代码：</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程知识点</title>
    <url>/2019/11/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>在秋招过程中根据别人整理的网络编程知识点，进行的二次整理，主要是一些高频知识点。</p>
<a id="more"></a>
<h3 id="1-TCP协议的三次握手和四次挥手"><a href="#1-TCP协议的三次握手和四次挥手" class="headerlink" title="1. TCP协议的三次握手和四次挥手"></a>1. TCP协议的三次握手和四次挥手</h3><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191012142805.png"/></p>
<ul>
<li><p>三次握手：</p>
<ol>
<li><p>c -&gt; s, 客户端向服务端发送带有SYN（同步标识位=1）的报文段seq(序号=x),c进入<code>SYN_SENT</code>状态;</p>
</li>
<li><p>s -&gt; c, 服务端接收到客户端发来的报文，检测SYN=1，知道客户端想和自己建立连接，则返回带有SYN(=1)，ACK(确认标识位=x+1)的报文段seq(=y)，s进入<code>SYN_RCVD</code>状态；</p>
</li>
<li><p>c -&gt; s，客户端检查服务端发来的信息(SYN, ACK,seq)，再向其发送ACK(=y+1)，服务端接收后检查ACK是否为y+1，是则建立链接完成三次握手,c和s都进入<code>ESTABLISHED</code>状态。</p>
</li>
</ol>
</li>
<li><p>四次挥手：</p>
<ol>
<li><p>c -&gt; s, 客户端发送带有FIN(结束标识位)的seq(=x+2), ACK(=y+1)，告诉服务端要断开连接，进入<code>FIN_WAIT_1</code>状态；</p>
</li>
<li><p>s -&gt; c, 服务端接收到FIN报文后向客户端发送ACK(=x+3)，服务器进入<code>CLOSE_WAIT</code>状态，客户端收到后进入<code>FIN_WAIT_2</code>状态；</p>
</li>
<li><p>s -&gt; c, 当服务器发送完剩下的数据后，向客户端发送带有FIN的seq(=y+1)，并进入<code>LAST_ACK</code>状态；</p>
</li>
<li><p>c -&gt; s, 客户端向服务端发送ACK(=y+2)，进入<code>TIME_WAIT</code>状态，等待2MSL(报文段最大生存时间)，没有服务端响应则关闭连接。</p>
</li>
</ol>
</li>
</ul>
<h3 id="2-一定要三次握手的原因"><a href="#2-一定要三次握手的原因" class="headerlink" title="2. 一定要三次握手的原因"></a>2. 一定要三次握手的原因</h3><p>客户端和服务端建立连接时，由于某种原因长时间驻留在网络节点中，无法达到服务器，因为TCP存在 <strong>超时重传机制</strong> ，客户端会不断尝试建立连接，直到成功。假设后面成功建立连接，传输结束断开连接后，若之前客户端发送给的连接请求又被服务端接收，则服务端会以为客户端尝试再次建立连接，如果仅存在这两次握手，则服务端会同意与客户端建立连接，并一直等待客户端的响应，但实际客户端此时已经关闭，直到超出计数器的设定值，服务端才会认为服务异常，关闭这个连接，造成计算资源的浪费，而加入第三次握手的机制由于服务端没有等到客户端的再次响应则不会再建立该连接。</p>
<h3 id="3-挥手比握手多一次的原因"><a href="#3-挥手比握手多一次的原因" class="headerlink" title="3. 挥手比握手多一次的原因"></a>3. 挥手比握手多一次的原因</h3><p>因为建立连接时，可以把SYN,ACK,seq放在同一个报文中进行传输，但是在断开连接时，服务端需要先将剩余的数据传输结束后，才能再向客户端发送FIN标识位以请求关闭连接，通常这里的ACK报文和FIN报文是分开传输的。</p>
<h3 id="4-HTTP和HTTPS"><a href="#4-HTTP和HTTPS" class="headerlink" title="4. HTTP和HTTPS"></a>4. HTTP和HTTPS</h3><p>HTTP: 是互联网上一种广泛的网络协议，是 <strong>客户端和服务端请求和应答的标准</strong></p>
<p>HTTPS: 是以安全为目标的HTTP通道，即在HTTP的三次握手后加入SSL层，主要用于1) 建立安全通道保证数据传输的安全，2) 确认网站的安全性。</p>
<p><strong>区别</strong></p>
<ol>
<li><p>HTTP协议是超文本传输协议，信息是明文传输，而HTTPS协议传输的数据是经过加密的，具有更高的安全性；</p>
</li>
<li><p>端口不同前者为80，后者是443</p>
</li>
</ol>
<h3 id="5-IP地址和MAC地址"><a href="#5-IP地址和MAC地址" class="headerlink" title="5. IP地址和MAC地址"></a>5. IP地址和MAC地址</h3><p>IP地址是IP协议提供的统一的地址格式，为互联网上每一个网络和每一台主机分配一个逻辑地址，以屏蔽物理地址的差异</p>
<p>MAC地址是一个硬件地址，用来确认网络设备位置的地址，在OSI模型中右数据连接层负责。如果一台设备有多块网卡，则每个网卡都会有一个唯一的MAC地址。</p>
<h3 id="6-打开一个网站的过程，以及其对那个的各个层的过程"><a href="#6-打开一个网站的过程，以及其对那个的各个层的过程" class="headerlink" title="6. 打开一个网站的过程，以及其对那个的各个层的过程"></a>6. 打开一个网站的过程，以及其对那个的各个层的过程</h3><ol>
<li>域名解析，浏览器获得URL地址，向操作系统请求该URL地址的IP地址，操作系统查询DNS（先查询本地HOST文件，没有则查询网络）获得对应的IP地址；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL 分割成几个部分：协议(http(s),ftp)、网络协议(域名、IP地址、端口号)、资源路径</span><br></pre></td></tr></table></figure>
<ol>
<li>确认好IP地址和端口号后，向该IP地址对应的服务器的该端口号发起TCP连接请求；</li>
</ol>
<ol>
<li><p>服务接收到TCP连接请求后，回复可以建立连接；</p>
</li>
<li><p>浏览器收到回传的数据后，还会向服务端发送数据包，表示三次握手的结束</p>
</li>
<li><p>三次握手成功后，开始通讯，客户端根据HTTP协议的要求，组织一个请求的数据包，其中包含请求的资源路径、身份信息等，服务器响应请求，将数据返回给浏览器，浏览器根据HTML协议组织网页，以此反复；</p>
</li>
<li><p>渲染页面，响应用户的操作；</p>
</li>
<li><p>关闭网页时，断开连接。</p>
</li>
</ol>
<h3 id="7-OSI七层模型和TCP-IP四层模型，每层用到的协议"><a href="#7-OSI七层模型和TCP-IP四层模型，每层用到的协议" class="headerlink" title="7. OSI七层模型和TCP/IP四层模型，每层用到的协议"></a>7. OSI七层模型和TCP/IP四层模型，每层用到的协议</h3><h4 id="OSI-Opening-System-Interconnection-开放系统互连"><a href="#OSI-Opening-System-Interconnection-开放系统互连" class="headerlink" title="OSI(Opening System Interconnection 开放系统互连)"></a>OSI(Opening System Interconnection 开放系统互连)</h4><ul>
<li>第七层 应用层</li>
</ul>
<p>为应用软件而设的接口</p>
<pre><code>功能： 文件传输，电子邮件，文件服务等；

协议： HTTP，HTTPS，FTP
</code></pre><ul>
<li>第六层 表示层</li>
</ul>
<p>把数据转换为能与接收者的系统格式兼容并适合传输的格式</p>
<pre><code>功能： 数据格式化，代码转换，数据加密
</code></pre><ul>
<li>第五层 会话层</li>
</ul>
<p>负责在数据传输过程中设置和维护计算机网络中两台计算机之间的通信连接</p>
<pre><code>功能： 解除或建立与其他接点的联系
</code></pre><ul>
<li>第四层 传输层</li>
</ul>
<p>把传输表头加至数据以形成数据包。传输表头包含了所使用的协议等发送信息</p>
<pre><code>功能： 提供端对端的接口

协议： TCP, UDP
</code></pre><ul>
<li>第三层 网络层</li>
</ul>
<p>决定数据的路径选择和转寄，将网络表头(NH)加至数据包，以形成报文，网格表头包含了网络数据</p>
<pre><code>功能： 为数据包选择路由

协议： IP
</code></pre><ul>
<li>第二层 数据链路层</li>
</ul>
<p>负责网络寻址、错误侦测和改错</p>
<pre><code>功能： 传输有地址的帧，错误检测功能

协议： ARP, SLIP,RARP
</code></pre><ul>
<li>第一层 物理层</li>
</ul>
<p>在局部局域网上传送数据帧，负责管理计算机通信设备和网络媒体之间的互通，包括电压、网卡、主机接口卡等</p>
<pre><code>功能： 以二进制形式在物理媒体上传输数据

协议： ISO2110, IEEE802
</code></pre><h4 id="TCP-IP-4层网络模型"><a href="#TCP-IP-4层网络模型" class="headerlink" title="TCP/IP 4层网络模型"></a>TCP/IP 4层网络模型</h4><ul>
<li>第四层 应用层</li>
</ul>
<p>电子邮件，文件传输</p>
<p>网页访问使用http协议，文件传输FTP协议，电子邮件发送SMTP协议，域名解析DNS协议，远程登陆Talnet协议</p>
<ul>
<li>第三层 传输层</li>
</ul>
<p>TCP,UDP协议分析</p>
<ul>
<li>第二层 网络层</li>
</ul>
<p>检查IP地址，路由设置</p>
<ul>
<li>第一层 网络接口层</li>
</ul>
<p>ARP地址检测、物理连接检测</p>
<p>小结：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191012165823.png"/></p>
<h3 id="8-TCP和UDP"><a href="#8-TCP和UDP" class="headerlink" title="8. TCP和UDP"></a>8. TCP和UDP</h3><ol>
<li><p>TCP面向连接（如打电话要先拨号建立连接），UDP在发送数据之前不需要建立连接；</p>
</li>
<li><p>TCP更加可靠，TCP传输的数据无差错，不丢失，不重复；</p>
</li>
<li><p>UDP较好的实时性，工作效率比TCP高，适用于对高速传输和实时性较高的通信或广播通信；</p>
</li>
<li><p>每一条TCP连接只能是点对点； UDP支持一对一，一对多，多对一和多对多的交互通信；</p>
</li>
<li><p>TCP对系统资源要求较多，UDP对系统资源要求较少；</p>
</li>
<li><p>要求数据的完成性应该适用TCP，如文件的传输、重要状态的更新； 要求实时性使用UDP，如视频传输、实时通信；</p>
</li>
<li><p>TCP面向字节流，UDP面向数据包</p>
</li>
</ol>
<h3 id="9-TCP的拥塞控制"><a href="#9-TCP的拥塞控制" class="headerlink" title="9. TCP的拥塞控制"></a>9. TCP的拥塞控制</h3><ol>
<li><p>发送维护一个拥塞窗口，由小到达逐渐增加拥塞窗口，探测网络的拥塞程度</p>
</li>
<li><p>快重传和快恢， 要求接收方在收到一个失序的报文段后就立即发出重复确认而不要等到自己发送数据时捎带确认。</p>
</li>
</ol>
<h3 id="10-DNS干什么的"><a href="#10-DNS干什么的" class="headerlink" title="10. DNS干什么的"></a>10. DNS干什么的</h3><p>DNS(Domain Name System 域名系统)， 将域名和地址相互映射的一个分布式数据库，能够让人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p>主机解析域名的顺序：</p>
<p>找缓存、找本及的hosts文件、找DNS服务器</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191105212943.png"/></p>
<p><strong>根域名服务器</strong>：是互联网域名解析系统（DNS）中最高级别的域名服务器，负责返回顶级域的权威域名服务器地址，全球只有13台，中国境内是其镜像。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>常见神经网络模型量估计</title>
    <url>/2019/11/05/%E5%B8%B8%E8%A7%81%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E9%87%8F%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<p>对于常见的深度学习，如CNN,RNN,DNN,GRU,LSTM，如果可以在设计模型时就能设计出模型的参数量，那对于后续的性能优化、模型部署调优都会有一个直观上的感受和帮助。</p>
<a id="more"></a>
<h2 id="1-CNN参数个数"><a href="#1-CNN参数个数" class="headerlink" title="1. CNN参数个数"></a>1. CNN参数个数</h2><p>常见CNN模型一般包含以下几种类型的层：卷积层、池化层和全连接层。假设卷积核大小为H*W， input channel为I，out channel为O。</p>
<ol>
<li>卷积层(Convolutional Layer):</li>
</ol>
<p>该层filter数量总数为(H x W x I)，每个将被映射到新的输出通道上，加上每个filter的计算要有一个bias，所以总的参数数量为：(H x W x I + 1) x O</p>
<ol>
<li>池化层(Pooling Layer)：</li>
</ol>
<p>一般的池化层属于固定操作，没有权重传播</p>
<h2 id="2-全连接层参数个数"><a href="#2-全连接层参数个数" class="headerlink" title="2. 全连接层参数个数"></a>2. 全连接层参数个数</h2><p>前后是n,m维的输入输出，所以其参数数量为(n+1) x m</p>
<blockquote>
<p>以下循环神经网络均已单层为例</p>
</blockquote>
<h2 id="3-RNN参数个数"><a href="#3-RNN参数个数" class="headerlink" title="3. RNN参数个数"></a>3. RNN参数个数</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191105212219.png"/></p>
<p>图上W,U,V在RNN的每一步中都是共享的参数，所以其参数量为：</p>
<script type="math/tex; mode=display">Number = n^2+kn+nm</script><ul>
<li>n- 隐藏层的维度</li>
<li>k- 输出层的维度</li>
<li>m- 输入层的维度</li>
</ul>
<p>$n^2$ 就是 $W*W$部分<br>$kn$ 就是$WV$部分<br>$nm$ 就是$UW$部分</p>
<h2 id="4-LSTM参数个数"><a href="#4-LSTM参数个数" class="headerlink" title="4. LSTM参数个数"></a>4. LSTM参数个数</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191105210926.png"/></p>
<p>LSTM一共维护四套参数，分别对应输入门、输出门、遗忘门和候选态，总参数数量：</p>
<script type="math/tex; mode=display">Number = 4 * n * (m + 1 + n)</script><ul>
<li>n- 隐藏层的维度</li>
<li>m- 输入层的维度</li>
<li>1 表示的是偏置项</li>
</ul>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line">rnn = nn.LSTM(input_size=<span class="number">100</span>, hidden_size=<span class="number">512</span>, num_layers=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>所以参数个数为：<script type="math/tex">4 \times 512 \times (100+1+512) = 1255424</script></p>
<h2 id="5-GRU参数个数"><a href="#5-GRU参数个数" class="headerlink" title="5. GRU参数个数"></a>5. GRU参数个数</h2><p>和LSTM类似，但是只有三套参数，更新门、重置门、候选态，总参数量为：</p>
<script type="math/tex; mode=display">Number = 3 \times n \times (m + 1 + n)</script><ul>
<li>n- 隐藏层的维度</li>
<li>m- 输入层的维度</li>
<li>1 表示的是偏置项</li>
</ul>
<ol>
<li>实验：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        super(MyModel, self).__init__()</span><br><span class="line">        self.lstm = nn.LSTM(input_size=<span class="number">100</span>, hidden_size=<span class="number">512</span>, num_layers=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#         self.rnn = nn.RNN(input_size=100, hidden_size=512, num_layers=1)</span></span><br><span class="line"><span class="comment">#         self.gru = nn.GRU(input_size=100, hidden_size=512, num_layers=1)</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net = MyModel()</span><br><span class="line">params = list(net.parameters())</span><br><span class="line">k = <span class="number">0</span></span><br><span class="line">all_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> params:</span><br><span class="line">    l = <span class="number">1</span></span><br><span class="line">    print(<span class="string">"该层的结构："</span> + str(list(i.size())))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i.size():</span><br><span class="line">        l *= j</span><br><span class="line">    print(<span class="string">"该层参数和："</span> + str(l))</span><br><span class="line">    k = k + l</span><br><span class="line">print(<span class="string">"参数总和："</span>+str(k))</span><br></pre></td></tr></table></figure>
<p>以lstm为例输出：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191012003103.png" width='200' height='200'/></p>
<p>可以看到LSTM输出比预期的参数多了 512*4 = 2048</p>
<p>同样，GRU会比预期的参数多 512*3 = 1536</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191012003245.png"/></p>
<p>似乎是多一个偏置项，但是从<a href="https://www.cnblogs.com/wushaogui/p/9176617.html" target="_blank" rel="noopener">参考连接</a>他人用keras好像没有问题，难道是框架的问题？之后再做一下实验。。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p><a href="https://datascience.stackexchange.com/questions/10589/number-of-parameters-in-an-rnn" target="_blank" rel="noopener">RNN参数量</a></p>
<p><a href="https://blog.csdn.net/taoyafan/article/details/82803943" target="_blank" rel="noopener">LSTM参数量</a></p>
<p><a href="https://stats.stackexchange.com/questions/328926/how-many-parameters-are-in-a-gated-recurrent-unit-gru-recurrent-neural-network" target="_blank" rel="noopener">GRU参数量</a></p>
<p><a href="https://blog.csdn.net/jdzwanghao/article/details/84196239" target="_blank" rel="noopener">pytorch参数量计算</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>STL 容器记录</title>
    <url>/2019/11/04/STL%E5%AE%B9%E5%99%A8%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>主要涉及到c++中STL容器的一些用法：vector,set,stack,queue,map,deque及Algorithm，不记得时可以随时查漏补缺。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">转载自@author 鲁伟林</span><br><span class="line">gitHub地址：https://github.com/thinkingfioa/Notes/blob/master/TechFiles/STL_Usage.md</span><br></pre></td></tr></table></figure>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="push-back-函数"><a href="#push-back-函数" class="headerlink" title="push_back()函数"></a>push_back()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector;</span><br><span class="line">myVector.push_back(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="pop-back-函数"><a href="#pop-back-函数" class="headerlink" title="pop_back()函数"></a>pop_back()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从后往前pop</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector;</span><br><span class="line">myVector.push_back(<span class="number">100</span>);</span><br><span class="line">myVector.push_back(<span class="number">200</span>);</span><br><span class="line">myVector.push_back(<span class="number">300</span>);</span><br><span class="line"><span class="comment">//执行前: 100, 200, 300</span></span><br><span class="line">myVector.pop_back();</span><br><span class="line"><span class="comment">//执行后: 100, 200</span></span><br></pre></td></tr></table></figure></p>
<h3 id="insert-函数"><a href="#insert-函数" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">3</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">  <span class="comment">//执行前: 100, 100, 100</span></span><br><span class="line">  it = myvector.begin();</span><br><span class="line">  it = myvector.insert ( it , <span class="number">200</span> );</span><br><span class="line">  <span class="comment">//执行后: 200, 100, 100, 100</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//执行前: 200, 100, 100, 100</span></span><br><span class="line">  myvector.insert (it,<span class="number">2</span>,<span class="number">300</span>);</span><br><span class="line">  <span class="comment">//执行后: 300, 300, 200, 100, 100, 100</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// "it" no longer valid, get a new one:</span></span><br><span class="line">  it = myvector.begin();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行前: 300, 300, 200, 100, 100, 100</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; anothervector (<span class="number">2</span>,<span class="number">400</span>);</span><br><span class="line">  myvector.insert (it+<span class="number">2</span>,anothervector.begin(),anothervector.end());</span><br><span class="line">  <span class="comment">//执行后: 300, 300, 400, 400, 200, 100, 100, 100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myarray [] = &#123; <span class="number">501</span>,<span class="number">502</span>,<span class="number">503</span> &#125;;</span><br><span class="line">  <span class="comment">//执行前: 300, 300, 400, 400, 200, 100, 100, 100</span></span><br><span class="line">  myvector.insert (myvector.begin(), myarray, myarray+<span class="number">3</span>);</span><br><span class="line">  <span class="comment">//执行后: 501, 502, 503, 300, 300, 400, 400, 200, 100, 100, 100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数"><a href="#erase-函数" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">	myVector.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 6, 7, 8, 9</span></span><br><span class="line">myVector.erase(myVector.begin() +<span class="number">5</span>); <span class="comment">// 移除下标为5的数,也就是myVector[5]=6</span></span><br><span class="line"><span class="comment">//执行后: 1, 2, 3, 4, 5, 7, 8, 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 7, 8, 9</span></span><br><span class="line">myVector.erase(myVector.begin(), myVector.begin() + <span class="number">3</span>);</span><br><span class="line"><span class="comment">//执行后: 4, 5, 7, 8, 9</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数"><a href="#swap-函数" class="headerlink" title="swap()函数"></a>swap()函数</h3><p> 代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">3</span>,<span class="number">100</span>);   <span class="comment">// three ints with a value of 100</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar (<span class="number">5</span>,<span class="number">200</span>);   <span class="comment">// five ints with a value of 200</span></span><br><span class="line"><span class="comment">//执行前: foo: [100, 100, 100]</span></span><br><span class="line"><span class="comment">//       bar: [200, 200, 200, 200, 200]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">//执行后: foo: [200, 200, 200, 200, 200]</span></span><br><span class="line"><span class="comment">//       bar: [100, 100, 100]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>迭代器遍历:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (it=myvector.begin(); it&lt;myvector.end(); it++)&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C++中的Set是一个有序-去重集合</span><br></pre></td></tr></table></figure>
<h3 id="insert-函数-1"><a href="#insert-函数-1" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator,<span class="keyword">bool</span>&gt; ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; ++i) myset.insert(i*<span class="number">10</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 30, 40, 50</span></span><br><span class="line">ret = myset.insert(<span class="number">20</span>);  <span class="comment">// no new element inserted</span></span><br><span class="line"><span class="comment">//执行后: 10, 20, 30, 40, 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret.second==<span class="literal">false</span>) it=ret.first;  <span class="comment">// "it" now points to element 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 30, 40, 50</span></span><br><span class="line">myset.insert (it,<span class="number">25</span>);                 <span class="comment">// max efficiency inserting</span></span><br><span class="line">myset.insert (it,<span class="number">24</span>);                 <span class="comment">// max efficiency inserting</span></span><br><span class="line">myset.insert (it,<span class="number">26</span>);                 <span class="comment">// no max efficiency inserting</span></span><br><span class="line"><span class="comment">//执行后: 10, 20, 24, 25, 26, 30, 40, 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 24, 25, 26, 30, 40, 50</span></span><br><span class="line"><span class="keyword">int</span> myints[]= &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>&#125;;              <span class="comment">// 10 already in set, not inserted</span></span><br><span class="line">myset.insert (myints,myints+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//执行后: 5, 10, 15, 20, 24, 25, 26, 30, 40, 50</span></span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数-1"><a href="#erase-函数-1" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert some values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; i++) myset.insert(i*<span class="number">10</span>);  <span class="comment">// 10 20 30 40 50 60 70 80 90</span></span><br><span class="line"></span><br><span class="line">it = myset.begin();</span><br><span class="line">++it;                                         <span class="comment">// "it" points now to 20</span></span><br><span class="line"><span class="comment">// 执行前: 10, 20, 30, 40, 50, 60, 70, 80, 90; //(*it) = 20</span></span><br><span class="line">myset.erase (it);</span><br><span class="line"><span class="comment">//执行后: 10, 30, 40, 50, 60, 70, 80, 90; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 30, 40, 50, 60, 70, 80, 90;</span></span><br><span class="line">myset.erase (<span class="number">40</span>);</span><br><span class="line"><span class="comment">//执行后: 10, 30, 50, 60, 70, 80, 90; </span></span><br><span class="line"></span><br><span class="line">it = myset.find (<span class="number">60</span>);</span><br><span class="line"><span class="comment">//执行前: 10, 30, 50, 60, 70, 80, 90; </span></span><br><span class="line">myset.erase (it, myset.end());</span><br><span class="line"><span class="comment">//执行后: 10, 30, 50;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-1"><a href="#swap-函数-1" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[]=&#123;<span class="number">12</span>,<span class="number">75</span>,<span class="number">10</span>,<span class="number">32</span>,<span class="number">20</span>,<span class="number">25</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; first (myints,myints+<span class="number">3</span>);     <span class="comment">// 10,12,75</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; second (myints+<span class="number">3</span>,myints+<span class="number">6</span>);  <span class="comment">// 20,25,32</span></span><br><span class="line"><span class="comment">//执行前: first [10, 12, 75]</span></span><br><span class="line"><span class="comment">//        second [20, 25, 32]</span></span><br><span class="line">first.swap(second);</span><br><span class="line"><span class="comment">//执行后: first [20, 25, 32]</span></span><br><span class="line"><span class="comment">//       second [10, 12, 75]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="find-函数"><a href="#find-函数" class="headerlink" title="find()函数"></a>find()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) myset.insert(i*<span class="number">10</span>);    <span class="comment">// set: 10 20 30 40 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行前: 10, 20, 30, 40, 50</span></span><br><span class="line">it=myset.find(<span class="number">20</span>);</span><br><span class="line">myset.erase (it);</span><br><span class="line"><span class="comment">// 执行后: 10, 30, 40, 50</span></span><br></pre></td></tr></table></figure></p>
<h3 id="count-函数"><a href="#count-函数" class="headerlink" title="count()函数"></a>count()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由于set集合不重复，所以count(val)返回的结果只有0或者1.</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">5</span>; ++i) myset.insert(i*<span class="number">3</span>);    <span class="comment">// set: 3 6 9 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结果是: 1</span></span><br><span class="line">myset.count(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//返回结果是: 0</span></span><br><span class="line">myset.count(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">75</span>,<span class="number">23</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset (myints,myints+<span class="number">5</span>); <span class="comment">//13, 23, 42, 65, 75</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=myset.begin(); it!=myset.end(); ++it)&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="top-函数"><a href="#top-函数" class="headerlink" title="top()函数"></a>top()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line">mystack.push(<span class="number">10</span>);</span><br><span class="line">mystack.push(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">mystack.top() -= <span class="number">5</span>; <span class="comment">//mystack.top() 的值为20</span></span><br></pre></td></tr></table></figure></p>
<h3 id="push-函数"><a href="#push-函数" class="headerlink" title="push()函数"></a>push()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) mystack.push(i);</span><br></pre></td></tr></table></figure></p>
<h3 id="pop-函数"><a href="#pop-函数" class="headerlink" title="pop()函数"></a>pop()函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">弹出栈的最上面</span><br></pre></td></tr></table></figure>
<h3 id="swap-函数-2"><a href="#swap-函数-2" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; foo,bar;</span><br><span class="line">foo.push (<span class="number">10</span>); foo.push(<span class="number">20</span>); foo.push(<span class="number">30</span>);</span><br><span class="line">bar.push (<span class="number">111</span>); bar.push(<span class="number">222</span>);</span><br><span class="line"><span class="comment">// 执行前: foo [10, 20, 30]</span></span><br><span class="line"><span class="comment">//        bar [111, 222]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">// 执行后: foo [111, 222]</span></span><br><span class="line"><span class="comment">//        bar [10, 20, 30]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Popping out elements..."</span>;</span><br><span class="line"><span class="keyword">while</span> (!mystack.empty())</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; mystack.top();</span><br><span class="line">   mystack.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c++ 中的map是默认按照key的排序。所以每次插入都会做调整。</span><br></pre></td></tr></table></figure>
<h3 id="insert-函数-2"><a href="#insert-函数-2" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first insert function version (single parameter):</span></span><br><span class="line">mymap.insert ( <span class="built_in">std</span>::pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;(<span class="string">'a'</span>,<span class="number">100</span>) );</span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数-2"><a href="#erase-函数-2" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert some values:</span></span><br><span class="line">mymap[<span class="string">'a'</span>]=<span class="number">10</span>;</span><br><span class="line">mymap[<span class="string">'b'</span>]=<span class="number">20</span>;</span><br><span class="line">mymap[<span class="string">'c'</span>]=<span class="number">30</span>;</span><br><span class="line">mymap[<span class="string">'d'</span>]=<span class="number">40</span>;</span><br><span class="line">mymap[<span class="string">'e'</span>]=<span class="number">50</span>;</span><br><span class="line">mymap[<span class="string">'f'</span>]=<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">it=mymap.find(<span class="string">'b'</span>);</span><br><span class="line"><span class="comment">//执行前: a-&gt;10, b-&gt;20, c-&gt;30, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line">mymap.erase (it);                   <span class="comment">// erasing by iterator</span></span><br><span class="line"><span class="comment">//执行后: a-&gt;10, c-&gt;30, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: a-&gt;10, c-&gt;30, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line">mymap.erase (<span class="string">'c'</span>);                  <span class="comment">// erasing by key</span></span><br><span class="line"><span class="comment">//执行后: a-&gt;10, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line"></span><br><span class="line">it=mymap.find (<span class="string">'e'</span>);</span><br><span class="line"><span class="comment">//执行前: a-&gt;10, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line">mymap.erase ( it, mymap.end() );    <span class="comment">// erasing by range</span></span><br><span class="line"><span class="comment">//执行后: a-&gt;10, d-&gt;40</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-3"><a href="#swap-函数-3" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; foo,bar;</span><br><span class="line"></span><br><span class="line">foo[<span class="string">'x'</span>]=<span class="number">100</span>;</span><br><span class="line">foo[<span class="string">'y'</span>]=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">bar[<span class="string">'a'</span>]=<span class="number">11</span>;</span><br><span class="line">bar[<span class="string">'b'</span>]=<span class="number">22</span>;</span><br><span class="line">bar[<span class="string">'c'</span>]=<span class="number">33</span>;</span><br><span class="line"><span class="comment">// 执行前: foo [x-&gt;100, y-&gt;200]</span></span><br><span class="line"><span class="comment">//        bar [a-&gt;11, b-&gt;22, c-&gt;33]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">// 执行前: foo [a-&gt;11, b-&gt;22, c-&gt;33]</span></span><br><span class="line"><span class="comment">//        bar [x-&gt;100, y-&gt;200]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-3"><a href="#遍历-3" class="headerlink" title="遍历"></a>遍历</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=foo.begin(); it!=foo.end(); ++it) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="push-函数-1"><a href="#push-函数-1" class="headerlink" title="push()函数"></a>push()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; myqueue;</span><br><span class="line">myqueue.push (myint);</span><br></pre></td></tr></table></figure></p>
<h3 id="pop-函数-1"><a href="#pop-函数-1" class="headerlink" title="pop()函数"></a>pop()函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">弹出最后一个数。</span><br></pre></td></tr></table></figure>
<h3 id="swap-函数-4"><a href="#swap-函数-4" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; foo,bar;</span><br><span class="line">foo.push (<span class="number">10</span>); foo.push(<span class="number">20</span>); foo.push(<span class="number">30</span>);</span><br><span class="line">bar.push (<span class="number">111</span>); bar.push(<span class="number">222</span>);</span><br><span class="line"><span class="comment">// 执行前: foo[10, 20, 30]</span></span><br><span class="line"><span class="comment">//        bar[111, 222]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">// 执行后: foo[111, 222]</span></span><br><span class="line"><span class="comment">//        bar[10, 20, 30]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="back-函数"><a href="#back-函数" class="headerlink" title="back()函数"></a>back()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">队列的最后一位</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myqueue.push(<span class="number">12</span>);</span><br><span class="line">myqueue.push(<span class="number">75</span>);   <span class="comment">// this is now the back</span></span><br><span class="line"><span class="comment">//执行前: 12, 75</span></span><br><span class="line">myqueue.back() -= myqueue.front();</span><br><span class="line"><span class="comment">//执行后: 12, 63</span></span><br></pre></td></tr></table></figure></p>
<h3 id="front-函数"><a href="#front-函数" class="headerlink" title="front()函数"></a>front()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">队列的队首</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myqueue.push(<span class="number">77</span>);</span><br><span class="line">myqueue.push(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//执行前: 77, 16</span></span><br><span class="line">myqueue.front() -= myqueue.back();    <span class="comment">// 77-16=61</span></span><br><span class="line"><span class="comment">//执行后: 61, 16</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-4"><a href="#遍历-4" class="headerlink" title="遍历"></a>遍历</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myqueue contains: "</span>;</span><br><span class="line"><span class="keyword">while</span> (!myqueue.empty())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myqueue.front();</span><br><span class="line">  myqueue.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">双向队列</span><br></pre></td></tr></table></figure>
<h3 id="front-函数-1"><a href="#front-函数-1" class="headerlink" title="front()函数"></a>front()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回队首</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line">mydeque.push_front(<span class="number">77</span>);</span><br><span class="line">mydeque.push_back(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//执行前: 77, 20</span></span><br><span class="line">mydeque.front() -= mydeque.back();</span><br><span class="line"><span class="comment">//执行后: 57, 20</span></span><br></pre></td></tr></table></figure></p>
<h3 id="back-函数-1"><a href="#back-函数-1" class="headerlink" title="back()函数"></a>back()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">双向队列的尾部</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line">mydeque.push_back(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (mydeque.back() != <span class="number">0</span>)</span><br><span class="line">  mydeque.push_back ( mydeque.back() <span class="number">-1</span> );</span><br></pre></td></tr></table></figure></p>
<h3 id="push-back-函数-1"><a href="#push-back-函数-1" class="headerlink" title="push_back()函数"></a>push_back()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"><span class="comment">//执行前: []</span></span><br><span class="line">mydeque.push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//执行后: [1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: [1]</span></span><br><span class="line">mydeque.push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//执行后: [1,2]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="push-front-函数"><a href="#push-front-函数" class="headerlink" title="push_front()函数"></a>push_front()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque (<span class="number">2</span>,<span class="number">100</span>);     <span class="comment">// two ints with a value of 100</span></span><br><span class="line"><span class="comment">//执行前: 100, 100</span></span><br><span class="line">mydeque.push_front (<span class="number">200</span>);</span><br><span class="line"><span class="comment">//执行后: 200, 100, 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 200, 100, 100</span></span><br><span class="line">mydeque.push_front (<span class="number">300</span>);</span><br><span class="line"><span class="comment">//执行前: 300, 200, 100, 100</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pop-back-函数-1"><a href="#pop-back-函数-1" class="headerlink" title="pop_back()函数"></a>pop_back()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行前: </span></span><br><span class="line">mydeque.push_back (<span class="number">10</span>);</span><br><span class="line">mydeque.push_back (<span class="number">20</span>);</span><br><span class="line">mydeque.push_back (<span class="number">30</span>);</span><br><span class="line"><span class="comment">//执行后: 10, 20, 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 30</span></span><br><span class="line">mydeque.pop_back(); </span><br><span class="line"><span class="comment">//执行后: 10, 20</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pop-front-函数"><a href="#pop-front-函数" class="headerlink" title="pop_front()函数"></a>pop_front()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行前: </span></span><br><span class="line">mydeque.push_back (<span class="number">100</span>);</span><br><span class="line">mydeque.push_back (<span class="number">200</span>);</span><br><span class="line">mydeque.push_back (<span class="number">300</span>);</span><br><span class="line"><span class="comment">//执行后: 100, 200, 300</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 100, 200, 300</span></span><br><span class="line">mydeque.pop_front();</span><br><span class="line"><span class="comment">//执行后: 200, 300</span></span><br></pre></td></tr></table></figure></p>
<h3 id="insert-函数-3"><a href="#insert-函数-3" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++) mydeque.push_back(i); <span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = mydeque.begin();</span><br><span class="line">++it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5</span></span><br><span class="line">it = mydeque.insert (it,<span class="number">10</span>); </span><br><span class="line"><span class="comment">//执行后: 1, 10, 2, 3, 4, 5</span></span><br><span class="line"><span class="comment">// "it" now points to the newly inserted 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 10, 2, 3, 4, 5</span></span><br><span class="line">mydeque.insert (it,<span class="number">2</span>,<span class="number">20</span>);                     <span class="comment">// 1 20 20 10 2 3 4 5</span></span><br><span class="line"><span class="comment">//执行后: 1, 20, 20, 10, 2, 3, 4, 5</span></span><br><span class="line"><span class="comment">// "it" no longer valid!</span></span><br><span class="line"></span><br><span class="line">it = mydeque.begin()+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 20, 20, 10, 2, 3, 4, 5</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">2</span>,<span class="number">30</span>);</span><br><span class="line">mydeque.insert (it,myvector.begin(),myvector.end());</span><br><span class="line"><span class="comment">//执行后: 1, 20, 30, 30, 20, 10, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数-3"><a href="#erase-函数-3" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set some values (from 1 to 10)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) mydeque.push_back(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// erase the 6th element</span></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</span></span><br><span class="line">mydeque.erase (mydeque.begin()+<span class="number">5</span>);</span><br><span class="line"><span class="comment">//执行后: 1, 2, 3, 4, 5, 7, 8, 9, 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// erase the first 3 elements:</span></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 7, 8, 9, 10</span></span><br><span class="line">mydeque.erase (mydeque.begin(),mydeque.begin()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//执行后: 4, 5, 7, 8, 9, 10</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-5"><a href="#swap-函数-5" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">3</span>,<span class="number">100</span>);   <span class="comment">// three ints with a value of 100</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; bar (<span class="number">5</span>,<span class="number">200</span>);   <span class="comment">// five ints with a value of 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: foo [100, 100, 100]</span></span><br><span class="line"><span class="comment">//       bar [200, 200, 200, 200, 200]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">//执行后: foo [200, 200, 200, 200, 200]</span></span><br><span class="line"><span class="comment">//       bar [100, 100, 100]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-5"><a href="#遍历-5" class="headerlink" title="遍历"></a>遍历</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = mydeque.begin(); it!=mydeque.end(); ++it) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!mydeque.empty()) &#123;</span><br><span class="line">  sum+=mydeque.back();</span><br><span class="line">  mydeque.pop_back(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><h3 id="find-函数-1"><a href="#find-函数-1" class="headerlink" title="find()函数"></a>find()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中查询</span></span><br><span class="line"><span class="keyword">int</span> myints[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">std</span>::find (myints, myints+<span class="number">4</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (p != myints+<span class="number">4</span>)</span><br><span class="line">  <span class="comment">//输出: 30</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element not found in myints\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector中查询</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints,myints+<span class="number">4</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">it = find (myvector.begin(), myvector.end(), <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myvector.end())</span><br><span class="line">  <span class="comment">//输出: 30</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element not found in myvector\n"</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="copy-函数"><a href="#copy-函数" class="headerlink" title="copy()函数"></a>copy()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">7</span>);</span><br><span class="line"><span class="comment">//执行前: myvector: </span></span><br><span class="line"><span class="built_in">std</span>::copy ( myints, myints+<span class="number">7</span>, myvector.begin() );</span><br><span class="line"><span class="comment">//执行前: myvector: 10, 20, 30, 40, 50, 60, 70</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-6"><a href="#swap-函数-6" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>, y=<span class="number">20</span>;                              <span class="comment">// x:10 y:20</span></span><br><span class="line"><span class="comment">//执行前: x:10, y:20</span></span><br><span class="line"><span class="built_in">std</span>::swap(x,y);                              <span class="comment">// x:20 y:10</span></span><br><span class="line"><span class="comment">//执行后: x:20, y:10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">4</span>,x), bar (<span class="number">6</span>,y);       <span class="comment">// foo:4x20 bar:6x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: foo[20, 20, 20, 20]</span></span><br><span class="line"><span class="comment">//       bar[10, 10, 10, 10]</span></span><br><span class="line"><span class="built_in">std</span>::swap(foo,bar);                          <span class="comment">// foo:6x10 bar:4x20</span></span><br><span class="line"><span class="comment">//执行前: foo[20, 20, 20, 20]</span></span><br><span class="line"><span class="comment">//       bar[10, 10, 10, 10]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="count-函数-1"><a href="#count-函数-1" class="headerlink" title="count()函数"></a>count()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;   <span class="comment">// 8 elements</span></span><br><span class="line"><span class="comment">//记录数组myints中，10的个数</span></span><br><span class="line"><span class="keyword">int</span> mycount = <span class="built_in">std</span>::count (myints, myints+<span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//输出结果 mycount = 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);</span><br><span class="line"><span class="comment">//记录数组myvector中，20的个数</span></span><br><span class="line">mycount = <span class="built_in">std</span>::count (myvector.begin(), myvector.end(), <span class="number">20</span>);</span><br><span class="line"><span class="comment">//记录数组myvector中，20的个数</span></span><br></pre></td></tr></table></figure></p>
<h3 id="replace-函数"><a href="#replace-函数" class="headerlink" title="replace()函数"></a>replace()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">//执行前: myvector: []</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);            </span><br><span class="line"><span class="comment">//执行后: myvector: 10, 20, 30, 30, 20, 10, 10, 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: myvector: 10, 20, 30, 30, 20, 10, 10, 20</span></span><br><span class="line"><span class="built_in">std</span>::replace (myvector.begin(), myvector.end(), <span class="number">20</span>, <span class="number">99</span>); </span><br><span class="line"><span class="comment">//执行前: myvector: 10, 99, 30, 30, 99, 10, 10, 99</span></span><br></pre></td></tr></table></figure></p>
<h3 id="fill-函数"><a href="#fill-函数" class="headerlink" title="fill()函数"></a>fill()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行前 myvector: []</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">8</span>);                      </span><br><span class="line"><span class="comment">//执行后 myvector: 0,0,0,0,0,0,0,0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前 myvector: 0,0,0,0,0,0,0,0</span></span><br><span class="line"><span class="built_in">std</span>::fill (myvector.begin(),myvector.begin()+<span class="number">4</span>,<span class="number">5</span>);   </span><br><span class="line"><span class="comment">//执行后 myvector: 5,5,5,5,0,0,0,0</span></span><br><span class="line"><span class="comment">//执行后 myvector: 5,5,5,5,0,0,0,0</span></span><br><span class="line">  <span class="built_in">std</span>::fill (myvector.begin()+<span class="number">3</span>,myvector.end()<span class="number">-2</span>,<span class="number">8</span>); </span><br><span class="line"><span class="comment">//执行后 myvector: 5,5,5,8,8,8,0,0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="reverse-函数"><a href="#reverse-函数" class="headerlink" title="reverse()函数"></a>reverse()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; ++i) myvector.push_back(i);   <span class="comment">// 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1,2,3,4,5,6,7,8,9</span></span><br><span class="line"><span class="built_in">std</span>::reverse(myvector.begin(),myvector.end());    <span class="comment">// 9 8 7 6 5 4 3 2 1</span></span><br><span class="line"><span class="comment">//执行后: 9,8,7,6,5,4,3,2,1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort()函数"></a>sort()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j);&#125;</span><br><span class="line">&#125; myobject;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">32</span>,<span class="number">71</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">26</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">33</span>&#125;;</span><br><span class="line">  <span class="comment">//执行前: myvector: []</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);             </span><br><span class="line">  <span class="comment">//执行后: myvector: 32,71,12,45,26,80,53,33</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//缺省的排序是升序(&lt;)</span></span><br><span class="line">  <span class="comment">//执行前: 32,71,12,45,26,80,53,33</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin(), myvector.begin()+<span class="number">4</span>);          </span><br><span class="line">  <span class="comment">//执行后: 12,32,45,71,26,80,53,33</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行前: 12,32,45,71,26,80,53,33 using function as comp</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin()+<span class="number">4</span>, myvector.end(), myfunction); </span><br><span class="line">  <span class="comment">//执行后: 12,32,45,71,26,33,53,80</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// using object as comp</span></span><br><span class="line">  <span class="comment">//执行后: 12,32,45,71,26,33,53,80</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin(), myvector.end(), myobject);   </span><br><span class="line">  <span class="comment">//执行后: 12,26,32,33,45,53,71,80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="merge函数"><a href="#merge函数" class="headerlink" title="merge函数"></a>merge函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将两个有序的组合sort1[], sort2[]。归并成一个新的有序组合。</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> first[] = &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> second[] = &#123;<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort (first,first+<span class="number">5</span>);</span><br><span class="line"><span class="built_in">std</span>::sort (second,second+<span class="number">5</span>);</span><br><span class="line"><span class="comment">//执行前: first: 5,10,15,20,25</span></span><br><span class="line"><span class="comment">//       second: 10,20,30,40,50</span></span><br><span class="line"><span class="comment">//       v:[]</span></span><br><span class="line"><span class="built_in">std</span>::merge (first,first+<span class="number">5</span>,second,second+<span class="number">5</span>,v.begin());</span><br><span class="line"><span class="comment">//执行后: first: 5,10,15,20,25</span></span><br><span class="line"><span class="comment">//       second: 10,20,30,40,50</span></span><br><span class="line"><span class="comment">//       v:5,10,10,15,20,20,25,30,40,50</span></span><br></pre></td></tr></table></figure></p>
<h3 id="min-函数"><a href="#min-函数" class="headerlink" title="min()函数"></a>min()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出: 1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min(1,2)=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>  </span><br><span class="line"><span class="comment">//输出: 1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min(2,1)=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="number">2</span>,<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 'a'</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min('a','z')=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="string">'a'</span>,<span class="string">'z'</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 2.72</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min(3.14,2.72)=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="number">3.14</span>,<span class="number">2.72</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="max-函数"><a href="#max-函数" class="headerlink" title="max()函数"></a>max()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出: 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(1,2)=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>  </span><br><span class="line"><span class="comment">//输出: 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(2,1)=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="number">2</span>,<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 'z'</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max('a','z')=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="string">'a'</span>,<span class="string">'z'</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 3.14</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(3.14,2.72)=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="number">3.14</span>,<span class="number">2.72</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>图论算法记录</title>
    <url>/2019/11/03/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>主要以有向加权图为主，涉及到 <strong>图的几种常见表示方法</strong>、<strong>拓扑排序</strong>、<strong>弗洛伊德算法(Floyd)算法</strong>、 <strong>狄克斯特拉(dijkstra)算法</strong>、 <strong>SPFA算法</strong>、<strong>贝尔曼-福特(Bellman-Ford)算法</strong></p>
<a id="more"></a>
<h2 id="图的常见表示方法"><a href="#图的常见表示方法" class="headerlink" title="图的常见表示方法"></a>图的常见表示方法</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151010.png" heigt='400' width='400'/></p>
<h3 id="1-邻接矩阵："><a href="#1-邻接矩阵：" class="headerlink" title="1. 邻接矩阵："></a>1. 邻接矩阵：</h3><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151027.png" heigt='400' width='400'/></p>
<h3 id="2-邻接表："><a href="#2-邻接表：" class="headerlink" title="2. 邻接表："></a>2. 邻接表：</h3><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151035.png" heigt='400' width='400'/></p>
<h3 id="3-边缘列表"><a href="#3-边缘列表" class="headerlink" title="3. 边缘列表"></a>3. 边缘列表</h3><p>在刷题的时候经常以这种形式给出，可以将其转换乘邻接表或者邻接矩阵</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151044.png" heigt='350' width='350'/></p>
<p><a href="https://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">完整</a></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/ca22fa351d5278e95c4c8c94aba6da42ae45d465ff3e8e82149777274293e194-0210.gif" alt=""></p>
<p>其简单思路就是先找到入度为0 的节点，并将该节点放入队列中，同时将与他相邻的节点的入度减一，以此往复，如果最后所有节点的入度都为零则说明可以完成拓扑排序，否则该图不能进行拓扑排序</p>
<p>具体的算法流程如下：</p>
<ol>
<li><p>在算法开始前，扫描对应的存储空间(使用邻接表)，将入度为 0 的节点放入队列中</p>
</li>
<li><p>只要队列非空，就从队首取出入度为0 的节点，并且将这个结点的所有邻接结点（它指向的结点）的入度减1，在减 1 以后，如果这个被减 1 的结点的入度为 0 ，就继续入队。</p>
</li>
<li><p>队列为空时，检查结果集是否满足要求</p>
</li>
</ol>
<p>除了需要保存入度为0 的队列，还需要两个辅助的数据结构：</p>
<pre><code>1). 邻接表：通过节点的索引，能够得到这个节点的后继节点；

2). 入度数组：通过节点的索引能够得到指向这个节点的节点个数
</code></pre><h3 id="leetcode207-课程表"><a href="#leetcode207-课程表" class="headerlink" title="leetcode207 课程表"></a>leetcode207 课程表</h3><ul>
<li>题目描述：</li>
</ul>
<p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p>
<ul>
<li><p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）</p>
</li>
</ul>
<p>链接：<a href="https://leetcode-cn.com/problems/course-schedule" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule</a></p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<ul>
<li>解题</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//输入prerequisites是边缘列表</span></span><br><span class="line">    <span class="keyword">int</span> clen = prerequisites.size(); <span class="comment">//课程的长度</span></span><br><span class="line">    <span class="keyword">if</span> (clen == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 课程长度为零，所以肯定可以学习完</span></span><br><span class="line">    <span class="comment">//1.初始化入度的数组 和 邻接表数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses); <span class="comment">//入度数组，初始化为0</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(numCourses); <span class="comment">//邻接表数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clen; ++i) &#123;</span><br><span class="line">        indegree[prerequisites[i][<span class="number">0</span>]] += <span class="number">1</span>;  <span class="comment">//统计每个顶点的度</span></span><br><span class="line">        adj[prerequisites[i][<span class="number">1</span>]].push_back(prerequisites[i][<span class="number">0</span>]); <span class="comment">// 创建邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 创建队列，在拓扑排序之前，将所有入度为0的顶点存入队列中</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; myqueue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">            myqueue.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 开始拓扑排序，主要是遍历前面的邻接表，然后找到表中顶点对应的入度，对入度减一操作，若检测到入度为0时则推入队列中，准备输出（删除）</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!myqueue.empty()) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">int</span> top = myqueue.front(); <span class="comment">// 得到首元素</span></span><br><span class="line">        myqueue.pop();  <span class="comment">//删除首元素</span></span><br><span class="line">        <span class="comment">//vector&lt;int&gt; tmp = adj[top];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = adj[top].begin(); iter != adj[top].end(); ++iter) &#123;</span><br><span class="line">            --indegree[*iter];</span><br><span class="line">            <span class="keyword">if</span> (indegree[*iter] == <span class="number">0</span>)</span><br><span class="line">                myqueue.push(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode210-课程表2"><a href="#leetcode210-课程表2" class="headerlink" title="leetcode210 课程表2"></a>leetcode210 课程表2</h3><p>和前面一样不同的是需要把课程表输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisities) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">//1. 初始化入度数组和邻接表'</span></span><br><span class="line">    <span class="keyword">if</span> (prerequisities.size() == <span class="number">0</span>) &#123;  <span class="comment">// 如果prerequisities大小为零，没有特别说明课程完成的先后顺序，则所有课程都能完成</span></span><br><span class="line">        <span class="keyword">while</span>(numCourses &gt;<span class="number">0</span>)</span><br><span class="line">            res.push_back(--numCourses);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses); <span class="comment">//入度数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(numCourses); <span class="comment">//邻接表数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisities.size(); ++i) &#123;</span><br><span class="line">        indegree[prerequisities[i][<span class="number">0</span>]] += <span class="number">1</span>;  <span class="comment">// 入度+1</span></span><br><span class="line">        adj[prerequisities[i][<span class="number">1</span>]].push_back(prerequisities[i][<span class="number">0</span>]); <span class="comment">// 扩展邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 创建队列，将度为0的元素推入队列中</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Myqueue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">            Myqueue.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 统计每个顶点的度，判断是否为零，减一和push进入队列中</span></span><br><span class="line">    <span class="keyword">while</span> (!Myqueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = Myqueue.front();</span><br><span class="line">        res.push_back(top);</span><br><span class="line">        Myqueue.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = adj[top].begin(); iter != adj[top].end(); ++iter) &#123;</span><br><span class="line">            --indegree[*iter];</span><br><span class="line">            <span class="keyword">if</span> (indegree[*iter] == <span class="number">0</span>)</span><br><span class="line">                Myqueue.push(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.size() != numCourses)</span><br><span class="line">        res = &#123;&#125;;  <span class="comment">// 输出空数组</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="弗洛伊德算法-Floyd"><a href="#弗洛伊德算法-Floyd" class="headerlink" title="弗洛伊德算法(Floyd)"></a>弗洛伊德算法(Floyd)</h2><p>弗洛伊德算法是经典的 <strong>多源最短路径</strong> 算法，可以正确处理有向图或有向图的负权，但不可存在负权回路的最短路径问题，同时也被用于计算有向图的传递闭包。 </p>
<ul>
<li>大概思路：</li>
</ul>
<p>定义两个二维矩阵D和P， D记录顶点间的最小路径，P记录顶点间最小路径中的中转点<br>通过三重循环，k为中转点，v为起点，w为终点，循环比较D[v][w] 和 D[v][k]+D[k][w]最小值，如果后者更小则替换前者</p>
<ul>
<li>具体：</li>
</ul>
<p>矩阵 D 记录顶点间的最小路径<br>例如 D[0][3]= 10，说明顶点 0  到  3  的最短路径为 10；<br>矩阵 P 记录顶点间最小路径中的中转点<br>例如 P[0][3]= 1  说明，0  到  3 的最短路径轨迹为：0 -&gt; 1 -&gt; 3。<br>它通过 3 重循环，k 为中转点，v 为起点，w 为终点，循环比较 D[v][w]  和  D[v][k] + D[k][w]最小值，如果 D[v][k] + D[k][w]  为更小值，则把 D[v][k] + D[k][w]  覆盖保存在 D[v][w]中。</p>
<ul>
<li>步骤演示：</li>
</ul>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/Floyd算法.PNG" height='800' width='400'/></p>
<p><a href="https://www.cnblogs.com/dzzy/p/5097009.html" target="_blank" rel="noopener">图片来源</a></p>
<h3 id="leetcode743-网络延迟时间"><a href="#leetcode743-网络延迟时间" class="headerlink" title="leetcode743 网络延迟时间"></a>leetcode743 网络延迟时间</h3><p>输入： times[i] = (u,v,w)，分别表示源节点、目标节点、它们之间的传递时间；  N：网络节点的个数， K表示测试时的起始节点<br>范围： N:[1,100], K:[1,N], times:[1,6000], 1 &lt;= u,v&lt;= N ,0 &lt;= w &lt;= 100<br>输出： 如果可以使所有节点都收到信号则返回总的时间，如果不能则返回-1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime_Floyd</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建二维稀疏矩阵表示 ==&gt; 邻接矩阵</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">-1</span>)); <span class="comment">// 创建二维vector 并初始化为-1表示永远不会到达</span></span><br><span class="line">    <span class="comment">//填充邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        v[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">        v[times[i][<span class="number">0</span>]][times[i][<span class="number">1</span>]] = times[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接下来进入Floyd算法的三重循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N ; ++k) &#123;  <span class="comment">//这里的小k表示的就是中间节点，尝试使用每个中间节点进行替换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">                <span class="comment">//当满足下面的条件时，使用中间节点进行替换</span></span><br><span class="line">                <span class="comment">//1. 中间节点不为-1，即i -&gt; k 和 k -&gt; j 这条有向边是存在的</span></span><br><span class="line">                <span class="comment">//2. 在满足条件1 的基础上，经过中间节点花费的时间可以比原来小，或者 原来的有向边不存在</span></span><br><span class="line">                <span class="keyword">if</span> (v[i][k] != <span class="number">-1</span> &amp;&amp; v[k][j] != <span class="number">-1</span> &amp;&amp; (v[i][j] &gt; v[i][k] + v[k][j] || v[i][j] == <span class="number">-1</span>))</span><br><span class="line">                    v[i][j] = v[i][k] + v[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过上面的三重循环，就将每个节点之间的最短通路找到了（如果存在的话）</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//因为最后的结果是要返回从该节点K出发遍历所有节点所花费的时间</span></span><br><span class="line">    <span class="comment">//所以首先判断是否为-1以此判断K是否可以联通所有节点，如果存在存在-1说明此路不通直接返回-1；</span></span><br><span class="line">    <span class="comment">//否则，将最大的那个值输出，因为最大值表示从K出发经过了所有的节点累加得到的路径长度，符合最后的要求</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[K][i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//说明这个节点是走不通的</span></span><br><span class="line">        res = max(res, v[K][i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="狄克斯特拉算法-Dijkstra"><a href="#狄克斯特拉算法-Dijkstra" class="headerlink" title="狄克斯特拉算法(Dijkstra)"></a>狄克斯特拉算法(Dijkstra)</h2><p>最经典的 <strong>单源最短路径</strong> (一个点到其余各个顶点的最短路径)算法，适用于边权为正的无向和有向图，不适用于有负边权的图.</p>
<p>基本思想：</p>
<p>每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。</p>
<p>基本步骤：</p>
<ol>
<li><p>将所有顶点分为两部分：已知最短路程的顶点集合P和未知最短路程的顶点集合Q。最开始，已知最短路径的顶点集合P中只有源点一个顶点。这里使用一个book[i]数组来记录哪些点在集合P中。例如对于某个顶点i，如果book[i]=1则表示这个顶点在集合P中，book[i]=0则表示这个顶点在集合Q中；</p>
</li>
<li><p>设置源点s到自己的最短路径为0即dis=0。若存在源点能直接到达顶点i，则把dis[i]设为e[s][i]，同时把所有其它（源点不能直接到达的）顶点的最短路径设置为 $ \infty$；</p>
</li>
<li><p>在集合Q的所有顶点选择一个离源点s最近的顶点u（即dis[u]最小）加入到集合P。并考察所有以点u为起点的边，对每一条边进行松弛操作。例如存在一条边从 u到v的边，那么可以通过将边 u -&gt; v添加到尾部来拓展一条从s 到v的路径，这条路径的长度是 dis[u]+e[u][v]，如果这个值比目前已知的dis[v]的值要小，可以用这个新值代替dis[v]中的值；</p>
</li>
<li><p>重复第三步，如果集合Q为空，算法结束。最终dis 数组中的值就是源点到所有顶点的最短路径。</p>
</li>
</ol>
<ul>
<li>步骤演示：</li>
</ul>
<p>给出下图：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.1.png" alt=""></p>
<p>创建邻接矩阵：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.2.png" alt=""></p>
<p>使用一个一维数组dis存储1号顶点到其余各个顶点的初始路程:</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.3.png" alt=""></p>
<p>找到离1号顶点最近的顶点，首先就是其本身，因为其操作没有特殊性，直接参考后续步骤。然后找到的最近顶点为2，然后查看2号顶点的出边有： 2-&gt;3, 2-&gt;4这两条边。先讨论2-&gt;3这条边能否让1号顶点到3号顶点的路程变短，也就是比较dis[3] 和 dis[2] + e[2][3]的大小，发现 12 &gt; 1+9，所以dis[3]更新为10,同理分析 2-&gt;4这条边， dis[4] = $ \infty$ &gt; dis[2] + e[2][4] = 4 所以dis[4] = 4，dis更新如下：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.4.png" alt=""></p>
<p>继续在 3,4,5,6顶点中查找离1号顶点最近的点，发现是4号顶点，其出边为 4-&gt;3, 4-&gt;5, 4-&gt;6。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于4 -&gt;3 ,dis[3] = 10 &gt; dis[4] + e[4][3] = 8,故 dis[3]更新为8;</span><br><span class="line">对于4-&gt;5, dis[5] = inf &gt; dis[4] + e[4][5] = 17, 故 dis[5] = 17;</span><br><span class="line">同理 dis[6] = 19</span><br></pre></td></tr></table></figure><br>所以dis更新如下：<br><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.5.png" alt=""></p>
<p>继续在3,5,6中查找离1号顶点最近的点，发现是3号顶点，其出边为 3-&gt;5。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 -&gt; 5， dis[5] = 17 &gt; dis[3] + e[3][5] = 13，故dis[5] = 13</span><br></pre></td></tr></table></figure><br>所以dis更新如下：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.6.png" alt="">（图中6号节点对应的19，背景应该是白色的）</p>
<p>继续在5,6中查找，最近点为5，其出边为 5-&gt;6：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5-&gt;6, dis[6] = 19 &gt; dis[5] + e[5][6] = 17，dis[6] = 17</span><br></pre></td></tr></table></figure></p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.7.png" alt=""></p>
<p>最后对顶点6进行松弛，发现没有出边故不处理，最终dis数组如下，这便是1号顶点到其余各个顶点的最短路径：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.8.png" alt=""></p>
<p><a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="leetcode743-网络延时时间"><a href="#leetcode743-网络延时时间" class="headerlink" title="leetcode743 网络延时时间"></a>leetcode743 网络延时时间</h3><p>前面使用了Floyd算法求解，这里使用Dijkstra算法求解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime_Dijkstra</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建邻接矩阵</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">-1</span>)); <span class="comment">//使用-1代替无穷大值，可能会有些许麻烦，之后尝试替换为 MAX_INT</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">        v[times[i][<span class="number">0</span>]][times[i][<span class="number">1</span>]] = times[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; S(N + <span class="number">1</span>, <span class="number">-1</span>), T(N + <span class="number">1</span>, <span class="number">-1</span>); <span class="comment">//S为确定数组，T为估计数组</span></span><br><span class="line">    <span class="comment">//根据单源节点填充数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[K][i] != <span class="number">-1</span>)</span><br><span class="line">            T[i] = v[K][i];</span><br><span class="line">    &#125;</span><br><span class="line">    T[K] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到距离单元节点最短距离的节点</span></span><br><span class="line">    <span class="keyword">int</span> minVal = <span class="number">-1</span>,minIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; ++c) &#123;</span><br><span class="line">        minVal = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (T[i] != <span class="number">-1</span> &amp;&amp; S[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minVal == <span class="number">-1</span> || T[i] &lt; minVal) &#123;</span><br><span class="line">                    minVal = T[i];</span><br><span class="line">                    minIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        S[minIndex] = minVal; <span class="comment">// 确定值</span></span><br><span class="line">        <span class="comment">// 以这个节点(minIndex)出发，找到其每个出边，并和原始距离进行比较，更新数组 T(估计数组)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[minIndex][i] != <span class="number">-1</span> &amp;&amp; (minVal + v[minIndex][i] &lt; T[i] || T[i] == <span class="number">-1</span>))</span><br><span class="line">                T[i] = minVal + v[minIndex][i]; <span class="comment">// 估计值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        res = max(res, S[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里使用-1 代替了 inf ，后续尝试修改成inf</span></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/network-delay-time/solution/c-bellman-forddijkstrafloydspfa-by-gez1994/" target="_blank" rel="noopener">解题参考</a></p>
<h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>SPFA算法是 <strong>单源最短路径</strong> 算法，是Bellman-ford队列优化，和BFS的关系密切，相较于狄克斯特拉算法，<strong>边的权重可以是负数</strong>、实现简单，但是时间复杂度过高。</p>
<ul>
<li>基本思路：</li>
</ul>
<p>使用一个先进先出的队列保存待优化的节点，优化时每次取出队首的节点 u ，并且对于 u 的所有出边所指向的节点v进行松弛操作，如果 v 点的最短路径估计值有所调整且v 点不在当前队列中，就将 v 点放入队尾。这样不断从队列中取出节点来进行松弛操作，直至队列为空。</p>
<ul>
<li>步骤：</li>
</ul>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103124821.png"/></p>
<h3 id="leetcode743-网络延时时间-1"><a href="#leetcode743-网络延时时间-1" class="headerlink" title="leetcode743 网络延时时间"></a>leetcode743 网络延时时间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networdDelay_SPFA</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T(N + <span class="number">1</span>, <span class="number">-1</span>);  <span class="comment">//估计值</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Flag(N + <span class="number">1</span>, <span class="number">-1</span>);  <span class="comment">// 用来标记节点是否在队列中</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Myqueue;  <span class="comment">//队列</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">        v[times[i][<span class="number">0</span>]][times[i][<span class="number">1</span>]] = times[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i)</span><br><span class="line">        v[i][i] = <span class="number">0</span>;</span><br><span class="line">    T[K] = <span class="number">0</span>;</span><br><span class="line">    Myqueue.push(K);  </span><br><span class="line">    Flag[K] = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">while</span> (!Myqueue.empty()) &#123;  <span class="comment">//只要队列不为空就一直循环</span></span><br><span class="line">        <span class="keyword">int</span> u = Myqueue.front();</span><br><span class="line">        Myqueue.pop();</span><br><span class="line">        Flag[u] = <span class="number">-1</span>; <span class="comment">//此时tmp 不在队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[u][i] != <span class="number">-1</span> &amp;&amp;( T[i] &gt; T[u] + v[u][i]  ||  T[i] == <span class="number">-1</span>))&#123;</span><br><span class="line">                T[i] = T[u] + v[u][i];</span><br><span class="line">                <span class="keyword">if</span> (Flag[i] == <span class="number">-1</span>) &#123;<span class="comment">//说明此时这个节点i不在队列中</span></span><br><span class="line">                    Myqueue.push(i);</span><br><span class="line">                    Flag[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        res = max(res, T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="贝尔曼-福特算法-Bellman-Ford"><a href="#贝尔曼-福特算法-Bellman-Ford" class="headerlink" title="贝尔曼-福特算法(Bellman-Ford)"></a>贝尔曼-福特算法(Bellman-Ford)</h2><p><a href="https://juejin.im/post/5b77fec1e51d4538cf53be68" target="_blank" rel="noopener">参考</a></p>
<p>其原理是对图进行最多n-1次松弛操作，得到所有可能的最短路径。其边的权重可以是负数，实现简单但是复杂度过高，复杂度为$O(NE)$ 其中N为顶点个数，E为边数。</p>
<p>基本思路：</p>
<ol>
<li><p>初始化时将起点s 到各顶点v的距离dis(s-&gt;v)赋值为 $\infty$，dis(s-&gt;s)赋值为0；</p>
</li>
<li><p>后续进行最多n-1 次遍历，对所有边进行松弛操作；</p>
</li>
<li><p>遍历都结束，若再进行一次遍历，还能得到s 到某些节点更短路径的话，就说明存在负环路（负环路会随着遍历次数的增加而不断减小）</p>
</li>
</ol>
<p>思路上与狄克斯特拉算法最大的不同是每次都是从源点s 重新出发进行 “松弛”更新操作，而狄克斯特拉算法则是从源点出发向外扩逐个处理相邻（最近）的节点。</p>
<h3 id="leetcode743-网络延时时间-2"><a href="#leetcode743-网络延时时间-2" class="headerlink" title="leetcode743 网络延时时间"></a>leetcode743 网络延时时间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. Bellman-Ford算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networdDelay_BellmanFord</span><span class="params">(<span class="built_in">vector</span> &lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T(N + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    T[K] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N - <span class="number">1</span>; ++c) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> src = times[i][<span class="number">0</span>], target = times[i][<span class="number">1</span>], dis = times[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (T[src] != <span class="number">-1</span> &amp;&amp; (T[src] + dis &lt; T[target] || T[target] == <span class="number">-1</span>)) &#123;</span><br><span class="line">                T[target] = T[src] + dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        res = max(res, T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
