<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CUDA组织并行线程</title>
    <url>/2019/11/09/CUDA%E7%BB%84%E7%BB%87%E5%B9%B6%E8%A1%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>CUDA编程中最重要的一环就是如何让数据并行计算，要想实现较为高效的并行计算就需要在CUDA编程时手动为每个数据分配线程，这就涉及到如何在不同的grid 和 block 中计算出合适线程的id号。</p>
<a id="more"></a>
<h2 id="CUDA组织并行线程"><a href="#CUDA组织并行线程" class="headerlink" title="CUDA组织并行线程"></a>CUDA组织并行线程</h2><p><a href="https://face2ai.com/cuda-f-2-3-%e7%bb%84%e7%bb%87%e5%b9%b6%e8%a1%8c%e7%ba%bf%e7%a8%8b/" target="_blank" rel="noopener">文章参考</a></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>CUDA编程中最重要的一环就是如何让数据并行计算，要想实现较为高效的并行计算就需要在CUDA编程时手动为每个数据分配线程，这就涉及到如何在不同的grid 和 block 中计算出合适线程的id号。</p>
<p>回顾GPU中一个 kernel 的大致框架：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/b8b1bdfda485204b59c940daf0f2fc7.jpg"/></p>
<p>所在一般在编程时需要事先声明grid, block, thread的大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">4</span>,<span class="number">2</span>)</span></span>;  <span class="comment">// 声明一个 block 其中包含 4 行 2 列 = 8 个线程</span></span><br><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;  <span class="comment">// 声明一个 grid 其中包含 2 行 3 列 = 6 个block</span></span><br><span class="line"><span class="comment">// 所以总共可分配的线程数为： 8 * 6 = 48 个</span></span><br></pre></td></tr></table></figure>
<p>所以在得到一个block中一个线程的索引号（threadIdx）后，需要还需要根据 gridDim. gridIdx, blockDim, blockIdx 计算获得其全局的索引号。详细: <a href="https://blog.csdn.net/hujingshuang/article/details/53097222#commentBox" target="_blank" rel="noopener">grid、block、thread的关系及thread索引的计算</a></p>
<p>这边以简单的二维block为例介绍：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191108160350.png"/></p>
<p>计算方式就如图中所示。</p>
<p>因为CUDA 每一个线程执行相同的代码，就是异构计算中的多线程单指令， 如果每个不同的线程执行同样的代码，又处理同一组数据，CUDA常用的做法是让不同的线程对应不同的数据，也就是用线程的全局全局标号对应不同组的数据。因为无论时设备还是主机内存都是线性存在的，比如二维矩阵 $(8 \times 6)$， 存储在内存中可能就是如下结构：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191108164506.png"/></p>
<p>我们要做的管理就是：</p>
<ul>
<li><p>矩阵和块索引（计算线程的全局索引）；</p>
</li>
<li><p>计算矩阵中给定点的坐标 (ix, iy);</p>
</li>
<li><p>(ix, iy) 对应的线性内存的位置；</p>
</li>
</ul>
<p>线性位置的计算方式：</p>
<script type="math/tex; mode=display">idx = ix + iy \times nx</script><p>这样的分配方式就将数组矩阵中 (ix, iy) 位置处的数据分配到线程标号为 ix,iy 处去计算。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>随机生成一个 6 行 8列的数组，总共有 48 个数字，如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191108170505.png"/></p>
<p>实际内存是一维线性的，如下：</p>
<script type="math/tex; mode=display">[29.6 , ... , 22.16 , 26.49 , ... , 23.45 , 30.92 , ... , ...]</script><p>block 和 grid 的大小为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">blcok</span><span class="params">(<span class="number">4</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个二维block和 二维线程，即使用 2 x 3 个block ，每个 block中再开辟 4x 2 个线程， 则 2 x 3 x 4 x 2 = 48，然后将这48个数字分配进去，每个数字一个线程,就相当于每个线程进行一个数字的操作，进行的计算的并行化。</p>
<p>有如下形式：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/451431f889b05d3ae630d32f175a126.jpg"/></p>
<p>按照下面的方式打印索引：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">printThreadIndex</span><span class="params">(<span class="keyword">float</span> *A, <span class="keyword">const</span> <span class="keyword">int</span> nx, <span class="keyword">const</span> <span class="keyword">int</span> ny)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ix = threadIdx.x + blockIdx.x*blockDim.x;  </span><br><span class="line">	<span class="keyword">int</span> iy = threadIdx.y + blockIdx.y*blockDim.y;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> idx = iy * nx + ix; </span><br><span class="line"><span class="comment">//nx = 8, ny= 6 在进一步计算全局线程标号，是为了将这48个数据分别匹配到不同的线程中去</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread_id(%d,%d) block_id(%d,%d) coordinate(%d,%d)"</span></span><br><span class="line">		<span class="string">"global index %2d ival %2d\n"</span>, threadIdx.x, threadIdx.y,</span><br><span class="line">		blockIdx.x, blockIdx.y, ix, iy, idx, A[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dim3 blcok(4,2);</span></span><br><span class="line"><span class="comment">//dim3 grid(2,3);</span></span><br><span class="line"><span class="comment">//int nx = 8;</span></span><br><span class="line"><span class="comment">//int ny = 6;</span></span><br><span class="line">printThreadIndex &lt;&lt; &lt;grid, block &gt;&gt; &gt; (A_dev, nx, ny);</span><br></pre></td></tr></table></figure>
<p>对应的计算示意图如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/a8de254c0be85b7d778bef29d5b33ca.jpg"/></p>
<p>程序打印输出结果如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191108232742.png"/></p>
<p>设置不同的block或者 grid大小，计算的性能也会不一样的，如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191109132806.png"/></p>
<p>可以看到在GPU上计算明显比CPU上计算快很多。</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>时间计算的比较：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cuda_runtime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"device_launch_parameters.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"freshman.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sumMatrix2D_CPU</span><span class="params">(<span class="keyword">float</span> * MatA, <span class="keyword">float</span> * MatB, <span class="keyword">float</span> * MatC, <span class="keyword">int</span> nx, <span class="keyword">int</span> ny)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> * a = MatA;</span><br><span class="line">	<span class="keyword">float</span> * b = MatB;</span><br><span class="line">	<span class="keyword">float</span> * c = MatC;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ny; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nx; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			c[i] = a[i] + b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		c += nx;</span><br><span class="line">		b += nx;</span><br><span class="line">		a += nx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">sumMatrix</span><span class="params">(<span class="keyword">float</span> * MatA, <span class="keyword">float</span> * MatB, <span class="keyword">float</span> * MatC, <span class="keyword">int</span> nx, <span class="keyword">int</span> ny)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ix = threadIdx.x + blockDim.x*blockIdx.x;</span><br><span class="line">	<span class="keyword">int</span> iy = threadIdx.y + blockDim.y*blockIdx.y;</span><br><span class="line">	<span class="keyword">int</span> idx = ix + iy * ny;</span><br><span class="line">	<span class="keyword">if</span> (ix &lt; nx &amp;&amp; iy &lt; ny)</span><br><span class="line">	&#123;</span><br><span class="line">		MatC[idx] = MatA[idx] + MatB[idx];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"strating...\n"</span>);</span><br><span class="line">	initDevice(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> nx = <span class="number">1</span> &lt;&lt; <span class="number">12</span>;  <span class="comment">//2**12 = 4096</span></span><br><span class="line">	<span class="keyword">int</span> ny = <span class="number">1</span> &lt;&lt; <span class="number">12</span>;  <span class="comment">//2**12 = 4096</span></span><br><span class="line">	<span class="keyword">int</span> nxy = nx * ny;  <span class="comment">// 4096 * 4096</span></span><br><span class="line">	<span class="keyword">int</span> nBytes = nxy * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);  <span class="comment">// nxy 共占用多少个字节</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Malloc</span></span><br><span class="line">	<span class="keyword">float</span>* A_host = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);  <span class="comment">// 分配指针空间</span></span><br><span class="line">	<span class="keyword">float</span>* B_host = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">	<span class="keyword">float</span>* C_host = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">	<span class="keyword">float</span>* C_from_gpu = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">	initialData(A_host, nxy);</span><br><span class="line">	initialData(B_host, nxy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cudaMalloc</span></span><br><span class="line">	<span class="keyword">float</span> *A_dev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">float</span> *B_dev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">float</span> *C_dev = <span class="literal">NULL</span>;</span><br><span class="line">	CHECK(cudaMalloc((<span class="keyword">void</span>**)&amp;A_dev, nBytes));</span><br><span class="line">	CHECK(cudaMalloc((<span class="keyword">void</span>**)&amp;B_dev, nBytes));</span><br><span class="line">	CHECK(cudaMalloc((<span class="keyword">void</span>**)&amp;C_dev, nBytes));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	CHECK(cudaMemcpy(A_dev, A_host, nBytes, cudaMemcpyHostToDevice));</span><br><span class="line">	CHECK(cudaMemcpy(B_dev, B_host, nBytes, cudaMemcpyHostToDevice));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> dimx = <span class="number">32</span>;</span><br><span class="line">	<span class="keyword">int</span> dimy = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cpu compute</span></span><br><span class="line">	cudaMemcpy(C_from_gpu, C_dev, nBytes, cudaMemcpyDeviceToHost);</span><br><span class="line">	<span class="keyword">double</span> iStart = cpuSecond();</span><br><span class="line">	sumMatrix2D_CPU(A_host, B_host, C_host, nx, ny);</span><br><span class="line">	<span class="keyword">double</span> iElaps = cpuSecond() - iStart;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"CPU Execution Time elapsed %f sec\n"</span>, iElaps);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//==================================== 2d block and 2d grid ================================</span></span><br><span class="line">	<span class="function">dim3 <span class="title">block_0</span><span class="params">(dimx, dimy)</span></span>; <span class="comment">// blockDim.x = 32， blockDim.y = 32, threadIdx.x(y) in [0,31]</span></span><br><span class="line">	<span class="comment">// (nx - 1)/ block_0.x + 1 相当于 int(nx/block_0.x)</span></span><br><span class="line">	<span class="function">dim3 <span class="title">grid_0</span><span class="params">((nx - <span class="number">1</span>) / block_0.x + <span class="number">1</span>, (ny - <span class="number">1</span>) / block_0.y + <span class="number">1</span>)</span></span>; <span class="comment">//128， 128，  gridDim.x(y) = 128, blockIdx.x(y) in [0,128]</span></span><br><span class="line">	iStart = cpuSecond();</span><br><span class="line">	sumMatrix &lt;&lt; &lt;grid_0, block_0 &gt;&gt; &gt; (A_dev, B_dev, C_dev, nx, ny);</span><br><span class="line">	CHECK(cudaDeviceSynchronize());</span><br><span class="line">	iElaps = cpuSecond() - iStart;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"GPU Execution configuration grid and block shape: &lt;&lt;&lt;(%d,%d),(%d,%d)&gt;&gt;&gt; Time elapsed %f sec\n"</span>,</span><br><span class="line">		grid_0.x, grid_0.y, block_0.x, block_0.y, iElaps);</span><br><span class="line">	CHECK(cudaMemcpy(C_from_gpu, C_dev, nBytes, cudaMemcpyDeviceToHost));</span><br><span class="line">	checkResult(C_host, C_from_gpu, nxy);</span><br><span class="line">	<span class="comment">//============================================================================================</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//=====================================1d block and 1d grid ==================================</span></span><br><span class="line">	dimx = <span class="number">32</span>;</span><br><span class="line">	<span class="function">dim3 <span class="title">block_1</span><span class="params">(dimx)</span></span>;  <span class="comment">// 32</span></span><br><span class="line">	<span class="function">dim3 <span class="title">grid_1</span><span class="params">((nxy - <span class="number">1</span>) / block_1.x + <span class="number">1</span>)</span></span>;  <span class="comment">// (4096 * 4096 -1)/ 32 + 1 = 524288</span></span><br><span class="line">	iStart = cpuSecond();</span><br><span class="line">	sumMatrix &lt;&lt; &lt;grid_1, block_1 &gt;&gt; &gt; (A_dev, B_dev, C_dev, nx*ny, <span class="number">1</span>);</span><br><span class="line">	CHECK(cudaDeviceSynchronize());</span><br><span class="line">	iElaps = cpuSecond() - iStart;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"GPU Execution configuration grid and block shape: &lt;&lt;&lt;(%d,%d),(%d,%d)&gt;&gt;&gt; Time elapsed %f sec\n"</span>,</span><br><span class="line">		grid_1.x, grid_1.y, block_1.x, block_1.y, iElaps);</span><br><span class="line">	CHECK(cudaMemcpy(C_from_gpu, C_dev, nBytes, cudaMemcpyDeviceToHost));</span><br><span class="line">	checkResult(C_host, C_from_gpu, nxy);</span><br><span class="line">	<span class="comment">//============================================================================================</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//===================================== 2d block and 1d grid =================================</span></span><br><span class="line">	dimx = <span class="number">32</span>;</span><br><span class="line">	<span class="function">dim3 <span class="title">block_2</span><span class="params">(dimx)</span></span>; <span class="comment">// 32</span></span><br><span class="line">	<span class="function">dim3 <span class="title">grid_2</span><span class="params">((nx - <span class="number">1</span>) / block_2.x + <span class="number">1</span>, ny)</span></span>;  <span class="comment">// 128, 4096</span></span><br><span class="line">	iStart = cpuSecond();</span><br><span class="line">	sumMatrix &lt;&lt; &lt;grid_2, block_2 &gt;&gt; &gt; (A_dev, B_dev, C_dev, nx, ny);</span><br><span class="line">	CHECK(cudaDeviceSynchronize());</span><br><span class="line">	iElaps = cpuSecond() - iStart;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"GPU Execution configuration grid and block shape: &lt;&lt;&lt;(%d,%d),(%d,%d)&gt;&gt;&gt; Time elapsed %f sec\n"</span>,</span><br><span class="line">		grid_2.x, grid_2.y, block_2.x, block_2.y, iElaps);</span><br><span class="line">	CHECK(cudaMemcpy(C_from_gpu, C_dev, nBytes, cudaMemcpyDeviceToHost));</span><br><span class="line">	checkResult(C_host, C_from_gpu, nxy);</span><br><span class="line">	<span class="comment">//=============================================================================================</span></span><br><span class="line">	cudaFree(A_dev);</span><br><span class="line">	cudaFree(B_dev);</span><br><span class="line">	cudaFree(C_dev);</span><br><span class="line">	<span class="built_in">free</span>(A_host);</span><br><span class="line">	<span class="built_in">free</span>(B_host);</span><br><span class="line">	<span class="built_in">free</span>(C_host);</span><br><span class="line">	<span class="built_in">free</span>(C_from_gpu);</span><br><span class="line">	cudaDeviceReset();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程知识点</title>
    <url>/2019/11/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>在秋招过程中根据别人整理的网络编程知识点，进行的二次整理，主要是一些高频知识点。</p>
<a id="more"></a>
<h3 id="1-TCP协议的三次握手和四次挥手"><a href="#1-TCP协议的三次握手和四次挥手" class="headerlink" title="1. TCP协议的三次握手和四次挥手"></a>1. TCP协议的三次握手和四次挥手</h3><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191012142805.png"/></p>
<ul>
<li><p>三次握手：</p>
<ol>
<li><p>c -&gt; s, 客户端向服务端发送带有SYN（同步标识位=1）的报文段seq(序号=x),c进入<code>SYN_SENT</code>状态;</p>
</li>
<li><p>s -&gt; c, 服务端接收到客户端发来的报文，检测SYN=1，知道客户端想和自己建立连接，则返回带有SYN(=1)，ACK(确认标识位=x+1)的报文段seq(=y)，s进入<code>SYN_RCVD</code>状态；</p>
</li>
<li><p>c -&gt; s，客户端检查服务端发来的信息(SYN, ACK,seq)，再向其发送ACK(=y+1)，服务端接收后检查ACK是否为y+1，是则建立链接完成三次握手,c和s都进入<code>ESTABLISHED</code>状态。</p>
</li>
</ol>
</li>
<li><p>四次挥手：</p>
<ol>
<li><p>c -&gt; s, 客户端发送带有FIN(结束标识位)的seq(=x+2), ACK(=y+1)，告诉服务端要断开连接，进入<code>FIN_WAIT_1</code>状态；</p>
</li>
<li><p>s -&gt; c, 服务端接收到FIN报文后向客户端发送ACK(=x+3)，服务器进入<code>CLOSE_WAIT</code>状态，客户端收到后进入<code>FIN_WAIT_2</code>状态；</p>
</li>
<li><p>s -&gt; c, 当服务器发送完剩下的数据后，向客户端发送带有FIN的seq(=y+1)，并进入<code>LAST_ACK</code>状态；</p>
</li>
<li><p>c -&gt; s, 客户端向服务端发送ACK(=y+2)，进入<code>TIME_WAIT</code>状态，等待2MSL(报文段最大生存时间)，没有服务端响应则关闭连接。</p>
</li>
</ol>
</li>
</ul>
<h3 id="2-一定要三次握手的原因"><a href="#2-一定要三次握手的原因" class="headerlink" title="2. 一定要三次握手的原因"></a>2. 一定要三次握手的原因</h3><p>客户端和服务端建立连接时，由于某种原因长时间驻留在网络节点中，无法达到服务器，因为TCP存在 <strong>超时重传机制</strong> ，客户端会不断尝试建立连接，直到成功。假设后面成功建立连接，传输结束断开连接后，若之前客户端发送给的连接请求又被服务端接收，则服务端会以为客户端尝试再次建立连接，如果仅存在这两次握手，则服务端会同意与客户端建立连接，并一直等待客户端的响应，但实际客户端此时已经关闭，直到超出计数器的设定值，服务端才会认为服务异常，关闭这个连接，造成计算资源的浪费，而加入第三次握手的机制由于服务端没有等到客户端的再次响应则不会再建立该连接。</p>
<h3 id="3-挥手比握手多一次的原因"><a href="#3-挥手比握手多一次的原因" class="headerlink" title="3. 挥手比握手多一次的原因"></a>3. 挥手比握手多一次的原因</h3><p>因为建立连接时，可以把SYN,ACK,seq放在同一个报文中进行传输，但是在断开连接时，服务端需要先将剩余的数据传输结束后，才能再向客户端发送FIN标识位以请求关闭连接，通常这里的ACK报文和FIN报文是分开传输的。</p>
<h3 id="4-HTTP和HTTPS"><a href="#4-HTTP和HTTPS" class="headerlink" title="4. HTTP和HTTPS"></a>4. HTTP和HTTPS</h3><p>HTTP: 是互联网上一种广泛的网络协议，是 <strong>客户端和服务端请求和应答的标准</strong></p>
<p>HTTPS: 是以安全为目标的HTTP通道，即在HTTP的三次握手后加入SSL层，主要用于1) 建立安全通道保证数据传输的安全，2) 确认网站的安全性。</p>
<p><strong>区别</strong></p>
<ol>
<li><p>HTTP协议是超文本传输协议，信息是明文传输，而HTTPS协议传输的数据是经过加密的，具有更高的安全性；</p>
</li>
<li><p>端口不同前者为80，后者是443</p>
</li>
</ol>
<h3 id="5-IP地址和MAC地址"><a href="#5-IP地址和MAC地址" class="headerlink" title="5. IP地址和MAC地址"></a>5. IP地址和MAC地址</h3><p>IP地址是IP协议提供的统一的地址格式，为互联网上每一个网络和每一台主机分配一个逻辑地址，以屏蔽物理地址的差异</p>
<p>MAC地址是一个硬件地址，用来确认网络设备位置的地址，在OSI模型中右数据连接层负责。如果一台设备有多块网卡，则每个网卡都会有一个唯一的MAC地址。</p>
<h3 id="6-打开一个网站的过程，以及其对那个的各个层的过程"><a href="#6-打开一个网站的过程，以及其对那个的各个层的过程" class="headerlink" title="6. 打开一个网站的过程，以及其对那个的各个层的过程"></a>6. 打开一个网站的过程，以及其对那个的各个层的过程</h3><ol>
<li>域名解析，浏览器获得URL地址，向操作系统请求该URL地址的IP地址，操作系统查询DNS（先查询本地HOST文件，没有则查询网络）获得对应的IP地址；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL 分割成几个部分：协议(http(s),ftp)、网络协议(域名、IP地址、端口号)、资源路径</span><br></pre></td></tr></table></figure>
<ol>
<li>确认好IP地址和端口号后，向该IP地址对应的服务器的该端口号发起TCP连接请求；</li>
</ol>
<ol>
<li><p>服务接收到TCP连接请求后，回复可以建立连接；</p>
</li>
<li><p>浏览器收到回传的数据后，还会向服务端发送数据包，表示三次握手的结束</p>
</li>
<li><p>三次握手成功后，开始通讯，客户端根据HTTP协议的要求，组织一个请求的数据包，其中包含请求的资源路径、身份信息等，服务器响应请求，将数据返回给浏览器，浏览器根据HTML协议组织网页，以此反复；</p>
</li>
<li><p>渲染页面，响应用户的操作；</p>
</li>
<li><p>关闭网页时，断开连接。</p>
</li>
</ol>
<h3 id="7-OSI七层模型和TCP-IP四层模型，每层用到的协议"><a href="#7-OSI七层模型和TCP-IP四层模型，每层用到的协议" class="headerlink" title="7. OSI七层模型和TCP/IP四层模型，每层用到的协议"></a>7. OSI七层模型和TCP/IP四层模型，每层用到的协议</h3><h4 id="OSI-Opening-System-Interconnection-开放系统互连"><a href="#OSI-Opening-System-Interconnection-开放系统互连" class="headerlink" title="OSI(Opening System Interconnection 开放系统互连)"></a>OSI(Opening System Interconnection 开放系统互连)</h4><ul>
<li>第七层 应用层</li>
</ul>
<p>为应用软件而设的接口</p>
<pre><code>功能： 文件传输，电子邮件，文件服务等；

协议： HTTP，HTTPS，FTP
</code></pre><ul>
<li>第六层 表示层</li>
</ul>
<p>把数据转换为能与接收者的系统格式兼容并适合传输的格式</p>
<pre><code>功能： 数据格式化，代码转换，数据加密
</code></pre><ul>
<li>第五层 会话层</li>
</ul>
<p>负责在数据传输过程中设置和维护计算机网络中两台计算机之间的通信连接</p>
<pre><code>功能： 解除或建立与其他接点的联系
</code></pre><ul>
<li>第四层 传输层</li>
</ul>
<p>把传输表头加至数据以形成数据包。传输表头包含了所使用的协议等发送信息</p>
<pre><code>功能： 提供端对端的接口

协议： TCP, UDP
</code></pre><ul>
<li>第三层 网络层</li>
</ul>
<p>决定数据的路径选择和转寄，将网络表头(NH)加至数据包，以形成报文，网格表头包含了网络数据</p>
<pre><code>功能： 为数据包选择路由

协议： IP
</code></pre><ul>
<li>第二层 数据链路层</li>
</ul>
<p>负责网络寻址、错误侦测和改错</p>
<pre><code>功能： 传输有地址的帧，错误检测功能

协议： ARP, SLIP,RARP
</code></pre><ul>
<li>第一层 物理层</li>
</ul>
<p>在局部局域网上传送数据帧，负责管理计算机通信设备和网络媒体之间的互通，包括电压、网卡、主机接口卡等</p>
<pre><code>功能： 以二进制形式在物理媒体上传输数据

协议： ISO2110, IEEE802
</code></pre><h4 id="TCP-IP-4层网络模型"><a href="#TCP-IP-4层网络模型" class="headerlink" title="TCP/IP 4层网络模型"></a>TCP/IP 4层网络模型</h4><ul>
<li>第四层 应用层</li>
</ul>
<p>电子邮件，文件传输</p>
<p>网页访问使用http协议，文件传输FTP协议，电子邮件发送SMTP协议，域名解析DNS协议，远程登陆Talnet协议</p>
<ul>
<li>第三层 传输层</li>
</ul>
<p>TCP,UDP协议分析</p>
<ul>
<li>第二层 网络层</li>
</ul>
<p>检查IP地址，路由设置</p>
<ul>
<li>第一层 网络接口层</li>
</ul>
<p>ARP地址检测、物理连接检测</p>
<p>小结：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191012165823.png"/></p>
<h3 id="8-TCP和UDP"><a href="#8-TCP和UDP" class="headerlink" title="8. TCP和UDP"></a>8. TCP和UDP</h3><ol>
<li><p>TCP面向连接（如打电话要先拨号建立连接），UDP在发送数据之前不需要建立连接；</p>
</li>
<li><p>TCP更加可靠，TCP传输的数据无差错，不丢失，不重复；</p>
</li>
<li><p>UDP较好的实时性，工作效率比TCP高，适用于对高速传输和实时性较高的通信或广播通信；</p>
</li>
<li><p>每一条TCP连接只能是点对点； UDP支持一对一，一对多，多对一和多对多的交互通信；</p>
</li>
<li><p>TCP对系统资源要求较多，UDP对系统资源要求较少；</p>
</li>
<li><p>要求数据的完成性应该适用TCP，如文件的传输、重要状态的更新； 要求实时性使用UDP，如视频传输、实时通信；</p>
</li>
<li><p>TCP面向字节流，UDP面向数据包</p>
</li>
</ol>
<h3 id="9-TCP的拥塞控制"><a href="#9-TCP的拥塞控制" class="headerlink" title="9. TCP的拥塞控制"></a>9. TCP的拥塞控制</h3><ol>
<li><p>发送维护一个拥塞窗口，由小到达逐渐增加拥塞窗口，探测网络的拥塞程度</p>
</li>
<li><p>快重传和快恢， 要求接收方在收到一个失序的报文段后就立即发出重复确认而不要等到自己发送数据时捎带确认。</p>
</li>
</ol>
<h3 id="10-DNS干什么的"><a href="#10-DNS干什么的" class="headerlink" title="10. DNS干什么的"></a>10. DNS干什么的</h3><p>DNS(Domain Name System 域名系统)， 将域名和地址相互映射的一个分布式数据库，能够让人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p>主机解析域名的顺序：</p>
<p>找缓存、找本及的hosts文件、找DNS服务器</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191105212943.png"/></p>
<p><strong>根域名服务器</strong>：是互联网域名解析系统（DNS）中最高级别的域名服务器，负责返回顶级域的权威域名服务器地址，全球只有13台，中国境内是其镜像。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>常见神经网络模型量估计</title>
    <url>/2019/11/05/%E5%B8%B8%E8%A7%81%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E9%87%8F%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<p>对于常见的深度学习，如CNN,RNN,DNN,GRU,LSTM，如果可以在设计模型时就能设计出模型的参数量，那对于后续的性能优化、模型部署调优都会有一个直观上的感受和帮助。</p>
<a id="more"></a>
<h2 id="1-CNN参数个数"><a href="#1-CNN参数个数" class="headerlink" title="1. CNN参数个数"></a>1. CNN参数个数</h2><p>常见CNN模型一般包含以下几种类型的层：卷积层、池化层和全连接层。假设卷积核大小为H*W， input channel为I，out channel为O。</p>
<ol>
<li>卷积层(Convolutional Layer):</li>
</ol>
<p>该层filter数量总数为(H x W x I)，每个将被映射到新的输出通道上，加上每个filter的计算要有一个bias，所以总的参数数量为：(H x W x I + 1) x O</p>
<ol>
<li>池化层(Pooling Layer)：</li>
</ol>
<p>一般的池化层属于固定操作，没有权重传播</p>
<h2 id="2-全连接层参数个数"><a href="#2-全连接层参数个数" class="headerlink" title="2. 全连接层参数个数"></a>2. 全连接层参数个数</h2><p>前后是n,m维的输入输出，所以其参数数量为(n+1) x m</p>
<blockquote>
<p>以下循环神经网络均已单层为例</p>
</blockquote>
<h2 id="3-RNN参数个数"><a href="#3-RNN参数个数" class="headerlink" title="3. RNN参数个数"></a>3. RNN参数个数</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191105212219.png"/></p>
<p>图上W,U,V在RNN的每一步中都是共享的参数，所以其参数量为：</p>
<script type="math/tex; mode=display">Number = n^2+kn+nm</script><ul>
<li>n- 隐藏层的维度</li>
<li>k- 输出层的维度</li>
<li>m- 输入层的维度</li>
</ul>
<p>$n^2$ 就是 $W*W$部分<br>$kn$ 就是$WV$部分<br>$nm$ 就是$UW$部分</p>
<h2 id="4-LSTM参数个数"><a href="#4-LSTM参数个数" class="headerlink" title="4. LSTM参数个数"></a>4. LSTM参数个数</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191105210926.png"/></p>
<p>LSTM一共维护四套参数，分别对应输入门、输出门、遗忘门和候选态，总参数数量：</p>
<script type="math/tex; mode=display">Number = 4 * n * (m + 1 + n)</script><ul>
<li>n- 隐藏层的维度</li>
<li>m- 输入层的维度</li>
<li>1 表示的是偏置项</li>
</ul>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line">rnn = nn.LSTM(input_size=<span class="number">100</span>, hidden_size=<span class="number">512</span>, num_layers=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>所以参数个数为：<script type="math/tex">4 \times 512 \times (100+1+512) = 1255424</script></p>
<h2 id="5-GRU参数个数"><a href="#5-GRU参数个数" class="headerlink" title="5. GRU参数个数"></a>5. GRU参数个数</h2><p>和LSTM类似，但是只有三套参数，更新门、重置门、候选态，总参数量为：</p>
<script type="math/tex; mode=display">Number = 3 \times n \times (m + 1 + n)</script><ul>
<li>n- 隐藏层的维度</li>
<li>m- 输入层的维度</li>
<li>1 表示的是偏置项</li>
</ul>
<ol>
<li>实验：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        super(MyModel, self).__init__()</span><br><span class="line">        self.lstm = nn.LSTM(input_size=<span class="number">100</span>, hidden_size=<span class="number">512</span>, num_layers=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#         self.rnn = nn.RNN(input_size=100, hidden_size=512, num_layers=1)</span></span><br><span class="line"><span class="comment">#         self.gru = nn.GRU(input_size=100, hidden_size=512, num_layers=1)</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net = MyModel()</span><br><span class="line">params = list(net.parameters())</span><br><span class="line">k = <span class="number">0</span></span><br><span class="line">all_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> params:</span><br><span class="line">    l = <span class="number">1</span></span><br><span class="line">    print(<span class="string">"该层的结构："</span> + str(list(i.size())))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i.size():</span><br><span class="line">        l *= j</span><br><span class="line">    print(<span class="string">"该层参数和："</span> + str(l))</span><br><span class="line">    k = k + l</span><br><span class="line">print(<span class="string">"参数总和："</span>+str(k))</span><br></pre></td></tr></table></figure>
<p>以lstm为例输出：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191012003103.png" width='200' height='200'/></p>
<p>可以看到LSTM输出比预期的参数多了 512*4 = 2048</p>
<p>同样，GRU会比预期的参数多 512*3 = 1536</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191012003245.png"/></p>
<p>似乎是多一个偏置项，但是从<a href="https://www.cnblogs.com/wushaogui/p/9176617.html" target="_blank" rel="noopener">参考连接</a>他人用keras好像没有问题，难道是框架的问题？之后再做一下实验。。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p><a href="https://datascience.stackexchange.com/questions/10589/number-of-parameters-in-an-rnn" target="_blank" rel="noopener">RNN参数量</a></p>
<p><a href="https://blog.csdn.net/taoyafan/article/details/82803943" target="_blank" rel="noopener">LSTM参数量</a></p>
<p><a href="https://stats.stackexchange.com/questions/328926/how-many-parameters-are-in-a-gated-recurrent-unit-gru-recurrent-neural-network" target="_blank" rel="noopener">GRU参数量</a></p>
<p><a href="https://blog.csdn.net/jdzwanghao/article/details/84196239" target="_blank" rel="noopener">pytorch参数量计算</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>STL 容器记录</title>
    <url>/2019/11/04/STL%E5%AE%B9%E5%99%A8%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>主要涉及到c++中STL容器的一些用法：vector,set,stack,queue,map,deque及Algorithm，不记得时可以随时查漏补缺。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">转载自@author 鲁伟林</span><br><span class="line">gitHub地址：https://github.com/thinkingfioa/Notes/blob/master/TechFiles/STL_Usage.md</span><br></pre></td></tr></table></figure>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="push-back-函数"><a href="#push-back-函数" class="headerlink" title="push_back()函数"></a>push_back()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector;</span><br><span class="line">myVector.push_back(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="pop-back-函数"><a href="#pop-back-函数" class="headerlink" title="pop_back()函数"></a>pop_back()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从后往前pop</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector;</span><br><span class="line">myVector.push_back(<span class="number">100</span>);</span><br><span class="line">myVector.push_back(<span class="number">200</span>);</span><br><span class="line">myVector.push_back(<span class="number">300</span>);</span><br><span class="line"><span class="comment">//执行前: 100, 200, 300</span></span><br><span class="line">myVector.pop_back();</span><br><span class="line"><span class="comment">//执行后: 100, 200</span></span><br></pre></td></tr></table></figure></p>
<h3 id="insert-函数"><a href="#insert-函数" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">3</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">  <span class="comment">//执行前: 100, 100, 100</span></span><br><span class="line">  it = myvector.begin();</span><br><span class="line">  it = myvector.insert ( it , <span class="number">200</span> );</span><br><span class="line">  <span class="comment">//执行后: 200, 100, 100, 100</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//执行前: 200, 100, 100, 100</span></span><br><span class="line">  myvector.insert (it,<span class="number">2</span>,<span class="number">300</span>);</span><br><span class="line">  <span class="comment">//执行后: 300, 300, 200, 100, 100, 100</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// "it" no longer valid, get a new one:</span></span><br><span class="line">  it = myvector.begin();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行前: 300, 300, 200, 100, 100, 100</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; anothervector (<span class="number">2</span>,<span class="number">400</span>);</span><br><span class="line">  myvector.insert (it+<span class="number">2</span>,anothervector.begin(),anothervector.end());</span><br><span class="line">  <span class="comment">//执行后: 300, 300, 400, 400, 200, 100, 100, 100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myarray [] = &#123; <span class="number">501</span>,<span class="number">502</span>,<span class="number">503</span> &#125;;</span><br><span class="line">  <span class="comment">//执行前: 300, 300, 400, 400, 200, 100, 100, 100</span></span><br><span class="line">  myvector.insert (myvector.begin(), myarray, myarray+<span class="number">3</span>);</span><br><span class="line">  <span class="comment">//执行后: 501, 502, 503, 300, 300, 400, 400, 200, 100, 100, 100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数"><a href="#erase-函数" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">	myVector.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 6, 7, 8, 9</span></span><br><span class="line">myVector.erase(myVector.begin() +<span class="number">5</span>); <span class="comment">// 移除下标为5的数,也就是myVector[5]=6</span></span><br><span class="line"><span class="comment">//执行后: 1, 2, 3, 4, 5, 7, 8, 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 7, 8, 9</span></span><br><span class="line">myVector.erase(myVector.begin(), myVector.begin() + <span class="number">3</span>);</span><br><span class="line"><span class="comment">//执行后: 4, 5, 7, 8, 9</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数"><a href="#swap-函数" class="headerlink" title="swap()函数"></a>swap()函数</h3><p> 代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">3</span>,<span class="number">100</span>);   <span class="comment">// three ints with a value of 100</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar (<span class="number">5</span>,<span class="number">200</span>);   <span class="comment">// five ints with a value of 200</span></span><br><span class="line"><span class="comment">//执行前: foo: [100, 100, 100]</span></span><br><span class="line"><span class="comment">//       bar: [200, 200, 200, 200, 200]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">//执行后: foo: [200, 200, 200, 200, 200]</span></span><br><span class="line"><span class="comment">//       bar: [100, 100, 100]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>迭代器遍历:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (it=myvector.begin(); it&lt;myvector.end(); it++)&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C++中的Set是一个有序-去重集合</span><br></pre></td></tr></table></figure>
<h3 id="insert-函数-1"><a href="#insert-函数-1" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator,<span class="keyword">bool</span>&gt; ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; ++i) myset.insert(i*<span class="number">10</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 30, 40, 50</span></span><br><span class="line">ret = myset.insert(<span class="number">20</span>);  <span class="comment">// no new element inserted</span></span><br><span class="line"><span class="comment">//执行后: 10, 20, 30, 40, 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret.second==<span class="literal">false</span>) it=ret.first;  <span class="comment">// "it" now points to element 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 30, 40, 50</span></span><br><span class="line">myset.insert (it,<span class="number">25</span>);                 <span class="comment">// max efficiency inserting</span></span><br><span class="line">myset.insert (it,<span class="number">24</span>);                 <span class="comment">// max efficiency inserting</span></span><br><span class="line">myset.insert (it,<span class="number">26</span>);                 <span class="comment">// no max efficiency inserting</span></span><br><span class="line"><span class="comment">//执行后: 10, 20, 24, 25, 26, 30, 40, 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 24, 25, 26, 30, 40, 50</span></span><br><span class="line"><span class="keyword">int</span> myints[]= &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>&#125;;              <span class="comment">// 10 already in set, not inserted</span></span><br><span class="line">myset.insert (myints,myints+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//执行后: 5, 10, 15, 20, 24, 25, 26, 30, 40, 50</span></span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数-1"><a href="#erase-函数-1" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert some values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; i++) myset.insert(i*<span class="number">10</span>);  <span class="comment">// 10 20 30 40 50 60 70 80 90</span></span><br><span class="line"></span><br><span class="line">it = myset.begin();</span><br><span class="line">++it;                                         <span class="comment">// "it" points now to 20</span></span><br><span class="line"><span class="comment">// 执行前: 10, 20, 30, 40, 50, 60, 70, 80, 90; //(*it) = 20</span></span><br><span class="line">myset.erase (it);</span><br><span class="line"><span class="comment">//执行后: 10, 30, 40, 50, 60, 70, 80, 90; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 30, 40, 50, 60, 70, 80, 90;</span></span><br><span class="line">myset.erase (<span class="number">40</span>);</span><br><span class="line"><span class="comment">//执行后: 10, 30, 50, 60, 70, 80, 90; </span></span><br><span class="line"></span><br><span class="line">it = myset.find (<span class="number">60</span>);</span><br><span class="line"><span class="comment">//执行前: 10, 30, 50, 60, 70, 80, 90; </span></span><br><span class="line">myset.erase (it, myset.end());</span><br><span class="line"><span class="comment">//执行后: 10, 30, 50;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-1"><a href="#swap-函数-1" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[]=&#123;<span class="number">12</span>,<span class="number">75</span>,<span class="number">10</span>,<span class="number">32</span>,<span class="number">20</span>,<span class="number">25</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; first (myints,myints+<span class="number">3</span>);     <span class="comment">// 10,12,75</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; second (myints+<span class="number">3</span>,myints+<span class="number">6</span>);  <span class="comment">// 20,25,32</span></span><br><span class="line"><span class="comment">//执行前: first [10, 12, 75]</span></span><br><span class="line"><span class="comment">//        second [20, 25, 32]</span></span><br><span class="line">first.swap(second);</span><br><span class="line"><span class="comment">//执行后: first [20, 25, 32]</span></span><br><span class="line"><span class="comment">//       second [10, 12, 75]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="find-函数"><a href="#find-函数" class="headerlink" title="find()函数"></a>find()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) myset.insert(i*<span class="number">10</span>);    <span class="comment">// set: 10 20 30 40 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行前: 10, 20, 30, 40, 50</span></span><br><span class="line">it=myset.find(<span class="number">20</span>);</span><br><span class="line">myset.erase (it);</span><br><span class="line"><span class="comment">// 执行后: 10, 30, 40, 50</span></span><br></pre></td></tr></table></figure></p>
<h3 id="count-函数"><a href="#count-函数" class="headerlink" title="count()函数"></a>count()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由于set集合不重复，所以count(val)返回的结果只有0或者1.</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">5</span>; ++i) myset.insert(i*<span class="number">3</span>);    <span class="comment">// set: 3 6 9 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结果是: 1</span></span><br><span class="line">myset.count(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//返回结果是: 0</span></span><br><span class="line">myset.count(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">75</span>,<span class="number">23</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset (myints,myints+<span class="number">5</span>); <span class="comment">//13, 23, 42, 65, 75</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=myset.begin(); it!=myset.end(); ++it)&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="top-函数"><a href="#top-函数" class="headerlink" title="top()函数"></a>top()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line">mystack.push(<span class="number">10</span>);</span><br><span class="line">mystack.push(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">mystack.top() -= <span class="number">5</span>; <span class="comment">//mystack.top() 的值为20</span></span><br></pre></td></tr></table></figure></p>
<h3 id="push-函数"><a href="#push-函数" class="headerlink" title="push()函数"></a>push()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) mystack.push(i);</span><br></pre></td></tr></table></figure></p>
<h3 id="pop-函数"><a href="#pop-函数" class="headerlink" title="pop()函数"></a>pop()函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">弹出栈的最上面</span><br></pre></td></tr></table></figure>
<h3 id="swap-函数-2"><a href="#swap-函数-2" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; foo,bar;</span><br><span class="line">foo.push (<span class="number">10</span>); foo.push(<span class="number">20</span>); foo.push(<span class="number">30</span>);</span><br><span class="line">bar.push (<span class="number">111</span>); bar.push(<span class="number">222</span>);</span><br><span class="line"><span class="comment">// 执行前: foo [10, 20, 30]</span></span><br><span class="line"><span class="comment">//        bar [111, 222]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">// 执行后: foo [111, 222]</span></span><br><span class="line"><span class="comment">//        bar [10, 20, 30]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Popping out elements..."</span>;</span><br><span class="line"><span class="keyword">while</span> (!mystack.empty())</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; mystack.top();</span><br><span class="line">   mystack.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c++ 中的map是默认按照key的排序。所以每次插入都会做调整。</span><br></pre></td></tr></table></figure>
<h3 id="insert-函数-2"><a href="#insert-函数-2" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first insert function version (single parameter):</span></span><br><span class="line">mymap.insert ( <span class="built_in">std</span>::pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;(<span class="string">'a'</span>,<span class="number">100</span>) );</span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数-2"><a href="#erase-函数-2" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert some values:</span></span><br><span class="line">mymap[<span class="string">'a'</span>]=<span class="number">10</span>;</span><br><span class="line">mymap[<span class="string">'b'</span>]=<span class="number">20</span>;</span><br><span class="line">mymap[<span class="string">'c'</span>]=<span class="number">30</span>;</span><br><span class="line">mymap[<span class="string">'d'</span>]=<span class="number">40</span>;</span><br><span class="line">mymap[<span class="string">'e'</span>]=<span class="number">50</span>;</span><br><span class="line">mymap[<span class="string">'f'</span>]=<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">it=mymap.find(<span class="string">'b'</span>);</span><br><span class="line"><span class="comment">//执行前: a-&gt;10, b-&gt;20, c-&gt;30, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line">mymap.erase (it);                   <span class="comment">// erasing by iterator</span></span><br><span class="line"><span class="comment">//执行后: a-&gt;10, c-&gt;30, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: a-&gt;10, c-&gt;30, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line">mymap.erase (<span class="string">'c'</span>);                  <span class="comment">// erasing by key</span></span><br><span class="line"><span class="comment">//执行后: a-&gt;10, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line"></span><br><span class="line">it=mymap.find (<span class="string">'e'</span>);</span><br><span class="line"><span class="comment">//执行前: a-&gt;10, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line">mymap.erase ( it, mymap.end() );    <span class="comment">// erasing by range</span></span><br><span class="line"><span class="comment">//执行后: a-&gt;10, d-&gt;40</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-3"><a href="#swap-函数-3" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; foo,bar;</span><br><span class="line"></span><br><span class="line">foo[<span class="string">'x'</span>]=<span class="number">100</span>;</span><br><span class="line">foo[<span class="string">'y'</span>]=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">bar[<span class="string">'a'</span>]=<span class="number">11</span>;</span><br><span class="line">bar[<span class="string">'b'</span>]=<span class="number">22</span>;</span><br><span class="line">bar[<span class="string">'c'</span>]=<span class="number">33</span>;</span><br><span class="line"><span class="comment">// 执行前: foo [x-&gt;100, y-&gt;200]</span></span><br><span class="line"><span class="comment">//        bar [a-&gt;11, b-&gt;22, c-&gt;33]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">// 执行前: foo [a-&gt;11, b-&gt;22, c-&gt;33]</span></span><br><span class="line"><span class="comment">//        bar [x-&gt;100, y-&gt;200]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-3"><a href="#遍历-3" class="headerlink" title="遍历"></a>遍历</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=foo.begin(); it!=foo.end(); ++it) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="push-函数-1"><a href="#push-函数-1" class="headerlink" title="push()函数"></a>push()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; myqueue;</span><br><span class="line">myqueue.push (myint);</span><br></pre></td></tr></table></figure></p>
<h3 id="pop-函数-1"><a href="#pop-函数-1" class="headerlink" title="pop()函数"></a>pop()函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">弹出最后一个数。</span><br></pre></td></tr></table></figure>
<h3 id="swap-函数-4"><a href="#swap-函数-4" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; foo,bar;</span><br><span class="line">foo.push (<span class="number">10</span>); foo.push(<span class="number">20</span>); foo.push(<span class="number">30</span>);</span><br><span class="line">bar.push (<span class="number">111</span>); bar.push(<span class="number">222</span>);</span><br><span class="line"><span class="comment">// 执行前: foo[10, 20, 30]</span></span><br><span class="line"><span class="comment">//        bar[111, 222]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">// 执行后: foo[111, 222]</span></span><br><span class="line"><span class="comment">//        bar[10, 20, 30]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="back-函数"><a href="#back-函数" class="headerlink" title="back()函数"></a>back()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">队列的最后一位</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myqueue.push(<span class="number">12</span>);</span><br><span class="line">myqueue.push(<span class="number">75</span>);   <span class="comment">// this is now the back</span></span><br><span class="line"><span class="comment">//执行前: 12, 75</span></span><br><span class="line">myqueue.back() -= myqueue.front();</span><br><span class="line"><span class="comment">//执行后: 12, 63</span></span><br></pre></td></tr></table></figure></p>
<h3 id="front-函数"><a href="#front-函数" class="headerlink" title="front()函数"></a>front()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">队列的队首</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myqueue.push(<span class="number">77</span>);</span><br><span class="line">myqueue.push(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//执行前: 77, 16</span></span><br><span class="line">myqueue.front() -= myqueue.back();    <span class="comment">// 77-16=61</span></span><br><span class="line"><span class="comment">//执行后: 61, 16</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-4"><a href="#遍历-4" class="headerlink" title="遍历"></a>遍历</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myqueue contains: "</span>;</span><br><span class="line"><span class="keyword">while</span> (!myqueue.empty())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myqueue.front();</span><br><span class="line">  myqueue.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">双向队列</span><br></pre></td></tr></table></figure>
<h3 id="front-函数-1"><a href="#front-函数-1" class="headerlink" title="front()函数"></a>front()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回队首</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line">mydeque.push_front(<span class="number">77</span>);</span><br><span class="line">mydeque.push_back(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//执行前: 77, 20</span></span><br><span class="line">mydeque.front() -= mydeque.back();</span><br><span class="line"><span class="comment">//执行后: 57, 20</span></span><br></pre></td></tr></table></figure></p>
<h3 id="back-函数-1"><a href="#back-函数-1" class="headerlink" title="back()函数"></a>back()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">双向队列的尾部</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line">mydeque.push_back(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (mydeque.back() != <span class="number">0</span>)</span><br><span class="line">  mydeque.push_back ( mydeque.back() <span class="number">-1</span> );</span><br></pre></td></tr></table></figure></p>
<h3 id="push-back-函数-1"><a href="#push-back-函数-1" class="headerlink" title="push_back()函数"></a>push_back()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"><span class="comment">//执行前: []</span></span><br><span class="line">mydeque.push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//执行后: [1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: [1]</span></span><br><span class="line">mydeque.push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//执行后: [1,2]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="push-front-函数"><a href="#push-front-函数" class="headerlink" title="push_front()函数"></a>push_front()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque (<span class="number">2</span>,<span class="number">100</span>);     <span class="comment">// two ints with a value of 100</span></span><br><span class="line"><span class="comment">//执行前: 100, 100</span></span><br><span class="line">mydeque.push_front (<span class="number">200</span>);</span><br><span class="line"><span class="comment">//执行后: 200, 100, 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 200, 100, 100</span></span><br><span class="line">mydeque.push_front (<span class="number">300</span>);</span><br><span class="line"><span class="comment">//执行前: 300, 200, 100, 100</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pop-back-函数-1"><a href="#pop-back-函数-1" class="headerlink" title="pop_back()函数"></a>pop_back()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行前: </span></span><br><span class="line">mydeque.push_back (<span class="number">10</span>);</span><br><span class="line">mydeque.push_back (<span class="number">20</span>);</span><br><span class="line">mydeque.push_back (<span class="number">30</span>);</span><br><span class="line"><span class="comment">//执行后: 10, 20, 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 30</span></span><br><span class="line">mydeque.pop_back(); </span><br><span class="line"><span class="comment">//执行后: 10, 20</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pop-front-函数"><a href="#pop-front-函数" class="headerlink" title="pop_front()函数"></a>pop_front()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行前: </span></span><br><span class="line">mydeque.push_back (<span class="number">100</span>);</span><br><span class="line">mydeque.push_back (<span class="number">200</span>);</span><br><span class="line">mydeque.push_back (<span class="number">300</span>);</span><br><span class="line"><span class="comment">//执行后: 100, 200, 300</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 100, 200, 300</span></span><br><span class="line">mydeque.pop_front();</span><br><span class="line"><span class="comment">//执行后: 200, 300</span></span><br></pre></td></tr></table></figure></p>
<h3 id="insert-函数-3"><a href="#insert-函数-3" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++) mydeque.push_back(i); <span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = mydeque.begin();</span><br><span class="line">++it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5</span></span><br><span class="line">it = mydeque.insert (it,<span class="number">10</span>); </span><br><span class="line"><span class="comment">//执行后: 1, 10, 2, 3, 4, 5</span></span><br><span class="line"><span class="comment">// "it" now points to the newly inserted 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 10, 2, 3, 4, 5</span></span><br><span class="line">mydeque.insert (it,<span class="number">2</span>,<span class="number">20</span>);                     <span class="comment">// 1 20 20 10 2 3 4 5</span></span><br><span class="line"><span class="comment">//执行后: 1, 20, 20, 10, 2, 3, 4, 5</span></span><br><span class="line"><span class="comment">// "it" no longer valid!</span></span><br><span class="line"></span><br><span class="line">it = mydeque.begin()+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 20, 20, 10, 2, 3, 4, 5</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">2</span>,<span class="number">30</span>);</span><br><span class="line">mydeque.insert (it,myvector.begin(),myvector.end());</span><br><span class="line"><span class="comment">//执行后: 1, 20, 30, 30, 20, 10, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数-3"><a href="#erase-函数-3" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set some values (from 1 to 10)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) mydeque.push_back(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// erase the 6th element</span></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</span></span><br><span class="line">mydeque.erase (mydeque.begin()+<span class="number">5</span>);</span><br><span class="line"><span class="comment">//执行后: 1, 2, 3, 4, 5, 7, 8, 9, 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// erase the first 3 elements:</span></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 7, 8, 9, 10</span></span><br><span class="line">mydeque.erase (mydeque.begin(),mydeque.begin()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//执行后: 4, 5, 7, 8, 9, 10</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-5"><a href="#swap-函数-5" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">3</span>,<span class="number">100</span>);   <span class="comment">// three ints with a value of 100</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; bar (<span class="number">5</span>,<span class="number">200</span>);   <span class="comment">// five ints with a value of 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: foo [100, 100, 100]</span></span><br><span class="line"><span class="comment">//       bar [200, 200, 200, 200, 200]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">//执行后: foo [200, 200, 200, 200, 200]</span></span><br><span class="line"><span class="comment">//       bar [100, 100, 100]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-5"><a href="#遍历-5" class="headerlink" title="遍历"></a>遍历</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = mydeque.begin(); it!=mydeque.end(); ++it) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!mydeque.empty()) &#123;</span><br><span class="line">  sum+=mydeque.back();</span><br><span class="line">  mydeque.pop_back(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><h3 id="find-函数-1"><a href="#find-函数-1" class="headerlink" title="find()函数"></a>find()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中查询</span></span><br><span class="line"><span class="keyword">int</span> myints[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">std</span>::find (myints, myints+<span class="number">4</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (p != myints+<span class="number">4</span>)</span><br><span class="line">  <span class="comment">//输出: 30</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element not found in myints\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector中查询</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints,myints+<span class="number">4</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">it = find (myvector.begin(), myvector.end(), <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myvector.end())</span><br><span class="line">  <span class="comment">//输出: 30</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element not found in myvector\n"</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="copy-函数"><a href="#copy-函数" class="headerlink" title="copy()函数"></a>copy()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">7</span>);</span><br><span class="line"><span class="comment">//执行前: myvector: </span></span><br><span class="line"><span class="built_in">std</span>::copy ( myints, myints+<span class="number">7</span>, myvector.begin() );</span><br><span class="line"><span class="comment">//执行前: myvector: 10, 20, 30, 40, 50, 60, 70</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-6"><a href="#swap-函数-6" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>, y=<span class="number">20</span>;                              <span class="comment">// x:10 y:20</span></span><br><span class="line"><span class="comment">//执行前: x:10, y:20</span></span><br><span class="line"><span class="built_in">std</span>::swap(x,y);                              <span class="comment">// x:20 y:10</span></span><br><span class="line"><span class="comment">//执行后: x:20, y:10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">4</span>,x), bar (<span class="number">6</span>,y);       <span class="comment">// foo:4x20 bar:6x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: foo[20, 20, 20, 20]</span></span><br><span class="line"><span class="comment">//       bar[10, 10, 10, 10]</span></span><br><span class="line"><span class="built_in">std</span>::swap(foo,bar);                          <span class="comment">// foo:6x10 bar:4x20</span></span><br><span class="line"><span class="comment">//执行前: foo[20, 20, 20, 20]</span></span><br><span class="line"><span class="comment">//       bar[10, 10, 10, 10]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="count-函数-1"><a href="#count-函数-1" class="headerlink" title="count()函数"></a>count()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;   <span class="comment">// 8 elements</span></span><br><span class="line"><span class="comment">//记录数组myints中，10的个数</span></span><br><span class="line"><span class="keyword">int</span> mycount = <span class="built_in">std</span>::count (myints, myints+<span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//输出结果 mycount = 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);</span><br><span class="line"><span class="comment">//记录数组myvector中，20的个数</span></span><br><span class="line">mycount = <span class="built_in">std</span>::count (myvector.begin(), myvector.end(), <span class="number">20</span>);</span><br><span class="line"><span class="comment">//记录数组myvector中，20的个数</span></span><br></pre></td></tr></table></figure></p>
<h3 id="replace-函数"><a href="#replace-函数" class="headerlink" title="replace()函数"></a>replace()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">//执行前: myvector: []</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);            </span><br><span class="line"><span class="comment">//执行后: myvector: 10, 20, 30, 30, 20, 10, 10, 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: myvector: 10, 20, 30, 30, 20, 10, 10, 20</span></span><br><span class="line"><span class="built_in">std</span>::replace (myvector.begin(), myvector.end(), <span class="number">20</span>, <span class="number">99</span>); </span><br><span class="line"><span class="comment">//执行前: myvector: 10, 99, 30, 30, 99, 10, 10, 99</span></span><br></pre></td></tr></table></figure></p>
<h3 id="fill-函数"><a href="#fill-函数" class="headerlink" title="fill()函数"></a>fill()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行前 myvector: []</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">8</span>);                      </span><br><span class="line"><span class="comment">//执行后 myvector: 0,0,0,0,0,0,0,0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前 myvector: 0,0,0,0,0,0,0,0</span></span><br><span class="line"><span class="built_in">std</span>::fill (myvector.begin(),myvector.begin()+<span class="number">4</span>,<span class="number">5</span>);   </span><br><span class="line"><span class="comment">//执行后 myvector: 5,5,5,5,0,0,0,0</span></span><br><span class="line"><span class="comment">//执行后 myvector: 5,5,5,5,0,0,0,0</span></span><br><span class="line">  <span class="built_in">std</span>::fill (myvector.begin()+<span class="number">3</span>,myvector.end()<span class="number">-2</span>,<span class="number">8</span>); </span><br><span class="line"><span class="comment">//执行后 myvector: 5,5,5,8,8,8,0,0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="reverse-函数"><a href="#reverse-函数" class="headerlink" title="reverse()函数"></a>reverse()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; ++i) myvector.push_back(i);   <span class="comment">// 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1,2,3,4,5,6,7,8,9</span></span><br><span class="line"><span class="built_in">std</span>::reverse(myvector.begin(),myvector.end());    <span class="comment">// 9 8 7 6 5 4 3 2 1</span></span><br><span class="line"><span class="comment">//执行后: 9,8,7,6,5,4,3,2,1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort()函数"></a>sort()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j);&#125;</span><br><span class="line">&#125; myobject;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">32</span>,<span class="number">71</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">26</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">33</span>&#125;;</span><br><span class="line">  <span class="comment">//执行前: myvector: []</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);             </span><br><span class="line">  <span class="comment">//执行后: myvector: 32,71,12,45,26,80,53,33</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//缺省的排序是升序(&lt;)</span></span><br><span class="line">  <span class="comment">//执行前: 32,71,12,45,26,80,53,33</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin(), myvector.begin()+<span class="number">4</span>);          </span><br><span class="line">  <span class="comment">//执行后: 12,32,45,71,26,80,53,33</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行前: 12,32,45,71,26,80,53,33 using function as comp</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin()+<span class="number">4</span>, myvector.end(), myfunction); </span><br><span class="line">  <span class="comment">//执行后: 12,32,45,71,26,33,53,80</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// using object as comp</span></span><br><span class="line">  <span class="comment">//执行后: 12,32,45,71,26,33,53,80</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin(), myvector.end(), myobject);   </span><br><span class="line">  <span class="comment">//执行后: 12,26,32,33,45,53,71,80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="merge函数"><a href="#merge函数" class="headerlink" title="merge函数"></a>merge函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将两个有序的组合sort1[], sort2[]。归并成一个新的有序组合。</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> first[] = &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> second[] = &#123;<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort (first,first+<span class="number">5</span>);</span><br><span class="line"><span class="built_in">std</span>::sort (second,second+<span class="number">5</span>);</span><br><span class="line"><span class="comment">//执行前: first: 5,10,15,20,25</span></span><br><span class="line"><span class="comment">//       second: 10,20,30,40,50</span></span><br><span class="line"><span class="comment">//       v:[]</span></span><br><span class="line"><span class="built_in">std</span>::merge (first,first+<span class="number">5</span>,second,second+<span class="number">5</span>,v.begin());</span><br><span class="line"><span class="comment">//执行后: first: 5,10,15,20,25</span></span><br><span class="line"><span class="comment">//       second: 10,20,30,40,50</span></span><br><span class="line"><span class="comment">//       v:5,10,10,15,20,20,25,30,40,50</span></span><br></pre></td></tr></table></figure></p>
<h3 id="min-函数"><a href="#min-函数" class="headerlink" title="min()函数"></a>min()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出: 1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min(1,2)=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>  </span><br><span class="line"><span class="comment">//输出: 1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min(2,1)=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="number">2</span>,<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 'a'</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min('a','z')=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="string">'a'</span>,<span class="string">'z'</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 2.72</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min(3.14,2.72)=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="number">3.14</span>,<span class="number">2.72</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="max-函数"><a href="#max-函数" class="headerlink" title="max()函数"></a>max()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出: 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(1,2)=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>  </span><br><span class="line"><span class="comment">//输出: 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(2,1)=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="number">2</span>,<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 'z'</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max('a','z')=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="string">'a'</span>,<span class="string">'z'</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 3.14</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(3.14,2.72)=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="number">3.14</span>,<span class="number">2.72</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>图论算法记录</title>
    <url>/2019/11/03/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>主要以有向加权图为主，涉及到 <strong>图的几种常见表示方法</strong>、<strong>拓扑排序</strong>、<strong>弗洛伊德算法(Floyd)算法</strong>、 <strong>狄克斯特拉(dijkstra)算法</strong>、 <strong>SPFA算法</strong>、<strong>贝尔曼-福特(Bellman-Ford)算法</strong></p>
<a id="more"></a>
<h2 id="图的常见表示方法"><a href="#图的常见表示方法" class="headerlink" title="图的常见表示方法"></a>图的常见表示方法</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151010.png" heigt='400' width='400'/></p>
<h3 id="1-邻接矩阵："><a href="#1-邻接矩阵：" class="headerlink" title="1. 邻接矩阵："></a>1. 邻接矩阵：</h3><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151027.png" heigt='400' width='400'/></p>
<h3 id="2-邻接表："><a href="#2-邻接表：" class="headerlink" title="2. 邻接表："></a>2. 邻接表：</h3><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151035.png" heigt='400' width='400'/></p>
<h3 id="3-边缘列表"><a href="#3-边缘列表" class="headerlink" title="3. 边缘列表"></a>3. 边缘列表</h3><p>在刷题的时候经常以这种形式给出，可以将其转换乘邻接表或者邻接矩阵</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151044.png" heigt='350' width='350'/></p>
<p><a href="https://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">完整</a></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/ca22fa351d5278e95c4c8c94aba6da42ae45d465ff3e8e82149777274293e194-0210.gif" alt=""></p>
<p>其简单思路就是先找到入度为0 的节点，并将该节点放入队列中，同时将与他相邻的节点的入度减一，以此往复，如果最后所有节点的入度都为零则说明可以完成拓扑排序，否则该图不能进行拓扑排序</p>
<p>具体的算法流程如下：</p>
<ol>
<li><p>在算法开始前，扫描对应的存储空间(使用邻接表)，将入度为 0 的节点放入队列中</p>
</li>
<li><p>只要队列非空，就从队首取出入度为0 的节点，并且将这个结点的所有邻接结点（它指向的结点）的入度减1，在减 1 以后，如果这个被减 1 的结点的入度为 0 ，就继续入队。</p>
</li>
<li><p>队列为空时，检查结果集是否满足要求</p>
</li>
</ol>
<p>除了需要保存入度为0 的队列，还需要两个辅助的数据结构：</p>
<pre><code>1). 邻接表：通过节点的索引，能够得到这个节点的后继节点；

2). 入度数组：通过节点的索引能够得到指向这个节点的节点个数
</code></pre><h3 id="leetcode207-课程表"><a href="#leetcode207-课程表" class="headerlink" title="leetcode207 课程表"></a>leetcode207 课程表</h3><ul>
<li>题目描述：</li>
</ul>
<p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p>
<ul>
<li><p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）</p>
</li>
</ul>
<p>链接：<a href="https://leetcode-cn.com/problems/course-schedule" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule</a></p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<ul>
<li>解题</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//输入prerequisites是边缘列表</span></span><br><span class="line">    <span class="keyword">int</span> clen = prerequisites.size(); <span class="comment">//课程的长度</span></span><br><span class="line">    <span class="keyword">if</span> (clen == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 课程长度为零，所以肯定可以学习完</span></span><br><span class="line">    <span class="comment">//1.初始化入度的数组 和 邻接表数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses); <span class="comment">//入度数组，初始化为0</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(numCourses); <span class="comment">//邻接表数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clen; ++i) &#123;</span><br><span class="line">        indegree[prerequisites[i][<span class="number">0</span>]] += <span class="number">1</span>;  <span class="comment">//统计每个顶点的度</span></span><br><span class="line">        adj[prerequisites[i][<span class="number">1</span>]].push_back(prerequisites[i][<span class="number">0</span>]); <span class="comment">// 创建邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 创建队列，在拓扑排序之前，将所有入度为0的顶点存入队列中</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; myqueue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">            myqueue.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 开始拓扑排序，主要是遍历前面的邻接表，然后找到表中顶点对应的入度，对入度减一操作，若检测到入度为0时则推入队列中，准备输出（删除）</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!myqueue.empty()) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">int</span> top = myqueue.front(); <span class="comment">// 得到首元素</span></span><br><span class="line">        myqueue.pop();  <span class="comment">//删除首元素</span></span><br><span class="line">        <span class="comment">//vector&lt;int&gt; tmp = adj[top];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = adj[top].begin(); iter != adj[top].end(); ++iter) &#123;</span><br><span class="line">            --indegree[*iter];</span><br><span class="line">            <span class="keyword">if</span> (indegree[*iter] == <span class="number">0</span>)</span><br><span class="line">                myqueue.push(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode210-课程表2"><a href="#leetcode210-课程表2" class="headerlink" title="leetcode210 课程表2"></a>leetcode210 课程表2</h3><p>和前面一样不同的是需要把课程表输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisities) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">//1. 初始化入度数组和邻接表'</span></span><br><span class="line">    <span class="keyword">if</span> (prerequisities.size() == <span class="number">0</span>) &#123;  <span class="comment">// 如果prerequisities大小为零，没有特别说明课程完成的先后顺序，则所有课程都能完成</span></span><br><span class="line">        <span class="keyword">while</span>(numCourses &gt;<span class="number">0</span>)</span><br><span class="line">            res.push_back(--numCourses);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses); <span class="comment">//入度数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(numCourses); <span class="comment">//邻接表数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisities.size(); ++i) &#123;</span><br><span class="line">        indegree[prerequisities[i][<span class="number">0</span>]] += <span class="number">1</span>;  <span class="comment">// 入度+1</span></span><br><span class="line">        adj[prerequisities[i][<span class="number">1</span>]].push_back(prerequisities[i][<span class="number">0</span>]); <span class="comment">// 扩展邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 创建队列，将度为0的元素推入队列中</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Myqueue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">            Myqueue.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 统计每个顶点的度，判断是否为零，减一和push进入队列中</span></span><br><span class="line">    <span class="keyword">while</span> (!Myqueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = Myqueue.front();</span><br><span class="line">        res.push_back(top);</span><br><span class="line">        Myqueue.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = adj[top].begin(); iter != adj[top].end(); ++iter) &#123;</span><br><span class="line">            --indegree[*iter];</span><br><span class="line">            <span class="keyword">if</span> (indegree[*iter] == <span class="number">0</span>)</span><br><span class="line">                Myqueue.push(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.size() != numCourses)</span><br><span class="line">        res = &#123;&#125;;  <span class="comment">// 输出空数组</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="弗洛伊德算法-Floyd"><a href="#弗洛伊德算法-Floyd" class="headerlink" title="弗洛伊德算法(Floyd)"></a>弗洛伊德算法(Floyd)</h2><p>弗洛伊德算法是经典的 <strong>多源最短路径</strong> 算法，可以正确处理有向图或有向图的负权，但不可存在负权回路的最短路径问题，同时也被用于计算有向图的传递闭包。 </p>
<ul>
<li>大概思路：</li>
</ul>
<p>定义两个二维矩阵D和P， D记录顶点间的最小路径，P记录顶点间最小路径中的中转点<br>通过三重循环，k为中转点，v为起点，w为终点，循环比较D[v][w] 和 D[v][k]+D[k][w]最小值，如果后者更小则替换前者</p>
<ul>
<li>具体：</li>
</ul>
<p>矩阵 D 记录顶点间的最小路径<br>例如 D[0][3]= 10，说明顶点 0  到  3  的最短路径为 10；<br>矩阵 P 记录顶点间最小路径中的中转点<br>例如 P[0][3]= 1  说明，0  到  3 的最短路径轨迹为：0 -&gt; 1 -&gt; 3。<br>它通过 3 重循环，k 为中转点，v 为起点，w 为终点，循环比较 D[v][w]  和  D[v][k] + D[k][w]最小值，如果 D[v][k] + D[k][w]  为更小值，则把 D[v][k] + D[k][w]  覆盖保存在 D[v][w]中。</p>
<ul>
<li>步骤演示：</li>
</ul>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/Floyd算法.PNG" height='800' width='400'/></p>
<p><a href="https://www.cnblogs.com/dzzy/p/5097009.html" target="_blank" rel="noopener">图片来源</a></p>
<h3 id="leetcode743-网络延迟时间"><a href="#leetcode743-网络延迟时间" class="headerlink" title="leetcode743 网络延迟时间"></a>leetcode743 网络延迟时间</h3><p>输入： times[i] = (u,v,w)，分别表示源节点、目标节点、它们之间的传递时间；  N：网络节点的个数， K表示测试时的起始节点<br>范围： N:[1,100], K:[1,N], times:[1,6000], 1 &lt;= u,v&lt;= N ,0 &lt;= w &lt;= 100<br>输出： 如果可以使所有节点都收到信号则返回总的时间，如果不能则返回-1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime_Floyd</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建二维稀疏矩阵表示 ==&gt; 邻接矩阵</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">-1</span>)); <span class="comment">// 创建二维vector 并初始化为-1表示永远不会到达</span></span><br><span class="line">    <span class="comment">//填充邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        v[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">        v[times[i][<span class="number">0</span>]][times[i][<span class="number">1</span>]] = times[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接下来进入Floyd算法的三重循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N ; ++k) &#123;  <span class="comment">//这里的小k表示的就是中间节点，尝试使用每个中间节点进行替换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">                <span class="comment">//当满足下面的条件时，使用中间节点进行替换</span></span><br><span class="line">                <span class="comment">//1. 中间节点不为-1，即i -&gt; k 和 k -&gt; j 这条有向边是存在的</span></span><br><span class="line">                <span class="comment">//2. 在满足条件1 的基础上，经过中间节点花费的时间可以比原来小，或者 原来的有向边不存在</span></span><br><span class="line">                <span class="keyword">if</span> (v[i][k] != <span class="number">-1</span> &amp;&amp; v[k][j] != <span class="number">-1</span> &amp;&amp; (v[i][j] &gt; v[i][k] + v[k][j] || v[i][j] == <span class="number">-1</span>))</span><br><span class="line">                    v[i][j] = v[i][k] + v[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过上面的三重循环，就将每个节点之间的最短通路找到了（如果存在的话）</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//因为最后的结果是要返回从该节点K出发遍历所有节点所花费的时间</span></span><br><span class="line">    <span class="comment">//所以首先判断是否为-1以此判断K是否可以联通所有节点，如果存在存在-1说明此路不通直接返回-1；</span></span><br><span class="line">    <span class="comment">//否则，将最大的那个值输出，因为最大值表示从K出发经过了所有的节点累加得到的路径长度，符合最后的要求</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[K][i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//说明这个节点是走不通的</span></span><br><span class="line">        res = max(res, v[K][i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="狄克斯特拉算法-Dijkstra"><a href="#狄克斯特拉算法-Dijkstra" class="headerlink" title="狄克斯特拉算法(Dijkstra)"></a>狄克斯特拉算法(Dijkstra)</h2><p>最经典的 <strong>单源最短路径</strong> (一个点到其余各个顶点的最短路径)算法，适用于边权为正的无向和有向图，不适用于有负边权的图.</p>
<p>基本思想：</p>
<p>每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。</p>
<p>基本步骤：</p>
<ol>
<li><p>将所有顶点分为两部分：已知最短路程的顶点集合P和未知最短路程的顶点集合Q。最开始，已知最短路径的顶点集合P中只有源点一个顶点。这里使用一个book[i]数组来记录哪些点在集合P中。例如对于某个顶点i，如果book[i]=1则表示这个顶点在集合P中，book[i]=0则表示这个顶点在集合Q中；</p>
</li>
<li><p>设置源点s到自己的最短路径为0即dis=0。若存在源点能直接到达顶点i，则把dis[i]设为e[s][i]，同时把所有其它（源点不能直接到达的）顶点的最短路径设置为 $ \infty$；</p>
</li>
<li><p>在集合Q的所有顶点选择一个离源点s最近的顶点u（即dis[u]最小）加入到集合P。并考察所有以点u为起点的边，对每一条边进行松弛操作。例如存在一条边从 u到v的边，那么可以通过将边 u -&gt; v添加到尾部来拓展一条从s 到v的路径，这条路径的长度是 dis[u]+e[u][v]，如果这个值比目前已知的dis[v]的值要小，可以用这个新值代替dis[v]中的值；</p>
</li>
<li><p>重复第三步，如果集合Q为空，算法结束。最终dis 数组中的值就是源点到所有顶点的最短路径。</p>
</li>
</ol>
<ul>
<li>步骤演示：</li>
</ul>
<p>给出下图：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.1.png" alt=""></p>
<p>创建邻接矩阵：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.2.png" alt=""></p>
<p>使用一个一维数组dis存储1号顶点到其余各个顶点的初始路程:</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.3.png" alt=""></p>
<p>找到离1号顶点最近的顶点，首先就是其本身，因为其操作没有特殊性，直接参考后续步骤。然后找到的最近顶点为2，然后查看2号顶点的出边有： 2-&gt;3, 2-&gt;4这两条边。先讨论2-&gt;3这条边能否让1号顶点到3号顶点的路程变短，也就是比较dis[3] 和 dis[2] + e[2][3]的大小，发现 12 &gt; 1+9，所以dis[3]更新为10,同理分析 2-&gt;4这条边， dis[4] = $ \infty$ &gt; dis[2] + e[2][4] = 4 所以dis[4] = 4，dis更新如下：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.4.png" alt=""></p>
<p>继续在 3,4,5,6顶点中查找离1号顶点最近的点，发现是4号顶点，其出边为 4-&gt;3, 4-&gt;5, 4-&gt;6。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于4 -&gt;3 ,dis[3] = 10 &gt; dis[4] + e[4][3] = 8,故 dis[3]更新为8;</span><br><span class="line">对于4-&gt;5, dis[5] = inf &gt; dis[4] + e[4][5] = 17, 故 dis[5] = 17;</span><br><span class="line">同理 dis[6] = 19</span><br></pre></td></tr></table></figure><br>所以dis更新如下：<br><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.5.png" alt=""></p>
<p>继续在3,5,6中查找离1号顶点最近的点，发现是3号顶点，其出边为 3-&gt;5。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 -&gt; 5， dis[5] = 17 &gt; dis[3] + e[3][5] = 13，故dis[5] = 13</span><br></pre></td></tr></table></figure><br>所以dis更新如下：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.6.png" alt="">（图中6号节点对应的19，背景应该是白色的）</p>
<p>继续在5,6中查找，最近点为5，其出边为 5-&gt;6：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5-&gt;6, dis[6] = 19 &gt; dis[5] + e[5][6] = 17，dis[6] = 17</span><br></pre></td></tr></table></figure></p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.7.png" alt=""></p>
<p>最后对顶点6进行松弛，发现没有出边故不处理，最终dis数组如下，这便是1号顶点到其余各个顶点的最短路径：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.8.png" alt=""></p>
<p><a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="leetcode743-网络延时时间"><a href="#leetcode743-网络延时时间" class="headerlink" title="leetcode743 网络延时时间"></a>leetcode743 网络延时时间</h3><p>前面使用了Floyd算法求解，这里使用Dijkstra算法求解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime_Dijkstra</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建邻接矩阵</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">-1</span>)); <span class="comment">//使用-1代替无穷大值，可能会有些许麻烦，之后尝试替换为 MAX_INT</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">        v[times[i][<span class="number">0</span>]][times[i][<span class="number">1</span>]] = times[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; S(N + <span class="number">1</span>, <span class="number">-1</span>), T(N + <span class="number">1</span>, <span class="number">-1</span>); <span class="comment">//S为确定数组，T为估计数组</span></span><br><span class="line">    <span class="comment">//根据单源节点填充数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[K][i] != <span class="number">-1</span>)</span><br><span class="line">            T[i] = v[K][i];</span><br><span class="line">    &#125;</span><br><span class="line">    T[K] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到距离单元节点最短距离的节点</span></span><br><span class="line">    <span class="keyword">int</span> minVal = <span class="number">-1</span>,minIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; ++c) &#123;</span><br><span class="line">        minVal = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (T[i] != <span class="number">-1</span> &amp;&amp; S[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minVal == <span class="number">-1</span> || T[i] &lt; minVal) &#123;</span><br><span class="line">                    minVal = T[i];</span><br><span class="line">                    minIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        S[minIndex] = minVal; <span class="comment">// 确定值</span></span><br><span class="line">        <span class="comment">// 以这个节点(minIndex)出发，找到其每个出边，并和原始距离进行比较，更新数组 T(估计数组)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[minIndex][i] != <span class="number">-1</span> &amp;&amp; (minVal + v[minIndex][i] &lt; T[i] || T[i] == <span class="number">-1</span>))</span><br><span class="line">                T[i] = minVal + v[minIndex][i]; <span class="comment">// 估计值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        res = max(res, S[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里使用-1 代替了 inf ，后续尝试修改成inf</span></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/network-delay-time/solution/c-bellman-forddijkstrafloydspfa-by-gez1994/" target="_blank" rel="noopener">解题参考</a></p>
<h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>SPFA算法是 <strong>单源最短路径</strong> 算法，是Bellman-ford队列优化，和BFS的关系密切，相较于狄克斯特拉算法，<strong>边的权重可以是负数</strong>、实现简单，但是时间复杂度过高。</p>
<ul>
<li>基本思路：</li>
</ul>
<p>使用一个先进先出的队列保存待优化的节点，优化时每次取出队首的节点 u ，并且对于 u 的所有出边所指向的节点v进行松弛操作，如果 v 点的最短路径估计值有所调整且v 点不在当前队列中，就将 v 点放入队尾。这样不断从队列中取出节点来进行松弛操作，直至队列为空。</p>
<ul>
<li>步骤：</li>
</ul>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103124821.png"/></p>
<h3 id="leetcode743-网络延时时间-1"><a href="#leetcode743-网络延时时间-1" class="headerlink" title="leetcode743 网络延时时间"></a>leetcode743 网络延时时间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networdDelay_SPFA</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T(N + <span class="number">1</span>, <span class="number">-1</span>);  <span class="comment">//估计值</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Flag(N + <span class="number">1</span>, <span class="number">-1</span>);  <span class="comment">// 用来标记节点是否在队列中</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Myqueue;  <span class="comment">//队列</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">        v[times[i][<span class="number">0</span>]][times[i][<span class="number">1</span>]] = times[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i)</span><br><span class="line">        v[i][i] = <span class="number">0</span>;</span><br><span class="line">    T[K] = <span class="number">0</span>;</span><br><span class="line">    Myqueue.push(K);  </span><br><span class="line">    Flag[K] = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">while</span> (!Myqueue.empty()) &#123;  <span class="comment">//只要队列不为空就一直循环</span></span><br><span class="line">        <span class="keyword">int</span> u = Myqueue.front();</span><br><span class="line">        Myqueue.pop();</span><br><span class="line">        Flag[u] = <span class="number">-1</span>; <span class="comment">//此时tmp 不在队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[u][i] != <span class="number">-1</span> &amp;&amp;( T[i] &gt; T[u] + v[u][i]  ||  T[i] == <span class="number">-1</span>))&#123;</span><br><span class="line">                T[i] = T[u] + v[u][i];</span><br><span class="line">                <span class="keyword">if</span> (Flag[i] == <span class="number">-1</span>) &#123;<span class="comment">//说明此时这个节点i不在队列中</span></span><br><span class="line">                    Myqueue.push(i);</span><br><span class="line">                    Flag[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        res = max(res, T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="贝尔曼-福特算法-Bellman-Ford"><a href="#贝尔曼-福特算法-Bellman-Ford" class="headerlink" title="贝尔曼-福特算法(Bellman-Ford)"></a>贝尔曼-福特算法(Bellman-Ford)</h2><p><a href="https://juejin.im/post/5b77fec1e51d4538cf53be68" target="_blank" rel="noopener">参考</a></p>
<p>其原理是对图进行最多n-1次松弛操作，得到所有可能的最短路径。其边的权重可以是负数，实现简单但是复杂度过高，复杂度为$O(NE)$ 其中N为顶点个数，E为边数。</p>
<p>基本思路：</p>
<ol>
<li><p>初始化时将起点s 到各顶点v的距离dis(s-&gt;v)赋值为 $\infty$，dis(s-&gt;s)赋值为0；</p>
</li>
<li><p>后续进行最多n-1 次遍历，对所有边进行松弛操作；</p>
</li>
<li><p>遍历都结束，若再进行一次遍历，还能得到s 到某些节点更短路径的话，就说明存在负环路（负环路会随着遍历次数的增加而不断减小）</p>
</li>
</ol>
<p>思路上与狄克斯特拉算法最大的不同是每次都是从源点s 重新出发进行 “松弛”更新操作，而狄克斯特拉算法则是从源点出发向外扩逐个处理相邻（最近）的节点。</p>
<h3 id="leetcode743-网络延时时间-2"><a href="#leetcode743-网络延时时间-2" class="headerlink" title="leetcode743 网络延时时间"></a>leetcode743 网络延时时间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. Bellman-Ford算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networdDelay_BellmanFord</span><span class="params">(<span class="built_in">vector</span> &lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T(N + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    T[K] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N - <span class="number">1</span>; ++c) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> src = times[i][<span class="number">0</span>], target = times[i][<span class="number">1</span>], dis = times[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (T[src] != <span class="number">-1</span> &amp;&amp; (T[src] + dis &lt; T[target] || T[target] == <span class="number">-1</span>)) &#123;</span><br><span class="line">                T[target] = T[src] + dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        res = max(res, T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
