<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CUDA_03理解线程束的执行</title>
    <url>/2019/11/12/CUDA_03%E7%90%86%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%9D%9F%E7%9A%84%E6%89%A7%E8%A1%8C/</url>
    <content><![CDATA[<p>CUDA执行的实质是线程束的执行。</p>
<a id="more"></a>
<p><a href="https://face2ai.com/cuda-f-3-2-%e7%90%86%e8%a7%a3%e7%ba%bf%e7%a8%8b%e6%9d%9f%e6%89%a7%e8%a1%8c%e7%9a%84%e6%9c%ac%e8%b4%a8-p1/" target="_blank" rel="noopener">来源：理解线程束执行的本质(Part I)</a></p>
<p>因为硬件根本不知道每个块谁是谁，也不知道先后顺序，硬件(SM)只知道按照机器码跑，而给他什么，先后顺序，这个就是硬件功能设计的直接体现了。<br>从外表来看，CUDA执行所有的线程，并行的，没有先后次序的，但实际上硬件资源是有限的，不可能同时执行百万个线程，所以从硬件角度来看，物理层面上执行的也只是线程的一部分，而每次执行的这一部分，就是我们前面提到的 <strong>线程束</strong> 。</p>
<h2 id="理解CUDA中的线程束"><a href="#理解CUDA中的线程束" class="headerlink" title="理解CUDA中的线程束"></a>理解CUDA中的线程束</h2><p><a href="https://songpo.wang/" target="_blank" rel="noopener">来源</a></p>
<p>线程束是SM中基本的执行单元， 每个线程束包含了 32 个线程。所以，当我们定义的一个block中含有的线程数量不是 32 的整数倍时，那么该 block 会被分配给 n+1 个线程束， 其中 n 表示的是 线程数量与32 的整数倍，多出来的线程束会有部分线程不活跃，但因为线程束是基本执行单元，所以这个额外的线程束依旧会消耗和其他线程束相同的资源。</p>
<blockquote>
<p>例如： 有一个一维的线程块包含有80个线程，那么映射到 <strong>硬件</strong> 上，系统就会为这个线程块分配 <strong>3个连续</strong> 的线程束，使总共96个硬件线程去支持80个软件线程。其中 <strong>第3个线程束</strong> 中有 <strong>16个线程不活跃</strong>，但是仍然 <strong>消耗</strong> 这系统资源，被浪费掉了。</p>
</blockquote>
<p>每个线程束中的线程按照 <strong>单指令多线程</strong> 的方式执行，也就是说同属于一个线程束的线程均会执行 <strong>同一个指令</strong>。</p>
<h2 id="线程束-warp-和线程块"><a href="#线程束-warp-和线程块" class="headerlink" title="线程束(warp)和线程块"></a>线程束(warp)和线程块</h2><p>执行过程：</p>
<ol>
<li><p>一个网格被启动（网格被启动，等价于一个内核被启动，每个内核对应于自己的网格），网格中包含线程块；</p>
</li>
<li><p>线程块被分配到某一个SM上；</p>
</li>
<li><p>SM上的线程块将分为多个线程束，每个线程束一般是 32 个线程；</p>
</li>
<li><p>在一个线程束中，所有线程按照单指令多线程SIMT的方式执行，每一步执行相同的指令，但是处理的数据是私有数据。</p>
</li>
</ol>
<p>下图，对应 <strong>逻辑</strong> 、<strong>实际</strong> 和 <strong>硬件</strong>：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191112152601.png"/></p>
<p>在块中，每个线程有唯一的编号， threadIdx;</p>
<p>在网格中，每个线程块也有唯一的编号，blockIdx;</p>
<p>所以每个线程就有在网格中的唯一编号。</p>
<p>因为线程块是逻辑层，被定义了一个三维结构，而线程束是硬件层，在硬件结构中是一维排列的，所以它们之间的对应关系就是：</p>
<ol>
<li>对于一个二维的线程块，映射到一维的物理布局上是：</li>
</ol>
<script type="math/tex; mode=display">\text{threadIdx.y} \times \text{blockDim.y} + \text{threadIdx.x}</script><ol>
<li>对于一个三维的线程块，映射到一维的物理布局上是：</li>
</ol>
<script type="math/tex; mode=display">\text{threadIdx.z} \times \text{blockDim.y} \times \text{blockDim.x} + \text{threadIdx.y} \times \text{blockDim.x} + \text{threadIdx.x}</script><h2 id="线程束分化"><a href="#线程束分化" class="headerlink" title="线程束分化"></a>线程束分化</h2><p>线程束是硬件层面的线程集合，线程块是逻辑层面的线程集合。线程束被执行的时候会被分配相同的指令，但是是处理各自私有的数据。如果一个线程束中的不同线程包含不同的控制条件，那么当我们执行到这个控制条件时就会面临不同的选择，同一个线程束中的线程，执行不同的指令就叫做 <strong>线程束的分化。</strong></p>
<p>GPU相较于CPU不时候大量计算逻辑复杂的任务，因为CPU在进行流水线作业时会采用 <strong>分支预测</strong> 的技术（之前有做个测试，如果对一个很大的随机数组在进行if…else逻辑判断前先进行排序会比未排序直接进行逻辑判断速度慢很多）,而GPU这方面就不擅长。</p>
<p>为了解决GPU中 <code>线程束中的所有线程执行相同的指令</code> 和 <code>线程束又是分化的</code> 之间的矛盾，只能让那些不成立的指令进行等待。</p>
<p>例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">分水果，你不爱吃，那你就只能看着别人吃，等大家都吃完了，再进行下一轮（也就是下一个指令）</span><br></pre></td></tr></table></figure>
<p>示意图：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191112162353.png"/></p>
<p>线程束分化会产生严重的性能下降。条件分支越多，并行性削弱越严重。所以应该避免同一个线程束内的线程分化，控制线程块中线程分配到线程束是有规律的而不是随机的。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//低效的分支：</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">mathKernel1</span><span class="params">(<span class="keyword">float</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tid = blockIdx.x* blockDim.x + threadIdx.x;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> (tid % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">100.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">200.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c[tid] = a + b;</span><br><span class="line">&#125;<span class="comment">//奇数偶数分化，每次间隔都要分化一次，分化严重</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调整</span></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">mathKernel2</span><span class="params">(<span class="keyword">float</span> *c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tid = blockIdx.x* blockDim.x + threadIdx.x;</span><br><span class="line">    <span class="keyword">float</span> a = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">float</span> b = <span class="number">0.0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((tid/warpSize) % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="number">100.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">200.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    c[tid] = a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//第一个线程束内的线程编号tid从0到31，tid/warpSize都等于0，那么就都执行if语句。</span></span><br><span class="line"><span class="comment">//第二个线程束内的线程编号tid从32到63，tid/warpSize都等于1，执行else线程束内没有分支，效率较高。</span></span><br></pre></td></tr></table></figure>
<h2 id="延迟隐藏-效率的最大化"><a href="#延迟隐藏-效率的最大化" class="headerlink" title="延迟隐藏-效率的最大化"></a>延迟隐藏-效率的最大化</h2><p>效率的最大化就是要最大化硬件，尤其是计算部分的硬件跑满，都不闲着的情况下利用率是最高的，即最大化功能单元的利用率，而 <strong>利用率</strong> 和 <strong>常驻线程束</strong> 直接相关。硬件中的线程调度器负责线程束的调度，当每时每刻都有可用的线程束供其调度时，这时候可以达到计算资源的完全利用，<strong>依次来保证通过其他常驻线程束来发布其他指令，并可以隐藏每个指令的延迟。</strong></p>
<p>对于指令的延迟，主要分为两种：</p>
<ol>
<li><p>算数指令延迟：从一个算数操作开始，到产生结果之间的时间，这个时间段内只有某些计算单元处于工作状态，而其他逻辑计算单元处于空闲，10 ~ 20 个时钟周期。</p>
</li>
<li><p>内存指令延迟： 当产生内存访问的时候，计算单元要等数据从内存拿到寄存器，这个周期是非常长的， 400 ~ 800 个时钟周期。</p>
</li>
</ol>
<p><strong>提高并行的两种方式：</strong></p>
<ol>
<li><p>指令集并行（ILP）：一个线程中有很多独立的指令</p>
</li>
<li><p>线程级并行（TLP）：很多并发的符合条件的线程</p>
</li>
</ol>
<p>指令隐藏的关键目的是使用全部的计算资源，而内存读取的延迟隐藏是为了使用全部的内存带宽</p>
<p>内核使用寄存器的数量会影响SM内线程束的数量，<strong>通过调整线程块内线程的多少来提高占用率</strong></p>
<ul>
<li><p>小的线程块： 每个线程块中线程太少，会在所有资源没用完就达到了线程束的最大要求；</p>
</li>
<li><p>大的线程块： 每个线程块中太多线程，会导致每个SM中每个线程可用的硬件资源较少。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA_02执行模型概述</title>
    <url>/2019/11/12/CUDA_02%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>GPU架构学习</p>
<a id="more"></a>
<p><a href="https://face2ai.com/cuda-f-3-1-cuda%e6%89%a7%e8%a1%8c%e6%a8%a1%e5%9e%8b%e6%a6%82%e8%bf%b0/" target="_blank" rel="noopener">参考1: CUDA执行模型概述</a></p>
<p><a href="https://www.cnblogs.com/timlly/p/11471507.html#%E5%9B%9Bgpu%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener">参考2: 深入GPU硬件架构及运行机制</a></p>
<h2 id="CUDA-编程模型和硬件模型对应"><a href="#CUDA-编程模型和硬件模型对应" class="headerlink" title="CUDA 编程模型和硬件模型对应"></a>CUDA 编程模型和硬件模型对应</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191112104551.png"/></p>
<p>线程块中通过共享内存和寄存器相互通信协调，寄存器和共享内存的分配可以严重影响性能。</p>
<p>因为SM有限，虽然在编程模型看所有线程都是并行执行，但是在微观上看，所有线程也是分批次在物理层面的机器上执行，线程块(block)里不同的线程可能进度都不一样，但是同一个线程束的线程拥有相同的进度。</p>
<p>并行就会引起竞争，多线程以未定义的顺序访问同一个数据，就导致了不可预测的行为，CUDA只提供了一种块内（块内线程间）同步的方式，块之间没办法同步！</p>
<p>同一个SM上可以有不止一个常驻的线程束，有些在执行，有些在等待，他们之间状态的转换是不需要开销的。<strong>每个SM</strong> 都将 <strong>分配给它的线程块</strong> 划分到包含32个线程（我的理解，这32 个线程就是对应到SM硬件图中的core）的线程束中，然后在可用的硬件资源上调度执行。</p>
<h2 id="Nvidia-Fermi架构"><a href="#Nvidia-Fermi架构" class="headerlink" title="Nvidia Fermi架构"></a>Nvidia Fermi架构</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/7FF8E397A2433A1D7678F72C97558C6A.jpg"/></p>
<p>解释：</p>
<ul>
<li><p>Fermi架构</p>
<ol>
<li><p><strong>L2 Cache:</strong>  768 KB 的二级缓存，被所有SM共享；</p>
</li>
<li><p><strong>DRAM:</strong> 6 个 384-bits 的GDRR5内存接口；</p>
</li>
<li><p><strong>GigaThread引擎：</strong> 全局调度器，分配线程块到SM线程束调度器上；</p>
</li>
<li><p><strong>SM(流多处理器器Stream Multiprocessor):</strong> 16个SM，每个SM支持数百个线程并发执行，当一个核函数的网格被启动的时候，多个block会被同时分配给可用的SM上执行。</p>
</li>
</ol>
</li>
<li><p>SM</p>
<ol>
<li><p><strong>2 个 Warp(线程束):</strong> 采用单指令多线程 SIMT 架构管理执行线程，每个线程束中包括 16个Core， Warp编排器（Warp Scheduler），分发单元（Dispatch Unit）；</p>
</li>
<li><p><strong>Warp编排器(Warp Scheduler)</strong>， 线程束调度器，</p>
</li>
<li><p><strong>分发单元(Dispatch Unit)</strong>， 指令调度（分配）单元，存储两个线程束要执行的命令，</p>
</li>
<li><p><strong>寄存器文件(Register File)</strong></p>
</li>
<li><p><strong>16组加载存储单元（LD/ST）</strong></p>
</li>
<li><p><strong>4 个特殊函数单元（SFU）</strong> 执行固有指令，如正弦、余弦、平方根和差值</p>
</li>
<li><p><strong>共享内存/一级缓存</strong></p>
</li>
<li><p><strong>CUDA核心</strong></p>
</li>
</ol>
</li>
<li><p>CUDA核心</p>
<ol>
<li><p><strong>一个 FP Unit:</strong> 浮点数运算单元FPU；</p>
</li>
<li><p><strong>一个 INT Unit:</strong> 全流水线的整数算数逻辑单元 ALU；</p>
</li>
</ol>
</li>
</ul>
<p><strong>SM 的中文对照：</strong></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191113095019.png" width="400"/></p>
<h2 id="Kepler-架构"><a href="#Kepler-架构" class="headerlink" title="Kepler 架构"></a>Kepler 架构</h2><p>是Fermi的后代</p>
<pre><code>- 强化了SM

- 动态并行

- Hyper-Q 技术
</code></pre><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191112145014.png"/></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191112145117.png"/></p>
<p>SMX是改进的架构，支持动态创建渲染线程，以降低延迟。</p>
<p>Hyper-Q技术主要是CPU和GPU之间的同步硬件连接，以确保CPU在GPU执行的同事做更多的工作。Fermi架构下CPU控制GPU只有一个队列，Kepler架构下可以通过Hyper-Q技术实现多个队列：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191112150046.png"/></p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>想要优化速度，先要学好使用使用性能优化工具：</p>
<ul>
<li><p>nvvp</p>
</li>
<li><p>nvprof</p>
</li>
</ul>
<p>限制内核性能的主要包括但不限于y一下因素：</p>
<ul>
<li><p>存储宽带</p>
</li>
<li><p>计算资源</p>
</li>
<li><p>指令和内存延迟</p>
</li>
</ul>
]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
      </tags>
  </entry>
  <entry>
    <title>Boost编译与配置</title>
    <url>/2019/11/11/Boost%E7%BC%96%E8%AF%91%E4%B8%8E%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>Boost的下载安装与编译配置</p>
<a id="more"></a>
<p>配置boost时出现缺少“*.lib”文件解决（主要是Boost的安装和编译）</p>
<p><a href="https://www.cnblogs.com/bluedoctor/p/6236905.html" target="_blank" rel="noopener">参考</a></p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><ol>
<li>从<a href="https://www.boost.org/users/download/" target="_blank" rel="noopener">官网</a>下载原始文件:</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105000.png"/></p>
<p>这里选择红色框中的文件进行下载</p>
<h2 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h2><ol>
<li>之后将文件解压，放到任意目录，这里将文件放在C盘根目录下：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105202.png"/></p>
<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><ol>
<li>进入文件夹，先运行<code>bootstrap.bat</code></li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105340.png"/></p>
<p>运行结束后会生成 <code>b2.exe</code>可执行文件。</p>
<ol>
<li>结束之后开始菜单找到 <code>Visual Studio 2015</code>文件夹，运行目录下面的 <code>VS2015 X86 本机工具命令提示符</code>：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105440.png" height="300"/></p>
<ol>
<li>在命令窗口中定位到刚才解压的<code>boost</code>文件夹下，运行如下命令：</li>
</ol>
<p><code>b2 -j4 --debug-symbols=on --build-type=complete toolset=msvc-14.0 threading=multi runtime-link=shared address-model=32</code></p>
<p>需要等待一段时间，即可生成动态链接库</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li>在VS2015中进行配置</li>
</ol>
<p>在项目属性中进行设置，右键<code>项目</code>—&gt;<code>属性</code>—&gt;<code>配置属性</code></p>
<p>a. <code>VC++目录</code>—&gt;<code>库目录</code> —&gt; 添加路径：<code>C:\boost_1_71_0\stage\lib</code></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111110710.png"/></p>
<p>之前就是这里没有添加动态链接库所以发生了如下报错：</p>
<p><code>LNK1104    无法打开文件 libboost_thread-vc140-mt-gd-x32-1_71.lib</code></p>
<p>b. <code>C/C++</code> —&gt; <code>常规</code> —&gt; <code>附加包含目录</code>  —&gt; 添加路径： <code>C:\boost_1_71_0</code></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111110923.png"/></p>
<blockquote>
<p>注意： 一定要在项目中添加了 <code>C++</code> 文件之后，项目属性设置中才会出现 <code>C/C++</code>的选项。</p>
</blockquote>
<p>接下来程序就可以正常运行了。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>对比程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	boost::this_thread::sleep(boost::posix_time::seconds(seconds));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		wait(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	boost::<span class="function">thread <span class="title">t</span><span class="params">(threadFun)</span></span>;  <span class="comment">// 上面的那个函数</span></span><br><span class="line">	t.join();  <span class="comment">// join() 方法是一个阻塞调用：它可以暂停当前线程，直到调用 join() 的线程运行结束。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>Boost</tag>
      </tags>
  </entry>
  <entry>
    <title>20191109记录</title>
    <url>/2019/11/09/20191109%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>C++句柄、const、Boost配置、复制构造函数、列表初始化</p>
<a id="more"></a>
<h2 id="C-句柄类"><a href="#C-句柄类" class="headerlink" title="C++ 句柄类"></a>C++ 句柄类</h2><p>在容器中保存有继承关系的对象时，如果定义成保存基类对象，则派生类将被切割，如果定义成保存派生类对象，则保存基类对象又成问题（基类对象将被强制转换成派生类对象，而派生类中定义的成员未被初始化）</p>
<blockquote>
<p>注：  上面这句话还是存在疑问，关键在于容器是如何保存对象的？对基类和派生类的影<br>响具体又是什么？</p>
</blockquote>
<p><strong>所以唯一可行的选择是容器中保存对象的指针，但是需要用户管理对象和指针。C++中一个通用的技术是包装类（cover）和句柄类(handle)，使用句柄类存储和管理类指针。</strong></p>
<p>句柄类大体上完成两方面的工作：</p>
<ol>
<li><p>管理指针，这与智能指针的功能类似。</p>
</li>
<li><p>实现多态，利用动态绑定，使得指针既可以指向基类，也可以指向派生类。</p>
</li>
</ol>
<blockquote>
<p>具体的实现呢？稍后补上</p>
</blockquote>
<p><a href="https://www.cnblogs.com/zhoudayang/p/5536630.html" target="_blank" rel="noopener">参考</a></p>
<h2 id="C-构拷贝（复制）造函数"><a href="#C-构拷贝（复制）造函数" class="headerlink" title="C++构拷贝（复制）造函数"></a>C++构拷贝（复制）造函数</h2><p>声明一个类时拷贝构造函数似乎很常见，但总是不太清楚其作用是什么？为什么需要拷贝构造函数？什么情况下需要使用？</p>
<p><a href="https://www.runoob.com/cplusplus/cpp-copy-constructor.html" target="_blank" rel="noopener">参考</a></p>
<p><strong>拷贝构造函数</strong> 是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象，通常用于：</p>
<ul>
<li><p>通过使用另一个同类型的对象来初始化新创建的对象；</p>
</li>
<li><p>复制对象把它作为参数传递给函数（以值传递的方式传入函数参数）；</p>
</li>
<li><p>复制对象，并从函数返回这个对象。  </p>
</li>
</ul>
<p>拷贝构造函数接受一个以引用方式传入的当前类的对象作为参数，这个参数是源对象的别名。</p>
<p>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果 <strong>类带有指针变量，并有动态内存分配，</strong> 则它 <strong>必须</strong> 有一个拷贝构造函数。</p>
<p>常见形式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">classname (<span class="keyword">const</span> classname &amp;obj)&#123;</span><br><span class="line">    <span class="comment">//构造函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看一个例子，对比有复制构造函数和没有复制构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数声明</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	Line(<span class="keyword">int</span> len); <span class="comment">//简单的构造函数</span></span><br><span class="line">	<span class="comment">//Line(const Line &amp;obj); // 拷贝构造函数</span></span><br><span class="line">	~Line(); <span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">int</span> len) &#123;  <span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//为指针分配内存</span></span><br><span class="line">	ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*ptr = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Line::Line(const Line &amp;obj) &#123;  // 拷贝构造函数</span></span><br><span class="line"><span class="comment">//	cout &lt;&lt; "调用拷贝构造函数并为指针 ptr 分配内存" &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//	ptr = new int;</span></span><br><span class="line"><span class="comment">//	*ptr = *obj.ptr;  //拷贝值</span></span><br><span class="line"><span class="comment">//	</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">Line::~Line(<span class="keyword">void</span>) &#123; <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"释放内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Line::getLength(<span class="keyword">void</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Line obj)</span> </span>&#123; <span class="comment">//注意这里对象是以值传递的方式传入函数参数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 大小： "</span> &lt;&lt; obj.getLength() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Line <span class="title">line</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	display(line);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先会有一个输出结果：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191110131651.png" width="150"/></p>
<p>可以看到函数尝试调用两次析构函数以释放内存，但是当调用第二次析构函数时出现下面的情况：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191110131919.png" width="300" /></p>
<p>最终导致程序报错，其原因主要由下图所示：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/FFA170BA5807AF4BE58389AE931B1A71.jpg"/></p>
<p>line作为变量传入到函数 display 中时，因为是浅拷贝所以 display 函数中的形参 obj 和 line 指向了相同的内存空间，而函数中的 obj 在执行完成后释放了形参指向的内存空间，但因为 line 和 obj指向相同内存，所以当程序结束尝试释放 line 指向的内存空间时发现并没有内存可以释放，这就导致了程序的错误，所以解决的办法就是使用拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">classname (<span class="keyword">const</span> classname &amp;obj)&#123;</span><br><span class="line">    <span class="comment">//构造函数的主体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看一个例子，对比有复制构造函数和没有复制构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//成员函数声明</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	Line(<span class="keyword">int</span> len); <span class="comment">//简单的构造函数</span></span><br><span class="line">	Line(<span class="keyword">const</span> Line &amp;obj); <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	~Line(); <span class="comment">// 析构函数</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">int</span> len) &#123;  <span class="comment">//构造函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">//为指针分配内存</span></span><br><span class="line">	ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*ptr = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::Line(<span class="keyword">const</span> Line &amp;obj) &#123;  <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数并为指针 ptr 分配内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*ptr = *obj.ptr;  <span class="comment">//拷贝值</span></span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::~Line(<span class="keyword">void</span>) &#123; <span class="comment">// 析构函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"释放内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> Line::getLength(<span class="keyword">void</span>) &#123;</span><br><span class="line">	<span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Line obj)</span> </span>&#123;  <span class="comment">//注意这里对象是以值传递的方式传入函数参数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"Line 大小： "</span> &lt;&lt; obj.getLength() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="function">Line <span class="title">line</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	display(line);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">调用构造函数</span><br><span class="line">调用拷贝构造函数并为指针 ptr 分配内存</span><br><span class="line">line 大小 : 10</span><br><span class="line">释放内存</span><br><span class="line">释放内存</span><br></pre></td></tr></table></figure>
<p>可以看到成功调用了两次析构函数，一次是obj在 display中进行调用的， 另一次是程序结束 line 进行调用的，没有发生错误，安全退出，其结构如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/922622A538313F7B71563DBC99E76FCF.jpg"/></p>
<p>下面还有一个例子，看一下什么时候程序会调用拷贝构造函数：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Line</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getLength</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	Line(<span class="keyword">int</span> len);             <span class="comment">// 简单的构造函数</span></span><br><span class="line">	Line(<span class="keyword">const</span> Line &amp;obj);      <span class="comment">// 拷贝构造函数</span></span><br><span class="line">	~Line();                     <span class="comment">// 析构函数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> *ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 成员函数定义，包括构造函数</span></span><br><span class="line">Line::Line(<span class="keyword">int</span> len)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用构造函数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="comment">// 为指针分配内存</span></span><br><span class="line">	ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*ptr = len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::Line(<span class="keyword">const</span> Line &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"调用拷贝构造函数并为指针 ptr 分配内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	ptr = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">	*ptr = *obj.ptr; <span class="comment">// 拷贝值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Line::~Line(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"释放内存"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">delete</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Line::getLength(<span class="keyword">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> *ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">(Line obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"line 大小 : "</span> &lt;&lt; obj.getLength() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Line <span class="title">line1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"=========================="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	Line line2 = line1; <span class="comment">// 这里也调用了拷贝构造函数</span></span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"=========================="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	display(line1);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"=========================="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	display(line2);</span><br><span class="line">	<span class="built_in">cout</span> &lt;&lt; <span class="string">"=========================="</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后输出：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191110141851.png" width="300"/></p>
<p>在对象进行复制时因为存在拷贝复制函数，所以发生了深层拷贝，最后在析构时依次析构 line1 和 line2。</p>
<h2 id="c-函数前面和后面-使用const-的作用："><a href="#c-函数前面和后面-使用const-的作用：" class="headerlink" title="c++ 函数前面和后面 使用const 的作用："></a>c++ 函数前面和后面 使用const 的作用：</h2><p><a href="https://blog.csdn.net/smf0504/article/details/52311207" target="_blank" rel="noopener">参考</a></p>
<p>前面使用const 表示返回值为const</p>
<p>后面加 const表示函数不可以修改class的成员</p>
<p>对应下面的：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getValue2</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FunctionConst</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    FunctionConst();</span><br><span class="line">    <span class="keyword">virtual</span> ~FunctionConst();</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getValue2</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">FunctionConst::FunctionConst():value(<span class="number">100</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FunctionConst::~FunctionConst() &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated destructor stub</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> FunctionConst::getValue()&#123;</span><br><span class="line">    <span class="keyword">return</span> value;<span class="comment">//返回值是 const, 返回值是指针时，防止函数调用表达式作为左值，使得指针的内容被修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> FunctionConst::getValue2() <span class="keyword">const</span>&#123;</span><br><span class="line">    <span class="comment">//此函数不能修改class FunctionConst的成员变量 value</span></span><br><span class="line">    value = <span class="number">15</span>;<span class="comment">//错误的, 因为函数后面加 const</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="C-赋值初始化和列表初始化"><a href="#C-赋值初始化和列表初始化" class="headerlink" title="C++ 赋值初始化和列表初始化"></a>C++ 赋值初始化和列表初始化</h2><p>类的构造函数在初始化成员变量时，主要有两种方式：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 方式一</span></span><br><span class="line">CSomeClass::CSomeClass() </span><br><span class="line">&#123; </span><br><span class="line">   x=<span class="number">0</span>; </span><br><span class="line">   y=<span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二</span></span><br><span class="line"></span><br><span class="line">CSomeClass::CSomeClass() : x(<span class="number">0</span>), y(<span class="number">1</span>) </span><br><span class="line">&#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方式一我们可以称为赋值初始化，通过在函数体内进行赋值初始化，在所有数据成员被 <strong>分配内存空间后才进行的。</strong></p>
<p>方式二我们称为列表初始化，在冒号后使用初始化列表进行初始化，<strong>给数据成员分配内存空间时就进行初始化</strong></p>
<p><a href="https://blog.csdn.net/fengxinlinux/article/details/70146347" target="_blank" rel="noopener">具体</a></p>
<h2 id="配置boost时出现缺少“-lib”文件解决（主要是Boost的安装和编译）"><a href="#配置boost时出现缺少“-lib”文件解决（主要是Boost的安装和编译）" class="headerlink" title="配置boost时出现缺少“*.lib”文件解决（主要是Boost的安装和编译）"></a>配置boost时出现缺少“*.lib”文件解决（主要是Boost的安装和编译）</h2><p><a href="https://www.cnblogs.com/bluedoctor/p/6236905.html" target="_blank" rel="noopener">参考</a></p>
<p>主要纪录Boost的正确安装</p>
<ol>
<li>从<a href="https://www.boost.org/users/download/" target="_blank" rel="noopener">官网</a>下载原始文件:</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105000.png"/></p>
<p>这里选择红色框中的文件进行下载</p>
<ol>
<li>之后将文件解压，放到任意目录，这里将文件放在C盘根目录下：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105202.png"/></p>
<ol>
<li>进入文件夹，先运行<code>bootstrap.bat</code></li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105340.png"/></p>
<p>运行结束后会生成 <code>b2.exe</code>可执行文件。</p>
<ol>
<li>结束之后开始菜单找到 <code>Visual Studio 2015</code>文件夹，运行目录下面的 <code>VS2015 X86 本机工具命令提示符</code>：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111105440.png" height="300"/></p>
<ol>
<li>在命令窗口中定位到刚才解压的<code>boost</code>文件夹下，运行如下命令：</li>
</ol>
<p><code>b2 -j4 --debug-symbols=on --build-type=complete toolset=msvc-14.0 threading=multi runtime-link=shared address-model=32</code></p>
<p>需要等待一段时间，即可生成动态链接库</p>
<ol>
<li>在VS2015中进行配置</li>
</ol>
<p>在项目属性中进行设置，右键<code>项目</code>—&gt;<code>属性</code>—&gt;<code>配置属性</code></p>
<p>a. <code>VC++目录</code>—&gt;<code>库目录</code> —&gt; 添加路径：<code>C:\boost_1_71_0\stage\lib</code></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111110710.png"/></p>
<p>之前就是这里没有添加动态链接库所以发生了如下报错：</p>
<p><code>LNK1104    无法打开文件 libboost_thread-vc140-mt-gd-x32-1_71.lib</code> </p>
<p>b. <code>C/C++</code> —&gt; <code>常规</code> —&gt; <code>附加包含目录</code>  —&gt; 添加路径： <code>C:\boost_1_71_0</code></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191111110923.png"/></p>
<blockquote>
<p>注意： 一定要在项目中添加了 <code>C++</code> 文件之后，项目属性设置中才会出现 <code>C/C++</code>的选项。</p>
</blockquote>
<p>接下来程序就可以正常运行了。</p>
<p>对比程序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span> seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	boost::this_thread::sleep(boost::posix_time::seconds(seconds));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadFun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">	&#123;</span><br><span class="line">		wait(<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	boost::<span class="function">thread <span class="title">t</span><span class="params">(threadFun)</span></span>;  <span class="comment">// 上面的那个函数</span></span><br><span class="line">	t.join();  <span class="comment">// join() 方法是一个阻塞调用：它可以暂停当前线程，直到调用 join() 的线程运行结束。</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA_01组织并行线程</title>
    <url>/2019/11/09/CUDA_01%E7%BB%84%E7%BB%87%E5%B9%B6%E8%A1%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>CUDA编程中最重要的一环就是如何让数据并行计算，要想实现较为高效的并行计算就需要在CUDA编程时手动为每个数据分配线程，这就涉及到如何在不同的grid 和 block 中计算出合适线程的id号。</p>
<a id="more"></a>
<h2 id="CUDA组织并行线程"><a href="#CUDA组织并行线程" class="headerlink" title="CUDA组织并行线程"></a>CUDA组织并行线程</h2><p><a href="https://face2ai.com/cuda-f-2-3-%e7%bb%84%e7%bb%87%e5%b9%b6%e8%a1%8c%e7%ba%bf%e7%a8%8b/" target="_blank" rel="noopener">文章参考</a></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>CUDA编程中最重要的一环就是如何让数据并行计算，要想实现较为高效的并行计算就需要在CUDA编程时手动为每个数据分配线程，这就涉及到如何在不同的grid 和 block 中计算出合适线程的id号。</p>
<p>回顾GPU中一个 kernel 的大致框架：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/b8b1bdfda485204b59c940daf0f2fc7.jpg"/></p>
<p>所在一般在编程时需要事先声明grid, block, thread的大小：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">block</span><span class="params">(<span class="number">4</span>,<span class="number">2</span>)</span></span>;  <span class="comment">// 声明一个 block 其中包含 4 行 2 列 = 8 个线程</span></span><br><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;  <span class="comment">// 声明一个 grid 其中包含 2 行 3 列 = 6 个block</span></span><br><span class="line"><span class="comment">// 所以总共可分配的线程数为： 8 * 6 = 48 个</span></span><br></pre></td></tr></table></figure>
<p>所以在得到一个block中一个线程的索引号（threadIdx）后，需要还需要根据 gridDim. gridIdx, blockDim, blockIdx 计算获得其全局的索引号。详细: <a href="https://blog.csdn.net/hujingshuang/article/details/53097222#commentBox" target="_blank" rel="noopener">grid、block、thread的关系及thread索引的计算</a></p>
<p>这边以简单的二维block为例介绍：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191108160350.png"/></p>
<p>计算方式就如图中所示。</p>
<p>因为CUDA 每一个线程执行相同的代码，就是异构计算中的多线程单指令， 如果每个不同的线程执行同样的代码，又处理同一组数据，CUDA常用的做法是让不同的线程对应不同的数据，也就是用线程的全局全局标号对应不同组的数据。因为无论时设备还是主机内存都是线性存在的，比如二维矩阵 $(8 \times 6)$， 存储在内存中可能就是如下结构：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191108164506.png"/></p>
<p>我们要做的管理就是：</p>
<ul>
<li><p>矩阵和块索引（计算线程的全局索引）；</p>
</li>
<li><p>计算矩阵中给定点的坐标 (ix, iy);</p>
</li>
<li><p>(ix, iy) 对应的线性内存的位置；</p>
</li>
</ul>
<p>线性位置的计算方式：</p>
<script type="math/tex; mode=display">idx = ix + iy \times nx</script><p>这样的分配方式就将数组矩阵中 (ix, iy) 位置处的数据分配到线程标号为 ix,iy 处去计算。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>随机生成一个 6 行 8列的数组，总共有 48 个数字，如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191108170505.png"/></p>
<p>实际内存是一维线性的，如下：</p>
<script type="math/tex; mode=display">[29.6 , ... , 22.16 , 26.49 , ... , 23.45 , 30.92 , ... , ...]</script><p>block 和 grid 的大小为：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">blcok</span><span class="params">(<span class="number">4</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">dim3 <span class="title">grid</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>这里创建了一个二维block和 二维线程，即使用 2 x 3 个block ，每个 block中再开辟 4x 2 个线程， 则 2 x 3 x 4 x 2 = 48，然后将这48个数字分配进去，每个数字一个线程,就相当于每个线程进行一个数字的操作，进行的计算的并行化。</p>
<p>有如下形式：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/451431f889b05d3ae630d32f175a126.jpg"/></p>
<p>按照下面的方式打印索引：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">printThreadIndex</span><span class="params">(<span class="keyword">float</span> *A, <span class="keyword">const</span> <span class="keyword">int</span> nx, <span class="keyword">const</span> <span class="keyword">int</span> ny)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ix = threadIdx.x + blockIdx.x*blockDim.x;  </span><br><span class="line">	<span class="keyword">int</span> iy = threadIdx.y + blockIdx.y*blockDim.y;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> idx = iy * nx + ix; </span><br><span class="line"><span class="comment">//nx = 8, ny= 6 在进一步计算全局线程标号，是为了将这48个数据分别匹配到不同的线程中去</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"thread_id(%d,%d) block_id(%d,%d) coordinate(%d,%d)"</span></span><br><span class="line">		<span class="string">"global index %2d ival %2d\n"</span>, threadIdx.x, threadIdx.y,</span><br><span class="line">		blockIdx.x, blockIdx.y, ix, iy, idx, A[idx]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dim3 blcok(4,2);</span></span><br><span class="line"><span class="comment">//dim3 grid(2,3);</span></span><br><span class="line"><span class="comment">//int nx = 8;</span></span><br><span class="line"><span class="comment">//int ny = 6;</span></span><br><span class="line">printThreadIndex &lt;&lt; &lt;grid, block &gt;&gt; &gt; (A_dev, nx, ny);</span><br></pre></td></tr></table></figure>
<p>对应的计算示意图如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/a8de254c0be85b7d778bef29d5b33ca.jpg"/></p>
<p>程序打印输出结果如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191108232742.png"/></p>
<p>设置不同的block或者 grid大小，计算的性能也会不一样的，如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191109132806.png"/></p>
<p>可以看到在GPU上计算明显比CPU上计算快很多。</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><p>时间计算的比较：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"cuda_runtime.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"device_launch_parameters.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"freshman.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sumMatrix2D_CPU</span><span class="params">(<span class="keyword">float</span> * MatA, <span class="keyword">float</span> * MatB, <span class="keyword">float</span> * MatC, <span class="keyword">int</span> nx, <span class="keyword">int</span> ny)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">float</span> * a = MatA;</span><br><span class="line">	<span class="keyword">float</span> * b = MatB;</span><br><span class="line">	<span class="keyword">float</span> * c = MatC;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ny; j++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nx; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			c[i] = a[i] + b[i];</span><br><span class="line">		&#125;</span><br><span class="line">		c += nx;</span><br><span class="line">		b += nx;</span><br><span class="line">		a += nx;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">sumMatrix</span><span class="params">(<span class="keyword">float</span> * MatA, <span class="keyword">float</span> * MatB, <span class="keyword">float</span> * MatC, <span class="keyword">int</span> nx, <span class="keyword">int</span> ny)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ix = threadIdx.x + blockDim.x*blockIdx.x;</span><br><span class="line">	<span class="keyword">int</span> iy = threadIdx.y + blockDim.y*blockIdx.y;</span><br><span class="line">	<span class="keyword">int</span> idx = ix + iy * ny;</span><br><span class="line">	<span class="keyword">if</span> (ix &lt; nx &amp;&amp; iy &lt; ny)</span><br><span class="line">	&#123;</span><br><span class="line">		MatC[idx] = MatA[idx] + MatB[idx];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"strating...\n"</span>);</span><br><span class="line">	initDevice(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> nx = <span class="number">1</span> &lt;&lt; <span class="number">12</span>;  <span class="comment">//2**12 = 4096</span></span><br><span class="line">	<span class="keyword">int</span> ny = <span class="number">1</span> &lt;&lt; <span class="number">12</span>;  <span class="comment">//2**12 = 4096</span></span><br><span class="line">	<span class="keyword">int</span> nxy = nx * ny;  <span class="comment">// 4096 * 4096</span></span><br><span class="line">	<span class="keyword">int</span> nBytes = nxy * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);  <span class="comment">// nxy 共占用多少个字节</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//Malloc</span></span><br><span class="line">	<span class="keyword">float</span>* A_host = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);  <span class="comment">// 分配指针空间</span></span><br><span class="line">	<span class="keyword">float</span>* B_host = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">	<span class="keyword">float</span>* C_host = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">	<span class="keyword">float</span>* C_from_gpu = (<span class="keyword">float</span>*)<span class="built_in">malloc</span>(nBytes);</span><br><span class="line">	initialData(A_host, nxy);</span><br><span class="line">	initialData(B_host, nxy);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//cudaMalloc</span></span><br><span class="line">	<span class="keyword">float</span> *A_dev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">float</span> *B_dev = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">float</span> *C_dev = <span class="literal">NULL</span>;</span><br><span class="line">	CHECK(cudaMalloc((<span class="keyword">void</span>**)&amp;A_dev, nBytes));</span><br><span class="line">	CHECK(cudaMalloc((<span class="keyword">void</span>**)&amp;B_dev, nBytes));</span><br><span class="line">	CHECK(cudaMalloc((<span class="keyword">void</span>**)&amp;C_dev, nBytes));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	CHECK(cudaMemcpy(A_dev, A_host, nBytes, cudaMemcpyHostToDevice));</span><br><span class="line">	CHECK(cudaMemcpy(B_dev, B_host, nBytes, cudaMemcpyHostToDevice));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> dimx = <span class="number">32</span>;</span><br><span class="line">	<span class="keyword">int</span> dimy = <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// cpu compute</span></span><br><span class="line">	cudaMemcpy(C_from_gpu, C_dev, nBytes, cudaMemcpyDeviceToHost);</span><br><span class="line">	<span class="keyword">double</span> iStart = cpuSecond();</span><br><span class="line">	sumMatrix2D_CPU(A_host, B_host, C_host, nx, ny);</span><br><span class="line">	<span class="keyword">double</span> iElaps = cpuSecond() - iStart;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"CPU Execution Time elapsed %f sec\n"</span>, iElaps);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//==================================== 2d block and 2d grid ================================</span></span><br><span class="line">	<span class="function">dim3 <span class="title">block_0</span><span class="params">(dimx, dimy)</span></span>; <span class="comment">// blockDim.x = 32， blockDim.y = 32, threadIdx.x(y) in [0,31]</span></span><br><span class="line">	<span class="comment">// (nx - 1)/ block_0.x + 1 相当于 int(nx/block_0.x)</span></span><br><span class="line">	<span class="function">dim3 <span class="title">grid_0</span><span class="params">((nx - <span class="number">1</span>) / block_0.x + <span class="number">1</span>, (ny - <span class="number">1</span>) / block_0.y + <span class="number">1</span>)</span></span>; <span class="comment">//128， 128，  gridDim.x(y) = 128, blockIdx.x(y) in [0,128]</span></span><br><span class="line">	iStart = cpuSecond();</span><br><span class="line">	sumMatrix &lt;&lt; &lt;grid_0, block_0 &gt;&gt; &gt; (A_dev, B_dev, C_dev, nx, ny);</span><br><span class="line">	CHECK(cudaDeviceSynchronize());</span><br><span class="line">	iElaps = cpuSecond() - iStart;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"GPU Execution configuration grid and block shape: &lt;&lt;&lt;(%d,%d),(%d,%d)&gt;&gt;&gt; Time elapsed %f sec\n"</span>,</span><br><span class="line">		grid_0.x, grid_0.y, block_0.x, block_0.y, iElaps);</span><br><span class="line">	CHECK(cudaMemcpy(C_from_gpu, C_dev, nBytes, cudaMemcpyDeviceToHost));</span><br><span class="line">	checkResult(C_host, C_from_gpu, nxy);</span><br><span class="line">	<span class="comment">//============================================================================================</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//=====================================1d block and 1d grid ==================================</span></span><br><span class="line">	dimx = <span class="number">32</span>;</span><br><span class="line">	<span class="function">dim3 <span class="title">block_1</span><span class="params">(dimx)</span></span>;  <span class="comment">// 32</span></span><br><span class="line">	<span class="function">dim3 <span class="title">grid_1</span><span class="params">((nxy - <span class="number">1</span>) / block_1.x + <span class="number">1</span>)</span></span>;  <span class="comment">// (4096 * 4096 -1)/ 32 + 1 = 524288</span></span><br><span class="line">	iStart = cpuSecond();</span><br><span class="line">	sumMatrix &lt;&lt; &lt;grid_1, block_1 &gt;&gt; &gt; (A_dev, B_dev, C_dev, nx*ny, <span class="number">1</span>);</span><br><span class="line">	CHECK(cudaDeviceSynchronize());</span><br><span class="line">	iElaps = cpuSecond() - iStart;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"GPU Execution configuration grid and block shape: &lt;&lt;&lt;(%d,%d),(%d,%d)&gt;&gt;&gt; Time elapsed %f sec\n"</span>,</span><br><span class="line">		grid_1.x, grid_1.y, block_1.x, block_1.y, iElaps);</span><br><span class="line">	CHECK(cudaMemcpy(C_from_gpu, C_dev, nBytes, cudaMemcpyDeviceToHost));</span><br><span class="line">	checkResult(C_host, C_from_gpu, nxy);</span><br><span class="line">	<span class="comment">//============================================================================================</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//===================================== 2d block and 1d grid =================================</span></span><br><span class="line">	dimx = <span class="number">32</span>;</span><br><span class="line">	<span class="function">dim3 <span class="title">block_2</span><span class="params">(dimx)</span></span>; <span class="comment">// 32</span></span><br><span class="line">	<span class="function">dim3 <span class="title">grid_2</span><span class="params">((nx - <span class="number">1</span>) / block_2.x + <span class="number">1</span>, ny)</span></span>;  <span class="comment">// 128, 4096</span></span><br><span class="line">	iStart = cpuSecond();</span><br><span class="line">	sumMatrix &lt;&lt; &lt;grid_2, block_2 &gt;&gt; &gt; (A_dev, B_dev, C_dev, nx, ny);</span><br><span class="line">	CHECK(cudaDeviceSynchronize());</span><br><span class="line">	iElaps = cpuSecond() - iStart;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"GPU Execution configuration grid and block shape: &lt;&lt;&lt;(%d,%d),(%d,%d)&gt;&gt;&gt; Time elapsed %f sec\n"</span>,</span><br><span class="line">		grid_2.x, grid_2.y, block_2.x, block_2.y, iElaps);</span><br><span class="line">	CHECK(cudaMemcpy(C_from_gpu, C_dev, nBytes, cudaMemcpyDeviceToHost));</span><br><span class="line">	checkResult(C_host, C_from_gpu, nxy);</span><br><span class="line">	<span class="comment">//=============================================================================================</span></span><br><span class="line">	cudaFree(A_dev);</span><br><span class="line">	cudaFree(B_dev);</span><br><span class="line">	cudaFree(C_dev);</span><br><span class="line">	<span class="built_in">free</span>(A_host);</span><br><span class="line">	<span class="built_in">free</span>(B_host);</span><br><span class="line">	<span class="built_in">free</span>(C_host);</span><br><span class="line">	<span class="built_in">free</span>(C_from_gpu);</span><br><span class="line">	cudaDeviceReset();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CUDA</category>
      </categories>
      <tags>
        <tag>CUDA</tag>
        <tag>CPP</tag>
      </tags>
  </entry>
  <entry>
    <title>20191106记录</title>
    <url>/2019/11/06/20191106%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>堆、判断2的幂次方、Python线程安全</p>
<a id="more"></a>
<h2 id="Python的线程安全"><a href="#Python的线程安全" class="headerlink" title="Python的线程安全"></a>Python的线程安全</h2><p>什么是线程安全？</p>
<p>在一段程序中，如果两个线程t1,t2共享一个全局变量，且这多个线程对同一个全局变量操作会出现资源竞争的问题，从而导致结果会不正确，即遇到线程安全的问题。所以一般采用线程同步或互斥锁机制保证共享数据在任何时刻，最多有一个线程访问，以保证数据的正确性。</p>
<p>其中Python内置类型： ditc, list, tuple是线程安全的。</p>
<p><a href="https://blog.csdn.net/u010649766/article/details/79740873" target="_blank" rel="noopener">参考</a></p>
<h2 id="快速判断一个数是否是-2-的幂次方"><a href="#快速判断一个数是否是-2-的幂次方" class="headerlink" title="快速判断一个数是否是 2 的幂次方"></a>快速判断一个数是否是 2 的幂次方</h2><p>如果将这个数减去1后会发现，仅有的那个1会变为0，而原来的那n个0会变为1；因此将原来的数与去减去1后的数字进行与运算后会发现为零。<br>例如：</p>
<script type="math/tex; mode=display">1000 \& 0111 = 0000</script><p>则8(1000)就是2的幂次方。</p>
<p><a href="https://blog.csdn.net/wanrenwangxuejing/article/details/28940769" target="_blank" rel="noopener">参考</a></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p><a href="https://www.cnblogs.com/lanhaicode/p/10546257.html" target="_blank" rel="noopener">来源</a></p>
<p>堆是一种 <strong>非线性结构</strong> ，可以把堆看作一个数组，也可以被看作是一个 <strong>完全二叉树</strong> (若设二叉树的深度为h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。)， 堆其实就是 <strong>利用完全二叉树的结构来维护的一维数组。</strong></p>
<p>大顶堆： 每个节点的值都 <strong>大于或等于</strong> 其左右孩子节点的值；</p>
<p>小顶堆： 每个节点的值都 <strong>小于或等于</strong> 其左右孩子节点的值；</p>
<p>堆的这种特性非常有用，常常被当作 <strong>优先队列</strong> 使用，因为可以快速的访问到“最重要”的元素。</p>
<p><strong>堆特点：</strong></p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107131510.png"/></p>
<p>对堆中的节点按层进行编号，映射到数组中：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107131622.png"/></p>
<p>所以有如下堆的定义：</p>
<p>大顶堆：</p>
<script type="math/tex; mode=display">arr[i] \geq arr[2i+1] \&\& arr[i] \geq arr[2i+2]</script><p>小定顶堆：</p>
<script type="math/tex; mode=display">a[i] \leq arr[2i+1] \&\& arr[i] \leq arr[2i+2]</script><p><strong>堆排序的过程：</strong></p>
<p>基本思想：</p>
<ol>
<li>将待排序序列构造成一个大顶堆，此时整个序列的最大值就是堆顶的根节点。</li>
<li>将其与末尾元素进行交换，此时末尾就为最大值。</li>
<li>然后将剩余 n-1 个元素重新构造成一个堆，这样会得到 n 个元素的次小值。</li>
<li>如此反复执行，便能得到一个有序序列了，建立最大堆时是从 <strong>最后一个非叶子节点</strong> 开始从下往上调整的。</li>
</ol>
<p>升序 — 大顶堆；<br>降序 — 小顶堆；</p>
<p><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">具体步骤:</a></p>
<p><strong>步骤一： 构造初始堆，将给定的无序序列构造成一个大顶堆：</strong></p>
<ol>
<li>给定无序序列如下：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107133021.png" weight='300' height='300'/></p>
<ol>
<li>从最后一个非叶子节点(<code>arr.length/2 -1 = 5/2-1 = 1</code>，也就是下面的 6 节点)，从左至右，从下往上进行调整：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107133334.png"/></p>
<p>节点6先和其左孩子比较<code>a[2 * 1 + 1] = arr[3] =5</code> ,因为6 &gt; 5所以不作调整；<br>和其右孩子比较<code>a[2 * 1 + 2] = arr[4] =9</code>, 因为 9 &gt; 6 ，所以两者进行交换</p>
<ol>
<li>找到下一个非叶子节点，当前坐标-1即 1-1 = 0，即第二个非叶子节点为4, [4,9,8]中9元素最大， 4和9 交换：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107140047.png"/></p>
<ol>
<li>这时，交换导致了子根[4,5,6]混乱，继续调整，[4,5,6]中 6 最大，交换 4 和6：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107140247.png"/></p>
<p><strong>步骤二：将堆顶元素和末尾元素进行交换，使末尾元素最大。然后继续调整堆，再将堆顶元素与末尾元素交换，得到第二大元素。如此反复进行交换、重建、交换：</strong></p>
<ol>
<li>将堆顶元素9 和末尾元素4 进行交换：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107140902.png"/></p>
<ol>
<li>重新调整结构，使其继续满足堆定义：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107140951.png"/></p>
<ol>
<li>再将堆顶元素 8 与末尾元素 5 进行交换，得到第二大元素8：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107141044.png"/></p>
<ol>
<li>后续过程，继续进行调整、交换，如此反复，最终使得整个序列有序：</li>
</ol>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191107141321.png" width="300" /></p>
<p>代码：</p>
]]></content>
      <categories>
        <category>杂记</category>
      </categories>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title>网络编程知识点</title>
    <url>/2019/11/05/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<p>在秋招过程中根据别人整理的网络编程知识点，进行的二次整理，主要是一些高频知识点。</p>
<a id="more"></a>
<h3 id="1-TCP协议的三次握手和四次挥手"><a href="#1-TCP协议的三次握手和四次挥手" class="headerlink" title="1. TCP协议的三次握手和四次挥手"></a>1. TCP协议的三次握手和四次挥手</h3><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191012142805.png"/></p>
<ul>
<li><p>三次握手：</p>
<ol>
<li><p>c -&gt; s, 客户端向服务端发送带有SYN（同步标识位=1）的报文段seq(序号=x),c进入<code>SYN_SENT</code>状态;</p>
</li>
<li><p>s -&gt; c, 服务端接收到客户端发来的报文，检测SYN=1，知道客户端想和自己建立连接，则返回带有SYN(=1)，ACK(确认标识位=x+1)的报文段seq(=y)，s进入<code>SYN_RCVD</code>状态；</p>
</li>
<li><p>c -&gt; s，客户端检查服务端发来的信息(SYN, ACK,seq)，再向其发送ACK(=y+1)，服务端接收后检查ACK是否为y+1，是则建立链接完成三次握手,c和s都进入<code>ESTABLISHED</code>状态。</p>
</li>
</ol>
</li>
<li><p>四次挥手：</p>
<ol>
<li><p>c -&gt; s, 客户端发送带有FIN(结束标识位)的seq(=x+2), ACK(=y+1)，告诉服务端要断开连接，进入<code>FIN_WAIT_1</code>状态；</p>
</li>
<li><p>s -&gt; c, 服务端接收到FIN报文后向客户端发送ACK(=x+3)，服务器进入<code>CLOSE_WAIT</code>状态，客户端收到后进入<code>FIN_WAIT_2</code>状态；</p>
</li>
<li><p>s -&gt; c, 当服务器发送完剩下的数据后，向客户端发送带有FIN的seq(=y+1)，并进入<code>LAST_ACK</code>状态；</p>
</li>
<li><p>c -&gt; s, 客户端向服务端发送ACK(=y+2)，进入<code>TIME_WAIT</code>状态，等待2MSL(报文段最大生存时间)，没有服务端响应则关闭连接。</p>
</li>
</ol>
</li>
</ul>
<h3 id="2-一定要三次握手的原因"><a href="#2-一定要三次握手的原因" class="headerlink" title="2. 一定要三次握手的原因"></a>2. 一定要三次握手的原因</h3><p>客户端和服务端建立连接时，由于某种原因长时间驻留在网络节点中，无法达到服务器，因为TCP存在 <strong>超时重传机制</strong> ，客户端会不断尝试建立连接，直到成功。假设后面成功建立连接，传输结束断开连接后，若之前客户端发送给的连接请求又被服务端接收，则服务端会以为客户端尝试再次建立连接，如果仅存在这两次握手，则服务端会同意与客户端建立连接，并一直等待客户端的响应，但实际客户端此时已经关闭，直到超出计数器的设定值，服务端才会认为服务异常，关闭这个连接，造成计算资源的浪费，而加入第三次握手的机制由于服务端没有等到客户端的再次响应则不会再建立该连接。</p>
<h3 id="3-挥手比握手多一次的原因"><a href="#3-挥手比握手多一次的原因" class="headerlink" title="3. 挥手比握手多一次的原因"></a>3. 挥手比握手多一次的原因</h3><p>因为建立连接时，可以把SYN,ACK,seq放在同一个报文中进行传输，但是在断开连接时，服务端需要先将剩余的数据传输结束后，才能再向客户端发送FIN标识位以请求关闭连接，通常这里的ACK报文和FIN报文是分开传输的。</p>
<h3 id="4-HTTP和HTTPS"><a href="#4-HTTP和HTTPS" class="headerlink" title="4. HTTP和HTTPS"></a>4. HTTP和HTTPS</h3><p>HTTP: 是互联网上一种广泛的网络协议，是 <strong>客户端和服务端请求和应答的标准</strong></p>
<p>HTTPS: 是以安全为目标的HTTP通道，即在HTTP的三次握手后加入SSL层，主要用于1) 建立安全通道保证数据传输的安全，2) 确认网站的安全性。</p>
<p><strong>区别</strong></p>
<ol>
<li><p>HTTP协议是超文本传输协议，信息是明文传输，而HTTPS协议传输的数据是经过加密的，具有更高的安全性；</p>
</li>
<li><p>端口不同前者为80，后者是443</p>
</li>
</ol>
<h3 id="5-IP地址和MAC地址"><a href="#5-IP地址和MAC地址" class="headerlink" title="5. IP地址和MAC地址"></a>5. IP地址和MAC地址</h3><p>IP地址是IP协议提供的统一的地址格式，为互联网上每一个网络和每一台主机分配一个逻辑地址，以屏蔽物理地址的差异</p>
<p>MAC地址是一个硬件地址，用来确认网络设备位置的地址，在OSI模型中右数据连接层负责。如果一台设备有多块网卡，则每个网卡都会有一个唯一的MAC地址。</p>
<h3 id="6-打开一个网站的过程，以及其对那个的各个层的过程"><a href="#6-打开一个网站的过程，以及其对那个的各个层的过程" class="headerlink" title="6. 打开一个网站的过程，以及其对那个的各个层的过程"></a>6. 打开一个网站的过程，以及其对那个的各个层的过程</h3><ol>
<li>域名解析，浏览器获得URL地址，向操作系统请求该URL地址的IP地址，操作系统查询DNS（先查询本地HOST文件，没有则查询网络）获得对应的IP地址；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URL 分割成几个部分：协议(http(s),ftp)、网络协议(域名、IP地址、端口号)、资源路径</span><br></pre></td></tr></table></figure>
<ol>
<li>确认好IP地址和端口号后，向该IP地址对应的服务器的该端口号发起TCP连接请求；</li>
</ol>
<ol>
<li><p>服务接收到TCP连接请求后，回复可以建立连接；</p>
</li>
<li><p>浏览器收到回传的数据后，还会向服务端发送数据包，表示三次握手的结束</p>
</li>
<li><p>三次握手成功后，开始通讯，客户端根据HTTP协议的要求，组织一个请求的数据包，其中包含请求的资源路径、身份信息等，服务器响应请求，将数据返回给浏览器，浏览器根据HTML协议组织网页，以此反复；</p>
</li>
<li><p>渲染页面，响应用户的操作；</p>
</li>
<li><p>关闭网页时，断开连接。</p>
</li>
</ol>
<h3 id="7-OSI七层模型和TCP-IP四层模型，每层用到的协议"><a href="#7-OSI七层模型和TCP-IP四层模型，每层用到的协议" class="headerlink" title="7. OSI七层模型和TCP/IP四层模型，每层用到的协议"></a>7. OSI七层模型和TCP/IP四层模型，每层用到的协议</h3><h4 id="OSI-Opening-System-Interconnection-开放系统互连"><a href="#OSI-Opening-System-Interconnection-开放系统互连" class="headerlink" title="OSI(Opening System Interconnection 开放系统互连)"></a>OSI(Opening System Interconnection 开放系统互连)</h4><ul>
<li>第七层 应用层</li>
</ul>
<p>为应用软件而设的接口</p>
<pre><code>功能： 文件传输，电子邮件，文件服务等；

协议： HTTP，HTTPS，FTP
</code></pre><ul>
<li>第六层 表示层</li>
</ul>
<p>把数据转换为能与接收者的系统格式兼容并适合传输的格式</p>
<pre><code>功能： 数据格式化，代码转换，数据加密
</code></pre><ul>
<li>第五层 会话层</li>
</ul>
<p>负责在数据传输过程中设置和维护计算机网络中两台计算机之间的通信连接</p>
<pre><code>功能： 解除或建立与其他接点的联系
</code></pre><ul>
<li>第四层 传输层</li>
</ul>
<p>把传输表头加至数据以形成数据包。传输表头包含了所使用的协议等发送信息</p>
<pre><code>功能： 提供端对端的接口

协议： TCP, UDP
</code></pre><ul>
<li>第三层 网络层</li>
</ul>
<p>决定数据的路径选择和转寄，将网络表头(NH)加至数据包，以形成报文，网格表头包含了网络数据</p>
<pre><code>功能： 为数据包选择路由

协议： IP
</code></pre><ul>
<li>第二层 数据链路层</li>
</ul>
<p>负责网络寻址、错误侦测和改错</p>
<pre><code>功能： 传输有地址的帧，错误检测功能

协议： ARP, SLIP,RARP
</code></pre><ul>
<li>第一层 物理层</li>
</ul>
<p>在局部局域网上传送数据帧，负责管理计算机通信设备和网络媒体之间的互通，包括电压、网卡、主机接口卡等</p>
<pre><code>功能： 以二进制形式在物理媒体上传输数据

协议： ISO2110, IEEE802
</code></pre><h4 id="TCP-IP-4层网络模型"><a href="#TCP-IP-4层网络模型" class="headerlink" title="TCP/IP 4层网络模型"></a>TCP/IP 4层网络模型</h4><ul>
<li>第四层 应用层</li>
</ul>
<p>电子邮件，文件传输</p>
<p>网页访问使用http协议，文件传输FTP协议，电子邮件发送SMTP协议，域名解析DNS协议，远程登陆Talnet协议</p>
<ul>
<li>第三层 传输层</li>
</ul>
<p>TCP,UDP协议分析</p>
<ul>
<li>第二层 网络层</li>
</ul>
<p>检查IP地址，路由设置</p>
<ul>
<li>第一层 网络接口层</li>
</ul>
<p>ARP地址检测、物理连接检测</p>
<p>小结：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191012165823.png"/></p>
<h3 id="8-TCP和UDP"><a href="#8-TCP和UDP" class="headerlink" title="8. TCP和UDP"></a>8. TCP和UDP</h3><ol>
<li><p>TCP面向连接（如打电话要先拨号建立连接），UDP在发送数据之前不需要建立连接；</p>
</li>
<li><p>TCP更加可靠，TCP传输的数据无差错，不丢失，不重复；</p>
</li>
<li><p>UDP较好的实时性，工作效率比TCP高，适用于对高速传输和实时性较高的通信或广播通信；</p>
</li>
<li><p>每一条TCP连接只能是点对点； UDP支持一对一，一对多，多对一和多对多的交互通信；</p>
</li>
<li><p>TCP对系统资源要求较多，UDP对系统资源要求较少；</p>
</li>
<li><p>要求数据的完成性应该适用TCP，如文件的传输、重要状态的更新； 要求实时性使用UDP，如视频传输、实时通信；</p>
</li>
<li><p>TCP面向字节流，UDP面向数据包</p>
</li>
</ol>
<h3 id="9-TCP的拥塞控制"><a href="#9-TCP的拥塞控制" class="headerlink" title="9. TCP的拥塞控制"></a>9. TCP的拥塞控制</h3><ol>
<li><p>发送维护一个拥塞窗口，由小到达逐渐增加拥塞窗口，探测网络的拥塞程度</p>
</li>
<li><p>快重传和快恢， 要求接收方在收到一个失序的报文段后就立即发出重复确认而不要等到自己发送数据时捎带确认。</p>
</li>
</ol>
<h3 id="10-DNS干什么的"><a href="#10-DNS干什么的" class="headerlink" title="10. DNS干什么的"></a>10. DNS干什么的</h3><p>DNS(Domain Name System 域名系统)， 将域名和地址相互映射的一个分布式数据库，能够让人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p>主机解析域名的顺序：</p>
<p>找缓存、找本及的hosts文件、找DNS服务器</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191105212943.png"/></p>
<p><strong>根域名服务器</strong>：是互联网域名解析系统（DNS）中最高级别的域名服务器，负责返回顶级域的权威域名服务器地址，全球只有13台，中国境内是其镜像。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>网络编程</tag>
      </tags>
  </entry>
  <entry>
    <title>常见神经网络模型量估计</title>
    <url>/2019/11/05/%E5%B8%B8%E8%A7%81%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E9%87%8F%E4%BC%B0%E8%AE%A1/</url>
    <content><![CDATA[<p>对于常见的深度学习，如CNN,RNN,DNN,GRU,LSTM，如果可以在设计模型时就能设计出模型的参数量，那对于后续的性能优化、模型部署调优都会有一个直观上的感受和帮助。</p>
<a id="more"></a>
<h2 id="1-CNN参数个数"><a href="#1-CNN参数个数" class="headerlink" title="1. CNN参数个数"></a>1. CNN参数个数</h2><p>常见CNN模型一般包含以下几种类型的层：卷积层、池化层和全连接层。假设卷积核大小为H*W， input channel为I，out channel为O。</p>
<ol>
<li>卷积层(Convolutional Layer):</li>
</ol>
<p>该层filter数量总数为(H x W x I)，每个将被映射到新的输出通道上，加上每个filter的计算要有一个bias，所以总的参数数量为：(H x W x I + 1) x O</p>
<ol>
<li>池化层(Pooling Layer)：</li>
</ol>
<p>一般的池化层属于固定操作，没有权重传播</p>
<h2 id="2-全连接层参数个数"><a href="#2-全连接层参数个数" class="headerlink" title="2. 全连接层参数个数"></a>2. 全连接层参数个数</h2><p>前后是n,m维的输入输出，所以其参数数量为(n+1) x m</p>
<blockquote>
<p>以下循环神经网络均已单层为例</p>
</blockquote>
<h2 id="3-RNN参数个数"><a href="#3-RNN参数个数" class="headerlink" title="3. RNN参数个数"></a>3. RNN参数个数</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191105212219.png"/></p>
<p>图上W,U,V在RNN的每一步中都是共享的参数，所以其参数量为：</p>
<script type="math/tex; mode=display">Number = n^2+kn+nm</script><ul>
<li>n- 隐藏层的维度</li>
<li>k- 输出层的维度</li>
<li>m- 输入层的维度</li>
</ul>
<p>$n^2$ 就是 $W*W$部分<br>$kn$ 就是$WV$部分<br>$nm$ 就是$UW$部分</p>
<h2 id="4-LSTM参数个数"><a href="#4-LSTM参数个数" class="headerlink" title="4. LSTM参数个数"></a>4. LSTM参数个数</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191105210926.png"/></p>
<p>LSTM一共维护四套参数，分别对应输入门、输出门、遗忘门和候选态，总参数数量：</p>
<script type="math/tex; mode=display">Number = 4 * n * (m + 1 + n)</script><ul>
<li>n- 隐藏层的维度</li>
<li>m- 输入层的维度</li>
<li>1 表示的是偏置项</li>
</ul>
<p>例如:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line">rnn = nn.LSTM(input_size=<span class="number">100</span>, hidden_size=<span class="number">512</span>, num_layers=<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p>所以参数个数为：<script type="math/tex">4 \times 512 \times (100+1+512) = 1255424</script></p>
<h2 id="5-GRU参数个数"><a href="#5-GRU参数个数" class="headerlink" title="5. GRU参数个数"></a>5. GRU参数个数</h2><p>和LSTM类似，但是只有三套参数，更新门、重置门、候选态，总参数量为：</p>
<script type="math/tex; mode=display">Number = 3 \times n \times (m + 1 + n)</script><ul>
<li>n- 隐藏层的维度</li>
<li>m- 输入层的维度</li>
<li>1 表示的是偏置项</li>
</ul>
<ol>
<li>实验：</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModel</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>  </span><br><span class="line">        super(MyModel, self).__init__()</span><br><span class="line">        self.lstm = nn.LSTM(input_size=<span class="number">100</span>, hidden_size=<span class="number">512</span>, num_layers=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#         self.rnn = nn.RNN(input_size=100, hidden_size=512, num_layers=1)</span></span><br><span class="line"><span class="comment">#         self.gru = nn.GRU(input_size=100, hidden_size=512, num_layers=1)</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span>  </span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">net = MyModel()</span><br><span class="line">params = list(net.parameters())</span><br><span class="line">k = <span class="number">0</span></span><br><span class="line">all_num = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> params:</span><br><span class="line">    l = <span class="number">1</span></span><br><span class="line">    print(<span class="string">"该层的结构："</span> + str(list(i.size())))</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> i.size():</span><br><span class="line">        l *= j</span><br><span class="line">    print(<span class="string">"该层参数和："</span> + str(l))</span><br><span class="line">    k = k + l</span><br><span class="line">print(<span class="string">"参数总和："</span>+str(k))</span><br></pre></td></tr></table></figure>
<p>以lstm为例输出：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191012003103.png" width='200' height='200'/></p>
<p>可以看到LSTM输出比预期的参数多了 512*4 = 2048</p>
<p>同样，GRU会比预期的参数多 512*3 = 1536</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191012003245.png"/></p>
<p>似乎是多一个偏置项，但是从<a href="https://www.cnblogs.com/wushaogui/p/9176617.html" target="_blank" rel="noopener">参考连接</a>他人用keras好像没有问题，难道是框架的问题？之后再做一下实验。。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考:"></a>参考:</h2><p><a href="https://datascience.stackexchange.com/questions/10589/number-of-parameters-in-an-rnn" target="_blank" rel="noopener">RNN参数量</a></p>
<p><a href="https://blog.csdn.net/taoyafan/article/details/82803943" target="_blank" rel="noopener">LSTM参数量</a></p>
<p><a href="https://stats.stackexchange.com/questions/328926/how-many-parameters-are-in-a-gated-recurrent-unit-gru-recurrent-neural-network" target="_blank" rel="noopener">GRU参数量</a></p>
<p><a href="https://blog.csdn.net/jdzwanghao/article/details/84196239" target="_blank" rel="noopener">pytorch参数量计算</a></p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title>STL 容器记录</title>
    <url>/2019/11/04/STL%E5%AE%B9%E5%99%A8%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p>主要涉及到c++中STL容器的一些用法：vector,set,stack,queue,map,deque及Algorithm，不记得时可以随时查漏补缺。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">转载自@author 鲁伟林</span><br><span class="line">gitHub地址：https://github.com/thinkingfioa/Notes/blob/master/TechFiles/STL_Usage.md</span><br></pre></td></tr></table></figure>
<h2 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h2><h3 id="push-back-函数"><a href="#push-back-函数" class="headerlink" title="push_back()函数"></a>push_back()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector;</span><br><span class="line">myVector.push_back(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="pop-back-函数"><a href="#pop-back-函数" class="headerlink" title="pop_back()函数"></a>pop_back()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">从后往前pop</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector;</span><br><span class="line">myVector.push_back(<span class="number">100</span>);</span><br><span class="line">myVector.push_back(<span class="number">200</span>);</span><br><span class="line">myVector.push_back(<span class="number">300</span>);</span><br><span class="line"><span class="comment">//执行前: 100, 200, 300</span></span><br><span class="line">myVector.pop_back();</span><br><span class="line"><span class="comment">//执行后: 100, 200</span></span><br></pre></td></tr></table></figure></p>
<h3 id="insert-函数"><a href="#insert-函数" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">3</span>,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line">  <span class="comment">//执行前: 100, 100, 100</span></span><br><span class="line">  it = myvector.begin();</span><br><span class="line">  it = myvector.insert ( it , <span class="number">200</span> );</span><br><span class="line">  <span class="comment">//执行后: 200, 100, 100, 100</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//执行前: 200, 100, 100, 100</span></span><br><span class="line">  myvector.insert (it,<span class="number">2</span>,<span class="number">300</span>);</span><br><span class="line">  <span class="comment">//执行后: 300, 300, 200, 100, 100, 100</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">// "it" no longer valid, get a new one:</span></span><br><span class="line">  it = myvector.begin();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行前: 300, 300, 200, 100, 100, 100</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; anothervector (<span class="number">2</span>,<span class="number">400</span>);</span><br><span class="line">  myvector.insert (it+<span class="number">2</span>,anothervector.begin(),anothervector.end());</span><br><span class="line">  <span class="comment">//执行后: 300, 300, 400, 400, 200, 100, 100, 100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> myarray [] = &#123; <span class="number">501</span>,<span class="number">502</span>,<span class="number">503</span> &#125;;</span><br><span class="line">  <span class="comment">//执行前: 300, 300, 400, 400, 200, 100, 100, 100</span></span><br><span class="line">  myvector.insert (myvector.begin(), myarray, myarray+<span class="number">3</span>);</span><br><span class="line">  <span class="comment">//执行后: 501, 502, 503, 300, 300, 400, 400, 200, 100, 100, 100</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数"><a href="#erase-函数" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myVector;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">10</span>;i++) &#123;</span><br><span class="line">	myVector.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 6, 7, 8, 9</span></span><br><span class="line">myVector.erase(myVector.begin() +<span class="number">5</span>); <span class="comment">// 移除下标为5的数,也就是myVector[5]=6</span></span><br><span class="line"><span class="comment">//执行后: 1, 2, 3, 4, 5, 7, 8, 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 7, 8, 9</span></span><br><span class="line">myVector.erase(myVector.begin(), myVector.begin() + <span class="number">3</span>);</span><br><span class="line"><span class="comment">//执行后: 4, 5, 7, 8, 9</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数"><a href="#swap-函数" class="headerlink" title="swap()函数"></a>swap()函数</h3><p> 代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">3</span>,<span class="number">100</span>);   <span class="comment">// three ints with a value of 100</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bar (<span class="number">5</span>,<span class="number">200</span>);   <span class="comment">// five ints with a value of 200</span></span><br><span class="line"><span class="comment">//执行前: foo: [100, 100, 100]</span></span><br><span class="line"><span class="comment">//       bar: [200, 200, 200, 200, 200]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">//执行后: foo: [200, 200, 200, 200, 200]</span></span><br><span class="line"><span class="comment">//       bar: [100, 100, 100]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>迭代器遍历:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (it=myvector.begin(); it&lt;myvector.end(); it++)&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C++中的Set是一个有序-去重集合</span><br></pre></td></tr></table></figure>
<h3 id="insert-函数-1"><a href="#insert-函数-1" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator,<span class="keyword">bool</span>&gt; ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; ++i) myset.insert(i*<span class="number">10</span>);   </span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 30, 40, 50</span></span><br><span class="line">ret = myset.insert(<span class="number">20</span>);  <span class="comment">// no new element inserted</span></span><br><span class="line"><span class="comment">//执行后: 10, 20, 30, 40, 50</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret.second==<span class="literal">false</span>) it=ret.first;  <span class="comment">// "it" now points to element 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 30, 40, 50</span></span><br><span class="line">myset.insert (it,<span class="number">25</span>);                 <span class="comment">// max efficiency inserting</span></span><br><span class="line">myset.insert (it,<span class="number">24</span>);                 <span class="comment">// max efficiency inserting</span></span><br><span class="line">myset.insert (it,<span class="number">26</span>);                 <span class="comment">// no max efficiency inserting</span></span><br><span class="line"><span class="comment">//执行后: 10, 20, 24, 25, 26, 30, 40, 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 24, 25, 26, 30, 40, 50</span></span><br><span class="line"><span class="keyword">int</span> myints[]= &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>&#125;;              <span class="comment">// 10 already in set, not inserted</span></span><br><span class="line">myset.insert (myints,myints+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//执行后: 5, 10, 15, 20, 24, 25, 26, 30, 40, 50</span></span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数-1"><a href="#erase-函数-1" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert some values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; i++) myset.insert(i*<span class="number">10</span>);  <span class="comment">// 10 20 30 40 50 60 70 80 90</span></span><br><span class="line"></span><br><span class="line">it = myset.begin();</span><br><span class="line">++it;                                         <span class="comment">// "it" points now to 20</span></span><br><span class="line"><span class="comment">// 执行前: 10, 20, 30, 40, 50, 60, 70, 80, 90; //(*it) = 20</span></span><br><span class="line">myset.erase (it);</span><br><span class="line"><span class="comment">//执行后: 10, 30, 40, 50, 60, 70, 80, 90; </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 30, 40, 50, 60, 70, 80, 90;</span></span><br><span class="line">myset.erase (<span class="number">40</span>);</span><br><span class="line"><span class="comment">//执行后: 10, 30, 50, 60, 70, 80, 90; </span></span><br><span class="line"></span><br><span class="line">it = myset.find (<span class="number">60</span>);</span><br><span class="line"><span class="comment">//执行前: 10, 30, 50, 60, 70, 80, 90; </span></span><br><span class="line">myset.erase (it, myset.end());</span><br><span class="line"><span class="comment">//执行后: 10, 30, 50;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-1"><a href="#swap-函数-1" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[]=&#123;<span class="number">12</span>,<span class="number">75</span>,<span class="number">10</span>,<span class="number">32</span>,<span class="number">20</span>,<span class="number">25</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; first (myints,myints+<span class="number">3</span>);     <span class="comment">// 10,12,75</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; second (myints+<span class="number">3</span>,myints+<span class="number">6</span>);  <span class="comment">// 20,25,32</span></span><br><span class="line"><span class="comment">//执行前: first [10, 12, 75]</span></span><br><span class="line"><span class="comment">//        second [20, 25, 32]</span></span><br><span class="line">first.swap(second);</span><br><span class="line"><span class="comment">//执行后: first [20, 25, 32]</span></span><br><span class="line"><span class="comment">//       second [10, 12, 75]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="find-函数"><a href="#find-函数" class="headerlink" title="find()函数"></a>find()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) myset.insert(i*<span class="number">10</span>);    <span class="comment">// set: 10 20 30 40 50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行前: 10, 20, 30, 40, 50</span></span><br><span class="line">it=myset.find(<span class="number">20</span>);</span><br><span class="line">myset.erase (it);</span><br><span class="line"><span class="comment">// 执行后: 10, 30, 40, 50</span></span><br></pre></td></tr></table></figure></p>
<h3 id="count-函数"><a href="#count-函数" class="headerlink" title="count()函数"></a>count()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">由于set集合不重复，所以count(val)返回的结果只有0或者1.</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">5</span>; ++i) myset.insert(i*<span class="number">3</span>);    <span class="comment">// set: 3 6 9 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//返回结果是: 1</span></span><br><span class="line">myset.count(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//返回结果是: 0</span></span><br><span class="line">myset.count(<span class="number">5</span>);</span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-1"><a href="#遍历-1" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">75</span>,<span class="number">23</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">13</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; myset (myints,myints+<span class="number">5</span>); <span class="comment">//13, 23, 42, 65, 75</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=myset.begin(); it!=myset.end(); ++it)&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="stack"><a href="#stack" class="headerlink" title="stack"></a>stack</h2><h3 id="top-函数"><a href="#top-函数" class="headerlink" title="top()函数"></a>top()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line">mystack.push(<span class="number">10</span>);</span><br><span class="line">mystack.push(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">mystack.top() -= <span class="number">5</span>; <span class="comment">//mystack.top() 的值为20</span></span><br></pre></td></tr></table></figure></p>
<h3 id="push-函数"><a href="#push-函数" class="headerlink" title="push()函数"></a>push()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; mystack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; ++i) mystack.push(i);</span><br></pre></td></tr></table></figure></p>
<h3 id="pop-函数"><a href="#pop-函数" class="headerlink" title="pop()函数"></a>pop()函数</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">弹出栈的最上面</span><br></pre></td></tr></table></figure>
<h3 id="swap-函数-2"><a href="#swap-函数-2" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; foo,bar;</span><br><span class="line">foo.push (<span class="number">10</span>); foo.push(<span class="number">20</span>); foo.push(<span class="number">30</span>);</span><br><span class="line">bar.push (<span class="number">111</span>); bar.push(<span class="number">222</span>);</span><br><span class="line"><span class="comment">// 执行前: foo [10, 20, 30]</span></span><br><span class="line"><span class="comment">//        bar [111, 222]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">// 执行后: foo [111, 222]</span></span><br><span class="line"><span class="comment">//        bar [10, 20, 30]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-2"><a href="#遍历-2" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Popping out elements..."</span>;</span><br><span class="line"><span class="keyword">while</span> (!mystack.empty())</span><br><span class="line">&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; mystack.top();</span><br><span class="line">   mystack.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c++ 中的map是默认按照key的排序。所以每次插入都会做调整。</span><br></pre></td></tr></table></figure>
<h3 id="insert-函数-2"><a href="#insert-函数-2" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// first insert function version (single parameter):</span></span><br><span class="line">mymap.insert ( <span class="built_in">std</span>::pair&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;(<span class="string">'a'</span>,<span class="number">100</span>) );</span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数-2"><a href="#erase-函数-2" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; mymap;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line"><span class="comment">// insert some values:</span></span><br><span class="line">mymap[<span class="string">'a'</span>]=<span class="number">10</span>;</span><br><span class="line">mymap[<span class="string">'b'</span>]=<span class="number">20</span>;</span><br><span class="line">mymap[<span class="string">'c'</span>]=<span class="number">30</span>;</span><br><span class="line">mymap[<span class="string">'d'</span>]=<span class="number">40</span>;</span><br><span class="line">mymap[<span class="string">'e'</span>]=<span class="number">50</span>;</span><br><span class="line">mymap[<span class="string">'f'</span>]=<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">it=mymap.find(<span class="string">'b'</span>);</span><br><span class="line"><span class="comment">//执行前: a-&gt;10, b-&gt;20, c-&gt;30, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line">mymap.erase (it);                   <span class="comment">// erasing by iterator</span></span><br><span class="line"><span class="comment">//执行后: a-&gt;10, c-&gt;30, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: a-&gt;10, c-&gt;30, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line">mymap.erase (<span class="string">'c'</span>);                  <span class="comment">// erasing by key</span></span><br><span class="line"><span class="comment">//执行后: a-&gt;10, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line"></span><br><span class="line">it=mymap.find (<span class="string">'e'</span>);</span><br><span class="line"><span class="comment">//执行前: a-&gt;10, d-&gt;40, e-&gt;50, f-&gt;60</span></span><br><span class="line">mymap.erase ( it, mymap.end() );    <span class="comment">// erasing by range</span></span><br><span class="line"><span class="comment">//执行后: a-&gt;10, d-&gt;40</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-3"><a href="#swap-函数-3" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; foo,bar;</span><br><span class="line"></span><br><span class="line">foo[<span class="string">'x'</span>]=<span class="number">100</span>;</span><br><span class="line">foo[<span class="string">'y'</span>]=<span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">bar[<span class="string">'a'</span>]=<span class="number">11</span>;</span><br><span class="line">bar[<span class="string">'b'</span>]=<span class="number">22</span>;</span><br><span class="line">bar[<span class="string">'c'</span>]=<span class="number">33</span>;</span><br><span class="line"><span class="comment">// 执行前: foo [x-&gt;100, y-&gt;200]</span></span><br><span class="line"><span class="comment">//        bar [a-&gt;11, b-&gt;22, c-&gt;33]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">// 执行前: foo [a-&gt;11, b-&gt;22, c-&gt;33]</span></span><br><span class="line"><span class="comment">//        bar [x-&gt;100, y-&gt;200]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-3"><a href="#遍历-3" class="headerlink" title="遍历"></a>遍历</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;::iterator it=foo.begin(); it!=foo.end(); ++it) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">" =&gt; "</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="queue"><a href="#queue" class="headerlink" title="queue"></a>queue</h2><h3 id="push-函数-1"><a href="#push-函数-1" class="headerlink" title="push()函数"></a>push()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; myqueue;</span><br><span class="line">myqueue.push (myint);</span><br></pre></td></tr></table></figure></p>
<h3 id="pop-函数-1"><a href="#pop-函数-1" class="headerlink" title="pop()函数"></a>pop()函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">弹出最后一个数。</span><br></pre></td></tr></table></figure>
<h3 id="swap-函数-4"><a href="#swap-函数-4" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; foo,bar;</span><br><span class="line">foo.push (<span class="number">10</span>); foo.push(<span class="number">20</span>); foo.push(<span class="number">30</span>);</span><br><span class="line">bar.push (<span class="number">111</span>); bar.push(<span class="number">222</span>);</span><br><span class="line"><span class="comment">// 执行前: foo[10, 20, 30]</span></span><br><span class="line"><span class="comment">//        bar[111, 222]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">// 执行后: foo[111, 222]</span></span><br><span class="line"><span class="comment">//        bar[10, 20, 30]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="back-函数"><a href="#back-函数" class="headerlink" title="back()函数"></a>back()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">队列的最后一位</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myqueue.push(<span class="number">12</span>);</span><br><span class="line">myqueue.push(<span class="number">75</span>);   <span class="comment">// this is now the back</span></span><br><span class="line"><span class="comment">//执行前: 12, 75</span></span><br><span class="line">myqueue.back() -= myqueue.front();</span><br><span class="line"><span class="comment">//执行后: 12, 63</span></span><br></pre></td></tr></table></figure></p>
<h3 id="front-函数"><a href="#front-函数" class="headerlink" title="front()函数"></a>front()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">队列的队首</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">myqueue.push(<span class="number">77</span>);</span><br><span class="line">myqueue.push(<span class="number">16</span>);</span><br><span class="line"><span class="comment">//执行前: 77, 16</span></span><br><span class="line">myqueue.front() -= myqueue.back();    <span class="comment">// 77-16=61</span></span><br><span class="line"><span class="comment">//执行后: 61, 16</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-4"><a href="#遍历-4" class="headerlink" title="遍历"></a>遍历</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"myqueue contains: "</span>;</span><br><span class="line"><span class="keyword">while</span> (!myqueue.empty())</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; myqueue.front();</span><br><span class="line">  myqueue.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">双向队列</span><br></pre></td></tr></table></figure>
<h3 id="front-函数-1"><a href="#front-函数-1" class="headerlink" title="front()函数"></a>front()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回队首</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line">mydeque.push_front(<span class="number">77</span>);</span><br><span class="line">mydeque.push_back(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//执行前: 77, 20</span></span><br><span class="line">mydeque.front() -= mydeque.back();</span><br><span class="line"><span class="comment">//执行后: 57, 20</span></span><br></pre></td></tr></table></figure></p>
<h3 id="back-函数-1"><a href="#back-函数-1" class="headerlink" title="back()函数"></a>back()函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">双向队列的尾部</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line">mydeque.push_back(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (mydeque.back() != <span class="number">0</span>)</span><br><span class="line">  mydeque.push_back ( mydeque.back() <span class="number">-1</span> );</span><br></pre></td></tr></table></figure></p>
<h3 id="push-back-函数-1"><a href="#push-back-函数-1" class="headerlink" title="push_back()函数"></a>push_back()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"><span class="comment">//执行前: []</span></span><br><span class="line">mydeque.push_back(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//执行后: [1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: [1]</span></span><br><span class="line">mydeque.push_back(<span class="number">2</span>);</span><br><span class="line"><span class="comment">//执行后: [1,2]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="push-front-函数"><a href="#push-front-函数" class="headerlink" title="push_front()函数"></a>push_front()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque (<span class="number">2</span>,<span class="number">100</span>);     <span class="comment">// two ints with a value of 100</span></span><br><span class="line"><span class="comment">//执行前: 100, 100</span></span><br><span class="line">mydeque.push_front (<span class="number">200</span>);</span><br><span class="line"><span class="comment">//执行后: 200, 100, 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 200, 100, 100</span></span><br><span class="line">mydeque.push_front (<span class="number">300</span>);</span><br><span class="line"><span class="comment">//执行前: 300, 200, 100, 100</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pop-back-函数-1"><a href="#pop-back-函数-1" class="headerlink" title="pop_back()函数"></a>pop_back()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行前: </span></span><br><span class="line">mydeque.push_back (<span class="number">10</span>);</span><br><span class="line">mydeque.push_back (<span class="number">20</span>);</span><br><span class="line">mydeque.push_back (<span class="number">30</span>);</span><br><span class="line"><span class="comment">//执行后: 10, 20, 30</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 10, 20, 30</span></span><br><span class="line">mydeque.pop_back(); </span><br><span class="line"><span class="comment">//执行后: 10, 20</span></span><br></pre></td></tr></table></figure></p>
<h3 id="pop-front-函数"><a href="#pop-front-函数" class="headerlink" title="pop_front()函数"></a>pop_front()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行前: </span></span><br><span class="line">mydeque.push_back (<span class="number">100</span>);</span><br><span class="line">mydeque.push_back (<span class="number">200</span>);</span><br><span class="line">mydeque.push_back (<span class="number">300</span>);</span><br><span class="line"><span class="comment">//执行后: 100, 200, 300</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 100, 200, 300</span></span><br><span class="line">mydeque.pop_front();</span><br><span class="line"><span class="comment">//执行后: 200, 300</span></span><br></pre></td></tr></table></figure></p>
<h3 id="insert-函数-3"><a href="#insert-函数-3" class="headerlink" title="insert()函数"></a>insert()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; mydeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">// set some initial values:</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">6</span>; i++) mydeque.push_back(i); <span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = mydeque.begin();</span><br><span class="line">++it;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5</span></span><br><span class="line">it = mydeque.insert (it,<span class="number">10</span>); </span><br><span class="line"><span class="comment">//执行后: 1, 10, 2, 3, 4, 5</span></span><br><span class="line"><span class="comment">// "it" now points to the newly inserted 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 10, 2, 3, 4, 5</span></span><br><span class="line">mydeque.insert (it,<span class="number">2</span>,<span class="number">20</span>);                     <span class="comment">// 1 20 20 10 2 3 4 5</span></span><br><span class="line"><span class="comment">//执行后: 1, 20, 20, 10, 2, 3, 4, 5</span></span><br><span class="line"><span class="comment">// "it" no longer valid!</span></span><br><span class="line"></span><br><span class="line">it = mydeque.begin()+<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1, 20, 20, 10, 2, 3, 4, 5</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">2</span>,<span class="number">30</span>);</span><br><span class="line">mydeque.insert (it,myvector.begin(),myvector.end());</span><br><span class="line"><span class="comment">//执行后: 1, 20, 30, 30, 20, 10, 2, 3, 4, 5</span></span><br></pre></td></tr></table></figure></p>
<h3 id="erase-函数-3"><a href="#erase-函数-3" class="headerlink" title="erase()函数"></a>erase()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set some values (from 1 to 10)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">10</span>; i++) mydeque.push_back(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">// erase the 6th element</span></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 6, 7, 8, 9, 10</span></span><br><span class="line">mydeque.erase (mydeque.begin()+<span class="number">5</span>);</span><br><span class="line"><span class="comment">//执行后: 1, 2, 3, 4, 5, 7, 8, 9, 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// erase the first 3 elements:</span></span><br><span class="line"><span class="comment">//执行前: 1, 2, 3, 4, 5, 7, 8, 9, 10</span></span><br><span class="line">mydeque.erase (mydeque.begin(),mydeque.begin()+<span class="number">3</span>);</span><br><span class="line"><span class="comment">//执行后: 4, 5, 7, 8, 9, 10</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-5"><a href="#swap-函数-5" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">3</span>,<span class="number">100</span>);   <span class="comment">// three ints with a value of 100</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; bar (<span class="number">5</span>,<span class="number">200</span>);   <span class="comment">// five ints with a value of 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: foo [100, 100, 100]</span></span><br><span class="line"><span class="comment">//       bar [200, 200, 200, 200, 200]</span></span><br><span class="line">foo.swap(bar);</span><br><span class="line"><span class="comment">//执行后: foo [200, 200, 200, 200, 200]</span></span><br><span class="line"><span class="comment">//       bar [100, 100, 100]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="遍历-5"><a href="#遍历-5" class="headerlink" title="遍历"></a>遍历</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator it = mydeque.begin(); it!=mydeque.end(); ++it) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">' '</span> &lt;&lt; *it;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (!mydeque.empty()) &#123;</span><br><span class="line">  sum+=mydeque.back();</span><br><span class="line">  mydeque.pop_back(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="algorithm"><a href="#algorithm" class="headerlink" title="algorithm"></a>algorithm</h2><h3 id="find-函数-1"><a href="#find-函数-1" class="headerlink" title="find()函数"></a>find()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//数组中查询</span></span><br><span class="line"><span class="keyword">int</span> myints[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> * p;</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">std</span>::find (myints, myints+<span class="number">4</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (p != myints+<span class="number">4</span>)</span><br><span class="line">  <span class="comment">//输出: 30</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element not found in myints\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vector中查询</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints,myints+<span class="number">4</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"></span><br><span class="line">it = find (myvector.begin(), myvector.end(), <span class="number">30</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myvector.end())</span><br><span class="line">  <span class="comment">//输出: 30</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Element not found in myvector\n"</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="copy-函数"><a href="#copy-函数" class="headerlink" title="copy()函数"></a>copy()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[]=&#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>,<span class="number">50</span>,<span class="number">60</span>,<span class="number">70</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">7</span>);</span><br><span class="line"><span class="comment">//执行前: myvector: </span></span><br><span class="line"><span class="built_in">std</span>::copy ( myints, myints+<span class="number">7</span>, myvector.begin() );</span><br><span class="line"><span class="comment">//执行前: myvector: 10, 20, 30, 40, 50, 60, 70</span></span><br></pre></td></tr></table></figure></p>
<h3 id="swap-函数-6"><a href="#swap-函数-6" class="headerlink" title="swap()函数"></a>swap()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">10</span>, y=<span class="number">20</span>;                              <span class="comment">// x:10 y:20</span></span><br><span class="line"><span class="comment">//执行前: x:10, y:20</span></span><br><span class="line"><span class="built_in">std</span>::swap(x,y);                              <span class="comment">// x:20 y:10</span></span><br><span class="line"><span class="comment">//执行后: x:20, y:10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; foo (<span class="number">4</span>,x), bar (<span class="number">6</span>,y);       <span class="comment">// foo:4x20 bar:6x10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: foo[20, 20, 20, 20]</span></span><br><span class="line"><span class="comment">//       bar[10, 10, 10, 10]</span></span><br><span class="line"><span class="built_in">std</span>::swap(foo,bar);                          <span class="comment">// foo:6x10 bar:4x20</span></span><br><span class="line"><span class="comment">//执行前: foo[20, 20, 20, 20]</span></span><br><span class="line"><span class="comment">//       bar[10, 10, 10, 10]</span></span><br></pre></td></tr></table></figure></p>
<h3 id="count-函数-1"><a href="#count-函数-1" class="headerlink" title="count()函数"></a>count()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">20</span>&#125;;   <span class="comment">// 8 elements</span></span><br><span class="line"><span class="comment">//记录数组myints中，10的个数</span></span><br><span class="line"><span class="keyword">int</span> mycount = <span class="built_in">std</span>::count (myints, myints+<span class="number">8</span>, <span class="number">10</span>);</span><br><span class="line"><span class="comment">//输出结果 mycount = 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);</span><br><span class="line"><span class="comment">//记录数组myvector中，20的个数</span></span><br><span class="line">mycount = <span class="built_in">std</span>::count (myvector.begin(), myvector.end(), <span class="number">20</span>);</span><br><span class="line"><span class="comment">//记录数组myvector中，20的个数</span></span><br></pre></td></tr></table></figure></p>
<h3 id="replace-函数"><a href="#replace-函数" class="headerlink" title="replace()函数"></a>replace()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> myints[] = &#123; <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">30</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">20</span> &#125;;</span><br><span class="line"><span class="comment">//执行前: myvector: []</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);            </span><br><span class="line"><span class="comment">//执行后: myvector: 10, 20, 30, 30, 20, 10, 10, 20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: myvector: 10, 20, 30, 30, 20, 10, 10, 20</span></span><br><span class="line"><span class="built_in">std</span>::replace (myvector.begin(), myvector.end(), <span class="number">20</span>, <span class="number">99</span>); </span><br><span class="line"><span class="comment">//执行前: myvector: 10, 99, 30, 30, 99, 10, 10, 99</span></span><br></pre></td></tr></table></figure></p>
<h3 id="fill-函数"><a href="#fill-函数" class="headerlink" title="fill()函数"></a>fill()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//执行前 myvector: []</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (<span class="number">8</span>);                      </span><br><span class="line"><span class="comment">//执行后 myvector: 0,0,0,0,0,0,0,0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前 myvector: 0,0,0,0,0,0,0,0</span></span><br><span class="line"><span class="built_in">std</span>::fill (myvector.begin(),myvector.begin()+<span class="number">4</span>,<span class="number">5</span>);   </span><br><span class="line"><span class="comment">//执行后 myvector: 5,5,5,5,0,0,0,0</span></span><br><span class="line"><span class="comment">//执行后 myvector: 5,5,5,5,0,0,0,0</span></span><br><span class="line">  <span class="built_in">std</span>::fill (myvector.begin()+<span class="number">3</span>,myvector.end()<span class="number">-2</span>,<span class="number">8</span>); </span><br><span class="line"><span class="comment">//执行后 myvector: 5,5,5,8,8,8,0,0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="reverse-函数"><a href="#reverse-函数" class="headerlink" title="reverse()函数"></a>reverse()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;<span class="number">10</span>; ++i) myvector.push_back(i);   <span class="comment">// 1 2 3 4 5 6 7 8 9</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//执行前: 1,2,3,4,5,6,7,8,9</span></span><br><span class="line"><span class="built_in">std</span>::reverse(myvector.begin(),myvector.end());    <span class="comment">// 9 8 7 6 5 4 3 2 1</span></span><br><span class="line"><span class="comment">//执行后: 9,8,7,6,5,4,3,2,1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="sort-函数"><a href="#sort-函数" class="headerlink" title="sort()函数"></a>sort()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myfunction</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//升序</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myclass</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> (i&lt;j);&#125;</span><br><span class="line">&#125; myobject;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> myints[] = &#123;<span class="number">32</span>,<span class="number">71</span>,<span class="number">12</span>,<span class="number">45</span>,<span class="number">26</span>,<span class="number">80</span>,<span class="number">53</span>,<span class="number">33</span>&#125;;</span><br><span class="line">  <span class="comment">//执行前: myvector: []</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; myvector (myints, myints+<span class="number">8</span>);             </span><br><span class="line">  <span class="comment">//执行后: myvector: 32,71,12,45,26,80,53,33</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//缺省的排序是升序(&lt;)</span></span><br><span class="line">  <span class="comment">//执行前: 32,71,12,45,26,80,53,33</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin(), myvector.begin()+<span class="number">4</span>);          </span><br><span class="line">  <span class="comment">//执行后: 12,32,45,71,26,80,53,33</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行前: 12,32,45,71,26,80,53,33 using function as comp</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin()+<span class="number">4</span>, myvector.end(), myfunction); </span><br><span class="line">  <span class="comment">//执行后: 12,32,45,71,26,33,53,80</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// using object as comp</span></span><br><span class="line">  <span class="comment">//执行后: 12,32,45,71,26,33,53,80</span></span><br><span class="line">  <span class="built_in">std</span>::sort (myvector.begin(), myvector.end(), myobject);   </span><br><span class="line">  <span class="comment">//执行后: 12,26,32,33,45,53,71,80</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="merge函数"><a href="#merge函数" class="headerlink" title="merge函数"></a>merge函数</h3><p>代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">将两个有序的组合sort1[], sort2[]。归并成一个新的有序组合。</span><br></pre></td></tr></table></figure><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> first[] = &#123;<span class="number">5</span>,<span class="number">10</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">25</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> second[] = &#123;<span class="number">50</span>,<span class="number">40</span>,<span class="number">30</span>,<span class="number">20</span>,<span class="number">10</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::sort (first,first+<span class="number">5</span>);</span><br><span class="line"><span class="built_in">std</span>::sort (second,second+<span class="number">5</span>);</span><br><span class="line"><span class="comment">//执行前: first: 5,10,15,20,25</span></span><br><span class="line"><span class="comment">//       second: 10,20,30,40,50</span></span><br><span class="line"><span class="comment">//       v:[]</span></span><br><span class="line"><span class="built_in">std</span>::merge (first,first+<span class="number">5</span>,second,second+<span class="number">5</span>,v.begin());</span><br><span class="line"><span class="comment">//执行后: first: 5,10,15,20,25</span></span><br><span class="line"><span class="comment">//       second: 10,20,30,40,50</span></span><br><span class="line"><span class="comment">//       v:5,10,10,15,20,20,25,30,40,50</span></span><br></pre></td></tr></table></figure></p>
<h3 id="min-函数"><a href="#min-函数" class="headerlink" title="min()函数"></a>min()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出: 1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min(1,2)=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>  </span><br><span class="line"><span class="comment">//输出: 1</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min(2,1)=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="number">2</span>,<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 'a'</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min('a','z')=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="string">'a'</span>,<span class="string">'z'</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 2.72</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"min(3.14,2.72)=="</span> &lt;&lt; <span class="built_in">std</span>::min(<span class="number">3.14</span>,<span class="number">2.72</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="max-函数"><a href="#max-函数" class="headerlink" title="max()函数"></a>max()函数</h3><p>代码:<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//输出: 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(1,2)=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="number">1</span>,<span class="number">2</span>) &lt;&lt; <span class="string">'\n'</span>  </span><br><span class="line"><span class="comment">//输出: 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(2,1)=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="number">2</span>,<span class="number">1</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 'z'</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max('a','z')=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="string">'a'</span>,<span class="string">'z'</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"><span class="comment">//输出: 3.14</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"max(3.14,2.72)=="</span> &lt;&lt; <span class="built_in">std</span>::max(<span class="number">3.14</span>,<span class="number">2.72</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>cpp</category>
      </categories>
      <tags>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title>图论算法记录</title>
    <url>/2019/11/03/%E5%9B%BE%E8%AE%BA%E7%AE%97%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>主要以有向加权图为主，涉及到 <strong>图的几种常见表示方法</strong>、<strong>拓扑排序</strong>、<strong>弗洛伊德算法(Floyd)算法</strong>、 <strong>狄克斯特拉(dijkstra)算法</strong>、 <strong>SPFA算法</strong>、<strong>贝尔曼-福特(Bellman-Ford)算法</strong></p>
<a id="more"></a>
<h2 id="图的常见表示方法"><a href="#图的常见表示方法" class="headerlink" title="图的常见表示方法"></a>图的常见表示方法</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151010.png" heigt='400' width='400'/></p>
<h3 id="1-邻接矩阵："><a href="#1-邻接矩阵：" class="headerlink" title="1. 邻接矩阵："></a>1. 邻接矩阵：</h3><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151027.png" heigt='400' width='400'/></p>
<h3 id="2-邻接表："><a href="#2-邻接表：" class="headerlink" title="2. 邻接表："></a>2. 邻接表：</h3><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151035.png" heigt='400' width='400'/></p>
<h3 id="3-边缘列表"><a href="#3-边缘列表" class="headerlink" title="3. 边缘列表"></a>3. 边缘列表</h3><p>在刷题的时候经常以这种形式给出，可以将其转换乘邻接表或者邻接矩阵</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103151044.png" heigt='350' width='350'/></p>
<p><a href="https://blog.csdn.net/woaidapaopao/article/details/51732947" target="_blank" rel="noopener">完整</a></p>
<h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/ca22fa351d5278e95c4c8c94aba6da42ae45d465ff3e8e82149777274293e194-0210.gif" alt=""></p>
<p>其简单思路就是先找到入度为0 的节点，并将该节点放入队列中，同时将与他相邻的节点的入度减一，以此往复，如果最后所有节点的入度都为零则说明可以完成拓扑排序，否则该图不能进行拓扑排序</p>
<p>具体的算法流程如下：</p>
<ol>
<li><p>在算法开始前，扫描对应的存储空间(使用邻接表)，将入度为 0 的节点放入队列中</p>
</li>
<li><p>只要队列非空，就从队首取出入度为0 的节点，并且将这个结点的所有邻接结点（它指向的结点）的入度减1，在减 1 以后，如果这个被减 1 的结点的入度为 0 ，就继续入队。</p>
</li>
<li><p>队列为空时，检查结果集是否满足要求</p>
</li>
</ol>
<p>除了需要保存入度为0 的队列，还需要两个辅助的数据结构：</p>
<pre><code>1). 邻接表：通过节点的索引，能够得到这个节点的后继节点；

2). 入度数组：通过节点的索引能够得到指向这个节点的节点个数
</code></pre><h3 id="leetcode207-课程表"><a href="#leetcode207-课程表" class="headerlink" title="leetcode207 课程表"></a>leetcode207 课程表</h3><ul>
<li>题目描述：</li>
</ul>
<p>现在你总共有 n 门课需要选，记为 0 到 n-1。</p>
<p>在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]</p>
<p>给定课程总量以及它们的先决条件，判断是否可能完成所有课程的学习？</p>
<ul>
<li><p>示例 1:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0]] </span><br><span class="line">输出: true</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。</span><br></pre></td></tr></table></figure>
</li>
<li><p>示例 2:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: 2, [[1,0],[0,1]]</span><br><span class="line">输出: false</span><br><span class="line">解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。</span><br></pre></td></tr></table></figure>
<p>来源：力扣（LeetCode）</p>
</li>
</ul>
<p>链接：<a href="https://leetcode-cn.com/problems/course-schedule" target="_blank" rel="noopener">https://leetcode-cn.com/problems/course-schedule</a></p>
<p>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p>
<ul>
<li>解题</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123; </span><br><span class="line">    <span class="comment">//输入prerequisites是边缘列表</span></span><br><span class="line">    <span class="keyword">int</span> clen = prerequisites.size(); <span class="comment">//课程的长度</span></span><br><span class="line">    <span class="keyword">if</span> (clen == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 课程长度为零，所以肯定可以学习完</span></span><br><span class="line">    <span class="comment">//1.初始化入度的数组 和 邻接表数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses); <span class="comment">//入度数组，初始化为0</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(numCourses); <span class="comment">//邻接表数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clen; ++i) &#123;</span><br><span class="line">        indegree[prerequisites[i][<span class="number">0</span>]] += <span class="number">1</span>;  <span class="comment">//统计每个顶点的度</span></span><br><span class="line">        adj[prerequisites[i][<span class="number">1</span>]].push_back(prerequisites[i][<span class="number">0</span>]); <span class="comment">// 创建邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 创建队列，在拓扑排序之前，将所有入度为0的顶点存入队列中</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; myqueue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">            myqueue.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3. 开始拓扑排序，主要是遍历前面的邻接表，然后找到表中顶点对应的入度，对入度减一操作，若检测到入度为0时则推入队列中，准备输出（删除）</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!myqueue.empty()) &#123;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">int</span> top = myqueue.front(); <span class="comment">// 得到首元素</span></span><br><span class="line">        myqueue.pop();  <span class="comment">//删除首元素</span></span><br><span class="line">        <span class="comment">//vector&lt;int&gt; tmp = adj[top];</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = adj[top].begin(); iter != adj[top].end(); ++iter) &#123;</span><br><span class="line">            --indegree[*iter];</span><br><span class="line">            <span class="keyword">if</span> (indegree[*iter] == <span class="number">0</span>)</span><br><span class="line">                myqueue.push(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count == numCourses;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="leetcode210-课程表2"><a href="#leetcode210-课程表2" class="headerlink" title="leetcode210 课程表2"></a>leetcode210 课程表2</h3><p>和前面一样不同的是需要把课程表输出</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; findOrder(<span class="keyword">int</span> numCourses, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisities) &#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">//1. 初始化入度数组和邻接表'</span></span><br><span class="line">    <span class="keyword">if</span> (prerequisities.size() == <span class="number">0</span>) &#123;  <span class="comment">// 如果prerequisities大小为零，没有特别说明课程完成的先后顺序，则所有课程都能完成</span></span><br><span class="line">        <span class="keyword">while</span>(numCourses &gt;<span class="number">0</span>)</span><br><span class="line">            res.push_back(--numCourses);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; indegree(numCourses); <span class="comment">//入度数组</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; adj(numCourses); <span class="comment">//邻接表数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prerequisities.size(); ++i) &#123;</span><br><span class="line">        indegree[prerequisities[i][<span class="number">0</span>]] += <span class="number">1</span>;  <span class="comment">// 入度+1</span></span><br><span class="line">        adj[prerequisities[i][<span class="number">1</span>]].push_back(prerequisities[i][<span class="number">0</span>]); <span class="comment">// 扩展邻接表</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2. 创建队列，将度为0的元素推入队列中</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Myqueue;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; indegree.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)</span><br><span class="line">            Myqueue.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3. 统计每个顶点的度，判断是否为零，减一和push进入队列中</span></span><br><span class="line">    <span class="keyword">while</span> (!Myqueue.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = Myqueue.front();</span><br><span class="line">        res.push_back(top);</span><br><span class="line">        Myqueue.pop();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter = adj[top].begin(); iter != adj[top].end(); ++iter) &#123;</span><br><span class="line">            --indegree[*iter];</span><br><span class="line">            <span class="keyword">if</span> (indegree[*iter] == <span class="number">0</span>)</span><br><span class="line">                Myqueue.push(*iter);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (res.size() != numCourses)</span><br><span class="line">        res = &#123;&#125;;  <span class="comment">// 输出空数组</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="弗洛伊德算法-Floyd"><a href="#弗洛伊德算法-Floyd" class="headerlink" title="弗洛伊德算法(Floyd)"></a>弗洛伊德算法(Floyd)</h2><p>弗洛伊德算法是经典的 <strong>多源最短路径</strong> 算法，可以正确处理有向图或有向图的负权，但不可存在负权回路的最短路径问题，同时也被用于计算有向图的传递闭包。 </p>
<ul>
<li>大概思路：</li>
</ul>
<p>定义两个二维矩阵D和P， D记录顶点间的最小路径，P记录顶点间最小路径中的中转点<br>通过三重循环，k为中转点，v为起点，w为终点，循环比较D[v][w] 和 D[v][k]+D[k][w]最小值，如果后者更小则替换前者</p>
<ul>
<li>具体：</li>
</ul>
<p>矩阵 D 记录顶点间的最小路径<br>例如 D[0][3]= 10，说明顶点 0  到  3  的最短路径为 10；<br>矩阵 P 记录顶点间最小路径中的中转点<br>例如 P[0][3]= 1  说明，0  到  3 的最短路径轨迹为：0 -&gt; 1 -&gt; 3。<br>它通过 3 重循环，k 为中转点，v 为起点，w 为终点，循环比较 D[v][w]  和  D[v][k] + D[k][w]最小值，如果 D[v][k] + D[k][w]  为更小值，则把 D[v][k] + D[k][w]  覆盖保存在 D[v][w]中。</p>
<ul>
<li>步骤演示：</li>
</ul>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/Floyd算法.PNG" height='800' width='400'/></p>
<p><a href="https://www.cnblogs.com/dzzy/p/5097009.html" target="_blank" rel="noopener">图片来源</a></p>
<h3 id="leetcode743-网络延迟时间"><a href="#leetcode743-网络延迟时间" class="headerlink" title="leetcode743 网络延迟时间"></a>leetcode743 网络延迟时间</h3><p>输入： times[i] = (u,v,w)，分别表示源节点、目标节点、它们之间的传递时间；  N：网络节点的个数， K表示测试时的起始节点<br>范围： N:[1,100], K:[1,N], times:[1,6000], 1 &lt;= u,v&lt;= N ,0 &lt;= w &lt;= 100<br>输出： 如果可以使所有节点都收到信号则返回总的时间，如果不能则返回-1</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime_Floyd</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建二维稀疏矩阵表示 ==&gt; 邻接矩阵</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">-1</span>)); <span class="comment">// 创建二维vector 并初始化为-1表示永远不会到达</span></span><br><span class="line">    <span class="comment">//填充邻接矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        v[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">        v[times[i][<span class="number">0</span>]][times[i][<span class="number">1</span>]] = times[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//接下来进入Floyd算法的三重循环</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= N ; ++k) &#123;  <span class="comment">//这里的小k表示的就是中间节点，尝试使用每个中间节点进行替换</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= N; ++j) &#123;</span><br><span class="line">                <span class="comment">//当满足下面的条件时，使用中间节点进行替换</span></span><br><span class="line">                <span class="comment">//1. 中间节点不为-1，即i -&gt; k 和 k -&gt; j 这条有向边是存在的</span></span><br><span class="line">                <span class="comment">//2. 在满足条件1 的基础上，经过中间节点花费的时间可以比原来小，或者 原来的有向边不存在</span></span><br><span class="line">                <span class="keyword">if</span> (v[i][k] != <span class="number">-1</span> &amp;&amp; v[k][j] != <span class="number">-1</span> &amp;&amp; (v[i][j] &gt; v[i][k] + v[k][j] || v[i][j] == <span class="number">-1</span>))</span><br><span class="line">                    v[i][j] = v[i][k] + v[k][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//通过上面的三重循环，就将每个节点之间的最短通路找到了（如果存在的话）</span></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//因为最后的结果是要返回从该节点K出发遍历所有节点所花费的时间</span></span><br><span class="line">    <span class="comment">//所以首先判断是否为-1以此判断K是否可以联通所有节点，如果存在存在-1说明此路不通直接返回-1；</span></span><br><span class="line">    <span class="comment">//否则，将最大的那个值输出，因为最大值表示从K出发经过了所有的节点累加得到的路径长度，符合最后的要求</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[K][i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//说明这个节点是走不通的</span></span><br><span class="line">        res = max(res, v[K][i]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="狄克斯特拉算法-Dijkstra"><a href="#狄克斯特拉算法-Dijkstra" class="headerlink" title="狄克斯特拉算法(Dijkstra)"></a>狄克斯特拉算法(Dijkstra)</h2><p>最经典的 <strong>单源最短路径</strong> (一个点到其余各个顶点的最短路径)算法，适用于边权为正的无向和有向图，不适用于有负边权的图.</p>
<p>基本思想：</p>
<p>每次找到离源点最近的一个顶点，然后以该顶点为中心进行扩展，最终得到源点到其余所有点的最短路径。</p>
<p>基本步骤：</p>
<ol>
<li><p>将所有顶点分为两部分：已知最短路程的顶点集合P和未知最短路程的顶点集合Q。最开始，已知最短路径的顶点集合P中只有源点一个顶点。这里使用一个book[i]数组来记录哪些点在集合P中。例如对于某个顶点i，如果book[i]=1则表示这个顶点在集合P中，book[i]=0则表示这个顶点在集合Q中；</p>
</li>
<li><p>设置源点s到自己的最短路径为0即dis=0。若存在源点能直接到达顶点i，则把dis[i]设为e[s][i]，同时把所有其它（源点不能直接到达的）顶点的最短路径设置为 $ \infty$；</p>
</li>
<li><p>在集合Q的所有顶点选择一个离源点s最近的顶点u（即dis[u]最小）加入到集合P。并考察所有以点u为起点的边，对每一条边进行松弛操作。例如存在一条边从 u到v的边，那么可以通过将边 u -&gt; v添加到尾部来拓展一条从s 到v的路径，这条路径的长度是 dis[u]+e[u][v]，如果这个值比目前已知的dis[v]的值要小，可以用这个新值代替dis[v]中的值；</p>
</li>
<li><p>重复第三步，如果集合Q为空，算法结束。最终dis 数组中的值就是源点到所有顶点的最短路径。</p>
</li>
</ol>
<ul>
<li>步骤演示：</li>
</ul>
<p>给出下图：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.1.png" alt=""></p>
<p>创建邻接矩阵：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.2.png" alt=""></p>
<p>使用一个一维数组dis存储1号顶点到其余各个顶点的初始路程:</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.3.png" alt=""></p>
<p>找到离1号顶点最近的顶点，首先就是其本身，因为其操作没有特殊性，直接参考后续步骤。然后找到的最近顶点为2，然后查看2号顶点的出边有： 2-&gt;3, 2-&gt;4这两条边。先讨论2-&gt;3这条边能否让1号顶点到3号顶点的路程变短，也就是比较dis[3] 和 dis[2] + e[2][3]的大小，发现 12 &gt; 1+9，所以dis[3]更新为10,同理分析 2-&gt;4这条边， dis[4] = $ \infty$ &gt; dis[2] + e[2][4] = 4 所以dis[4] = 4，dis更新如下：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.4.png" alt=""></p>
<p>继续在 3,4,5,6顶点中查找离1号顶点最近的点，发现是4号顶点，其出边为 4-&gt;3, 4-&gt;5, 4-&gt;6。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于4 -&gt;3 ,dis[3] = 10 &gt; dis[4] + e[4][3] = 8,故 dis[3]更新为8;</span><br><span class="line">对于4-&gt;5, dis[5] = inf &gt; dis[4] + e[4][5] = 17, 故 dis[5] = 17;</span><br><span class="line">同理 dis[6] = 19</span><br></pre></td></tr></table></figure><br>所以dis更新如下：<br><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.5.png" alt=""></p>
<p>继续在3,5,6中查找离1号顶点最近的点，发现是3号顶点，其出边为 3-&gt;5。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 -&gt; 5， dis[5] = 17 &gt; dis[3] + e[3][5] = 13，故dis[5] = 13</span><br></pre></td></tr></table></figure><br>所以dis更新如下：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.6.png" alt="">（图中6号节点对应的19，背景应该是白色的）</p>
<p>继续在5,6中查找，最近点为5，其出边为 5-&gt;6：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5-&gt;6, dis[6] = 19 &gt; dis[5] + e[5][6] = 17，dis[6] = 17</span><br></pre></td></tr></table></figure></p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.7.png" alt=""></p>
<p>最后对顶点6进行松弛，发现没有出边故不处理，最终dis数组如下，这便是1号顶点到其余各个顶点的最短路径：</p>
<p><img src="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/images/7.8.png" alt=""></p>
<p><a href="http://wiki.jikexueyuan.com/project/easy-learn-algorithm/dijkstra.html" target="_blank" rel="noopener">参考</a></p>
<h3 id="leetcode743-网络延时时间"><a href="#leetcode743-网络延时时间" class="headerlink" title="leetcode743 网络延时时间"></a>leetcode743 网络延时时间</h3><p>前面使用了Floyd算法求解，这里使用Dijkstra算法求解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime_Dijkstra</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建邻接矩阵</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">-1</span>)); <span class="comment">//使用-1代替无穷大值，可能会有些许麻烦，之后尝试替换为 MAX_INT</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">        v[times[i][<span class="number">0</span>]][times[i][<span class="number">1</span>]] = times[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; S(N + <span class="number">1</span>, <span class="number">-1</span>), T(N + <span class="number">1</span>, <span class="number">-1</span>); <span class="comment">//S为确定数组，T为估计数组</span></span><br><span class="line">    <span class="comment">//根据单源节点填充数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v[K][i] != <span class="number">-1</span>)</span><br><span class="line">            T[i] = v[K][i];</span><br><span class="line">    &#125;</span><br><span class="line">    T[K] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到距离单元节点最短距离的节点</span></span><br><span class="line">    <span class="keyword">int</span> minVal = <span class="number">-1</span>,minIndex = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N; ++c) &#123;</span><br><span class="line">        minVal = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (T[i] != <span class="number">-1</span> &amp;&amp; S[i] == <span class="number">-1</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minVal == <span class="number">-1</span> || T[i] &lt; minVal) &#123;</span><br><span class="line">                    minVal = T[i];</span><br><span class="line">                    minIndex = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        S[minIndex] = minVal; <span class="comment">// 确定值</span></span><br><span class="line">        <span class="comment">// 以这个节点(minIndex)出发，找到其每个出边，并和原始距离进行比较，更新数组 T(估计数组)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[minIndex][i] != <span class="number">-1</span> &amp;&amp; (minVal + v[minIndex][i] &lt; T[i] || T[i] == <span class="number">-1</span>))</span><br><span class="line">                T[i] = minVal + v[minIndex][i]; <span class="comment">// 估计值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; S.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (S[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        res = max(res, S[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里使用-1 代替了 inf ，后续尝试修改成inf</span></span><br></pre></td></tr></table></figure>
<p><a href="https://leetcode-cn.com/problems/network-delay-time/solution/c-bellman-forddijkstrafloydspfa-by-gez1994/" target="_blank" rel="noopener">解题参考</a></p>
<h2 id="SPFA算法"><a href="#SPFA算法" class="headerlink" title="SPFA算法"></a>SPFA算法</h2><p>SPFA算法是 <strong>单源最短路径</strong> 算法，是Bellman-ford队列优化，和BFS的关系密切，相较于狄克斯特拉算法，<strong>边的权重可以是负数</strong>、实现简单，但是时间复杂度过高。</p>
<ul>
<li>基本思路：</li>
</ul>
<p>使用一个先进先出的队列保存待优化的节点，优化时每次取出队首的节点 u ，并且对于 u 的所有出边所指向的节点v进行松弛操作，如果 v 点的最短路径估计值有所调整且v 点不在当前队列中，就将 v 点放入队尾。这样不断从队列中取出节点来进行松弛操作，直至队列为空。</p>
<ul>
<li>步骤：</li>
</ul>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20191103124821.png"/></p>
<h3 id="leetcode743-网络延时时间-1"><a href="#leetcode743-网络延时时间-1" class="headerlink" title="leetcode743 网络延时时间"></a>leetcode743 网络延时时间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networdDelay_SPFA</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T(N + <span class="number">1</span>, <span class="number">-1</span>);  <span class="comment">//估计值</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Flag(N + <span class="number">1</span>, <span class="number">-1</span>);  <span class="comment">// 用来标记节点是否在队列中</span></span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Myqueue;  <span class="comment">//队列</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; v(N + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N + <span class="number">1</span>, <span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">        v[times[i][<span class="number">0</span>]][times[i][<span class="number">1</span>]] = times[i][<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i)</span><br><span class="line">        v[i][i] = <span class="number">0</span>;</span><br><span class="line">    T[K] = <span class="number">0</span>;</span><br><span class="line">    Myqueue.push(K);  </span><br><span class="line">    Flag[K] = <span class="number">0</span>; <span class="comment">// </span></span><br><span class="line">    <span class="keyword">while</span> (!Myqueue.empty()) &#123;  <span class="comment">//只要队列不为空就一直循环</span></span><br><span class="line">        <span class="keyword">int</span> u = Myqueue.front();</span><br><span class="line">        Myqueue.pop();</span><br><span class="line">        Flag[u] = <span class="number">-1</span>; <span class="comment">//此时tmp 不在队列中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v[u][i] != <span class="number">-1</span> &amp;&amp;( T[i] &gt; T[u] + v[u][i]  ||  T[i] == <span class="number">-1</span>))&#123;</span><br><span class="line">                T[i] = T[u] + v[u][i];</span><br><span class="line">                <span class="keyword">if</span> (Flag[i] == <span class="number">-1</span>) &#123;<span class="comment">//说明此时这个节点i不在队列中</span></span><br><span class="line">                    Myqueue.push(i);</span><br><span class="line">                    Flag[i] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        res = max(res, T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="贝尔曼-福特算法-Bellman-Ford"><a href="#贝尔曼-福特算法-Bellman-Ford" class="headerlink" title="贝尔曼-福特算法(Bellman-Ford)"></a>贝尔曼-福特算法(Bellman-Ford)</h2><p><a href="https://juejin.im/post/5b77fec1e51d4538cf53be68" target="_blank" rel="noopener">参考</a></p>
<p>其原理是对图进行最多n-1次松弛操作，得到所有可能的最短路径。其边的权重可以是负数，实现简单但是复杂度过高，复杂度为$O(NE)$ 其中N为顶点个数，E为边数。</p>
<p>基本思路：</p>
<ol>
<li><p>初始化时将起点s 到各顶点v的距离dis(s-&gt;v)赋值为 $\infty$，dis(s-&gt;s)赋值为0；</p>
</li>
<li><p>后续进行最多n-1 次遍历，对所有边进行松弛操作；</p>
</li>
<li><p>遍历都结束，若再进行一次遍历，还能得到s 到某些节点更短路径的话，就说明存在负环路（负环路会随着遍历次数的增加而不断减小）</p>
</li>
</ol>
<p>思路上与狄克斯特拉算法最大的不同是每次都是从源点s 重新出发进行 “松弛”更新操作，而狄克斯特拉算法则是从源点出发向外扩逐个处理相邻（最近）的节点。</p>
<h3 id="leetcode743-网络延时时间-2"><a href="#leetcode743-网络延时时间-2" class="headerlink" title="leetcode743 网络延时时间"></a>leetcode743 网络延时时间</h3><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4. Bellman-Ford算法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">networdDelay_BellmanFord</span><span class="params">(<span class="built_in">vector</span> &lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> N, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; T(N + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">    T[K] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; N - <span class="number">1</span>; ++c) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> src = times[i][<span class="number">0</span>], target = times[i][<span class="number">1</span>], dis = times[i][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (T[src] != <span class="number">-1</span> &amp;&amp; (T[src] + dis &lt; T[target] || T[target] == <span class="number">-1</span>)) &#123;</span><br><span class="line">                T[target] = T[src] + dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (T[i] == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        res = max(res, T[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法与数据结构</category>
      </categories>
      <tags>
        <tag>cpp</tag>
        <tag>数据结构</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
