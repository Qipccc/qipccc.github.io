<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png">
  <link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#222">
  <link rel="alternate" href="/atom.xml" title="Odyssey" type="application/atom+xml">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: true,
    mediumzoom: false,
    lazyload: false,
    pangu: true,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    translation: {
      copy_button: '复制',
      copy_success: '复制成功',
      copy_failure: '复制失败'
    },
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="利用计算机视觉技术，对贴砖过程的进行实时校准">
<meta name="keywords" content="机械臂">
<meta property="og:type" content="article">
<meta property="og:title" content="URVision">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;01&#x2F;URVision&#x2F;index.html">
<meta property="og:site_name" content="Odyssey">
<meta property="og:description" content="利用计算机视觉技术，对贴砖过程的进行实时校准">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;PositionInitialize.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;GetPlacePos.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;GeneratePath.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;soogif.gif">
<meta property="og:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;urgif.gif">
<meta property="og:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;贴砖策略示意图.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;20200105135628.png">
<meta property="og:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;20200105135721.png">
<meta property="og:image" content="https:&#x2F;&#x2F;torsteinmyhre.name&#x2F;snippets&#x2F;robcam_calibration&#x2F;images&#x2F;extrinsic-camera-calibration-eye-in-hand-651px.png">
<meta property="og:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;calibrate1.png">
<meta property="og:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;calibrate2.png">
<meta property="og:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;threetype.PNG">
<meta property="og:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;threetype.PNG">
<meta property="og:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;postype1.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;postype0.jpg">
<meta property="og:updated_time" content="2020-01-05T05:57:31.695Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;qipccc-alipic.oss-cn-shanghai.aliyuncs.com&#x2F;images&#x2F;PositionInitialize.jpg">

<link rel="canonical" href="http://yoursite.com/2019/12/01/URVision/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: false,
    isPost: true,
    isPage: false,
    isArchive: false
  };
</script>

  <title>URVision | Odyssey</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Odyssey</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">qipccc的博客</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/12/01/URVision/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="qipccc">
      <meta itemprop="description" content="风雨兼程">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Odyssey">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          URVision
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-12-01 19:40:14" itemprop="dateCreated datePublished" datetime="2019-12-01T19:40:14+08:00">2019-12-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-01-05 13:57:31" itemprop="dateModified" datetime="2020-01-05T13:57:31+08:00">2020-01-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9C%BA%E6%A2%B0%E8%87%82/" itemprop="url" rel="index">
                    <span itemprop="name">机械臂</span>
                  </a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>32k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>54 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>利用计算机视觉技术，对贴砖过程的进行实时校准</p>
<a id="more"></a>
<h1 id="0-基于视觉的UR10机器人贴砖系统"><a href="#0-基于视觉的UR10机器人贴砖系统" class="headerlink" title="0. 基于视觉的UR10机器人贴砖系统"></a>0. 基于视觉的UR10机器人贴砖系统</h1><p>前言: 利用计算机视觉技术，对贴砖过程的进行实时校准。当前文档记录的机器人还是处在固定位置，还没有移动底座，以及视觉相关的算法。接下主要包含两个部分，一个是<a href="##1.UR控制">UR控制部分</a>，一个是<a href="##2.UR视觉">UR视觉部分</a>。控制部分主要按照两个部分来介绍，一个是接收数据部分，接收数据部分现在是通过TCP/IP直接在Processing中读取机箱中的相关数值；另一个是机器人路径规划以及发送数据，控制机器人运动和IO相关的部分，这部分主要在Grasshopper中完成，之后也会脱离GH。</p>
<h1 id="1-UR控制"><a href="#1-UR控制" class="headerlink" title="1.UR控制"></a>1.UR控制</h1><p>UR的脚本编程语言很简单，相关文档可以参考<a href="https://s3-eu-west-1.amazonaws.com/ur-support-site/18679/scriptmanual_en.pdf" target="_blank" rel="noopener">英文文档</a>,<a href="https://github.com/Qipccc/learning-note/blob/master/URControl/doc/%E8%84%9A%E6%9C%AC%E6%89%8B%E5%86%8C_%E4%B8%AD%E6%96%87_3.1%20.pdf" target="_blank" rel="noopener">中文文档</a>。在这里因为是直接利用taco，所以没有太多的涉及。</p>
<h2 id="1-1读取数据"><a href="#1-1读取数据" class="headerlink" title="1.1读取数据"></a>1.1读取数据</h2><p>通过UR的30001或30002或30003特定的编程端口，可以与机器人控制器建立TCP/IP连接，这样我们就可以在上位机上按照URScript语言的格式编写脚本程序，直接发送给机器人控制器，机器人就可以直接执行程序了。可以参考<a href="http://www.ecnc.org.cn/equipment/robot/2015/2015311793_2.html" target="_blank" rel="noopener">这里</a>，但是其中的字节顺序表是存在问题的，可以参考<a href="https://github.com/Qipccc/learning-note/blob/master/URControl/doc/UR%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%E5%9C%B0%E5%9D%80.xlsx" target="_blank" rel="noopener">官方的字节顺序表</a>。</p>
<p>下面给出python和java的两个例子：</p>
<blockquote>
<p>python</p>
</blockquote>
<p>主要先用socket读取机箱数据，然后使用struct库对获得的数据流进行解包。struct相关例子可以参考<a href="https://www.cnblogs.com/gala/archive/2011/09/22/2184801.html" target="_blank" rel="noopener">这里</a>。简单的读取UR机箱数据例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket, math, time</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">HOST = <span class="string">"10.10.30.2"</span>   <span class="comment">#机箱的IP地址</span></span><br><span class="line">PORT_30003 = <span class="number">30003</span></span><br><span class="line">joins = []</span><br><span class="line">coordinates = []</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span><br><span class="line">    print(<span class="string">"start"</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">     s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">     s.settimeout(<span class="number">10</span>)</span><br><span class="line">     s.connect((HOST, PORT_30003))</span><br><span class="line">     time.sleep(<span class="number">1.00</span>)</span><br><span class="line">     packet_1 = s.recv(<span class="number">12</span>) </span><br><span class="line">     <span class="comment">#Joint A1</span></span><br><span class="line">     packet_3 = s.recv(<span class="number">8</span>)       </span><br><span class="line">     a1 = struct.unpack(<span class="string">'!d'</span>, packet_3)[<span class="number">0</span>]</span><br><span class="line">     joins.append(a1) </span><br><span class="line">     <span class="comment">#Joint A2</span></span><br><span class="line">     packet_4 = s.recv(<span class="number">8</span>)</span><br><span class="line">     a2 = struct.unpack(<span class="string">'!d'</span>, packet_4)[<span class="number">0</span>]</span><br><span class="line">     joins.append(a2)</span><br><span class="line">     <span class="comment">#Joint A3</span></span><br><span class="line">     packet_5 = s.recv(<span class="number">8</span>)</span><br><span class="line">     a3 = struct.unpack(<span class="string">'!d'</span>, packet_5)[<span class="number">0</span>]</span><br><span class="line">     joins.append(a3)</span><br><span class="line">     <span class="comment">#Joint A4</span></span><br><span class="line">     packet_6 = s.recv(<span class="number">8</span>)</span><br><span class="line">     a4 = struct.unpack(<span class="string">'!d'</span>, packet_6)[<span class="number">0</span>]</span><br><span class="line">     joins.append(a4)</span><br><span class="line">     <span class="comment">#Joint A5</span></span><br><span class="line">     packet_7 = s.recv(<span class="number">8</span>)</span><br><span class="line">     a5 = struct.unpack(<span class="string">'!d'</span>, packet_7)[<span class="number">0</span>]</span><br><span class="line">     joins.append(a5)</span><br><span class="line">     <span class="comment">#Joint A6</span></span><br><span class="line">     packet_8 = s.recv(<span class="number">8</span>)</span><br><span class="line">     a6 = struct.unpack(<span class="string">'!d'</span>, packet_8)[<span class="number">0</span>]</span><br><span class="line">     joins.append(a6)            </span><br><span class="line">     <span class="comment">#Skip</span></span><br><span class="line">     packet_9 = s.recv(<span class="number">528</span>)</span><br><span class="line">     <span class="comment">#X</span></span><br><span class="line">     packet_20 = s.recv(<span class="number">8</span>)</span><br><span class="line">     x = struct.unpack(<span class="string">'!d'</span>, packet_20)[<span class="number">0</span>]</span><br><span class="line">     x *= <span class="number">1000</span></span><br><span class="line">     coordinates.append(x)</span><br><span class="line">     <span class="comment">#Y</span></span><br><span class="line">     packet_21 = s.recv(<span class="number">8</span>)</span><br><span class="line">     y = struct.unpack(<span class="string">'!d'</span>, packet_21)[<span class="number">0</span>]</span><br><span class="line">     y *= <span class="number">1000</span></span><br><span class="line">     coordinates.append(y)</span><br><span class="line">     <span class="comment">#Z</span></span><br><span class="line">     packet_22 = s.recv(<span class="number">8</span>)</span><br><span class="line">     z = struct.unpack(<span class="string">'!d'</span>, packet_22)[<span class="number">0</span>]</span><br><span class="line">     z *= <span class="number">1000</span></span><br><span class="line">     coordinates.append(z)</span><br><span class="line">     <span class="comment">#RX</span></span><br><span class="line">     packet_23 = s.recv(<span class="number">8</span>)</span><br><span class="line">     rx = struct.unpack(<span class="string">'!d'</span>, packet_23)[<span class="number">0</span>]            </span><br><span class="line">     coordinates.append(rx)</span><br><span class="line">     <span class="comment">#RY</span></span><br><span class="line">     packet_24 = s.recv(<span class="number">8</span>)</span><br><span class="line">     ry = struct.unpack(<span class="string">'!d'</span>, packet_24)[<span class="number">0</span>]</span><br><span class="line">     coordinates.append(ry)</span><br><span class="line">     <span class="comment">#RZ</span></span><br><span class="line">     packet_25 = s.recv(<span class="number">8</span>)</span><br><span class="line">     rz = struct.unpack(<span class="string">'!d'</span>, packet_25)[<span class="number">0</span>]</span><br><span class="line">     coordinates.append(rz)      </span><br><span class="line">     UR_Joints = joins</span><br><span class="line">     UR_TCP = coordinates</span><br><span class="line">     s.close()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        print(<span class="string">"Error: "</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>java</p>
</blockquote>
<p>这里接收数据流主要使用的是java中的DataInputStream相关函数，processing官方也给出了有关socket的<a href="https://processing.org/reference/libraries/net/Client.html" target="_blank" rel="noopener">介绍</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//与UR建立通讯 对其进行控制</span></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.DataInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.UnknownHostException;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">URCommunication</span></span>&#123;</span><br><span class="line">  String host;</span><br><span class="line">  <span class="keyword">int</span> port;</span><br><span class="line">  DataInputStream is;</span><br><span class="line">  OutputStream out;</span><br><span class="line">  Socket s;</span><br><span class="line">  ArrayList&lt;Double&gt; get_pose = <span class="keyword">new</span> ArrayList&lt;Double&gt;();<span class="comment">//机器人姿态数据</span></span><br><span class="line">  ArrayList&lt;Double&gt; get_joint = <span class="keyword">new</span> ArrayList&lt;Double&gt;(); <span class="comment">//机器人关节位置</span></span><br><span class="line">  <span class="keyword">int</span> digital_output; <span class="comment">//机器人数字输出</span></span><br><span class="line">  <span class="keyword">float</span> tcp_speed = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">URCommunication</span><span class="params">(String host)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.host = host;</span><br><span class="line">    <span class="keyword">this</span>.port = <span class="number">30003</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      s = <span class="keyword">new</span> Socket(host,port);</span><br><span class="line">      s.setSoTimeout(<span class="number">2000</span>);</span><br><span class="line">      is = <span class="keyword">new</span> DataInputStream(s.getInputStream());</span><br><span class="line">      </span><br><span class="line">      out = s.getOutputStream(); <span class="comment">//向UR写数据</span></span><br><span class="line">      </span><br><span class="line">      is.skipBytes(<span class="number">12</span>); <span class="comment">//跳过前12个字节</span></span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; <span class="number">6</span>;i++)&#123; <span class="comment">//读取6个轴的信息</span></span><br><span class="line">        <span class="keyword">double</span> a = is.readDouble();</span><br><span class="line">        get_joint.add(a);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      is.skipBytes(<span class="number">528</span>);</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; <span class="number">6</span>;i++)&#123; <span class="comment">//读取姿态信息的信息</span></span><br><span class="line">        <span class="keyword">double</span> x;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">3</span>)&#123;</span><br><span class="line">          x = is.readDouble() * <span class="number">1000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          x = is.readDouble();</span><br><span class="line">        &#125;</span><br><span class="line">        get_pose.add(x);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">double</span> x = is.readDouble();</span><br><span class="line">        <span class="keyword">float</span> x_f = (<span class="keyword">float</span>)x;</span><br><span class="line">        tcp_speed = tcp_speed + x_f*x_f;</span><br><span class="line">      &#125;</span><br><span class="line">      tcp_speed = sqrt(tcp_speed);</span><br><span class="line">      </span><br><span class="line">      is.skipBytes(<span class="number">360</span>); <span class="comment">//跳过456个字节</span></span><br><span class="line">      digital_output = (<span class="keyword">int</span>)is.readDouble(); <span class="comment">//得到数字输出</span></span><br><span class="line">      </span><br><span class="line">    &#125;<span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">   &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closing_io</span><span class="params">(<span class="keyword">int</span> io_num)</span></span>&#123;</span><br><span class="line">    String io_num_str = str(io_num);</span><br><span class="line">    PrintWriter bufw=<span class="keyword">new</span> PrintWriter(out,<span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    bufw.println(<span class="string">"set_digital_out("</span> + io_num_str +<span class="string">",False)"</span>);<span class="comment">//发送数据给服务端</span></span><br><span class="line">    println(<span class="string">"closing success"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">   </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">closeUR</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      s.close();</span><br><span class="line">    &#125;<span class="keyword">catch</span> (UnknownHostException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">   &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">   &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>当然其实通过端口30003不仅可以读取数据，也是可以发送数据，以达到控制UR的效果，简单的命令基本通过发送字符串就可以实现，当然在python中还有一个<a href="https://github.com/SintefManufacturing/python-urx" target="_blank" rel="noopener">URX</a>库，可以实现对UR的控制，功能也比较齐全，之后也会使用这个库做些尝试。</p>
<h2 id="1-2发送数据-机器人规划"><a href="#1-2发送数据-机器人规划" class="headerlink" title="1.2发送数据(机器人规划)"></a>1.2发送数据(机器人规划)</h2><p>发送数据即为目前的控制部分，这部分主要是由Grasshopper部分完成，之后会使用python + urx完成控制路径的规划，这里主要介绍一些目前的几个部分，以及控制逻辑。<br>总体流程是：</p>
<ul>
<li><p>信息初始化，生成瓷砖抓取位置，并根据一些初始化信息计算出之后每块瓷砖大概放置位置</p>
</li>
<li><p>放置初始瓷砖，并让机器人移动至下一个位置</p>
</li>
<li><p>到达指定位置后，等待接收processing发出的信号</p>
</li>
<li><p>接收processing的信号，进行下一步移动</p>
</li>
</ul>
<h3 id="1-2-1初始化"><a href="#1-2-1初始化" class="headerlink" title="1.2.1初始化"></a>1.2.1初始化</h3><p>主要进行一下的一些初始化：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/PositionInitialize.jpg"/></p>
<p>需要说明的是 <strong>水平方向点</strong>，该点是瓷砖水平方向上的一个点，通过人为设置，主要用来设置贴砖的方向。<strong>移动平面</strong> 高度是指机器人吸取瓷砖后在这个平面高度移动瓷砖到指定的位置。</p>
<h3 id="1-2-2-生成瓷砖吸取位置"><a href="#1-2-2-生成瓷砖吸取位置" class="headerlink" title="1.2.2 生成瓷砖吸取位置"></a>1.2.2 生成瓷砖吸取位置</h3><p>将初始吸砖位置、排列砖的列数和行数，以及砖的厚度发送到后面的 <code>C#</code> 代码中(代码如下)，可以得到瓷砖的排列高度。这些高度都是以点的形式存在。<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Point3d&gt; listPickPos = <span class="keyword">new</span> List&lt;Point3d&gt;();</span><br><span class="line">    <span class="keyword">int</span> n = width * height;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">      listPickPos.Add(<span class="keyword">new</span> Point3d(pickPos.X, pickPos.Y, pickPos.Z + (i * thickness)));</span><br><span class="line">    &#125;</span><br><span class="line">    A = listPickPos;</span><br></pre></td></tr></table></figure><br>有了这些信息，就可以在知道要贴第几块砖的情况下，告诉UR到达指定高度吸取瓷砖。</p>
<h3 id="1-2-3生成放置瓷砖位置"><a href="#1-2-3生成放置瓷砖位置" class="headerlink" title="1.2.3生成放置瓷砖位置"></a>1.2.3生成放置瓷砖位置</h3><p>GH中的电池如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/GetPlacePos.jpg"/></p>
<p>简单来说就是根据在初始瓷砖的基础上，在规定的方向上，每隔一定间隔放置一块瓷砖，这个间隔由前面设置的瓷砖的宽度决定。最后就会输出一些点，这些表示每一块瓷砖应该放置的大概位置。</p>
<h3 id="1-2-4由点生成路径"><a href="#1-2-4由点生成路径" class="headerlink" title="1.2.4由点生成路径"></a>1.2.4由点生成路径</h3><p>在得到吸取瓷砖和放置瓷砖的点集后即可以生成机器人运动路径和I/O控制命令。GH中的电池图如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/GeneratePath.jpg"/></p>
<p><strong>注意</strong> 其中的number，指的是从processing获得的第几块砖的信息。有了这个信息才能准确的生成对应的放置瓷砖的位置。</p>
<p>该段代码目前由<code>C#</code>编写，如下：<br><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">RunScript</span>(<span class="params"><span class="keyword">bool</span> reset, List&lt;Point3d&gt; pickPos, DataTree&lt;Point3d&gt; placePos, <span class="keyword">double</span> height, <span class="keyword">double</span> height2, <span class="keyword">int</span> number, <span class="keyword">ref</span> <span class="keyword">object</span> P, <span class="keyword">ref</span> <span class="keyword">object</span> O, <span class="keyword">ref</span> <span class="keyword">object</span> S</span>)</span></span><br><span class="line"><span class="function"></span>  &#123;</span><br><span class="line">    <span class="keyword">int</span> picknum = pickPos.Count;</span><br><span class="line">    List&lt;Point3d&gt; robotPath = <span class="keyword">new</span> List&lt;Point3d&gt;(); <span class="comment">//运动路径</span></span><br><span class="line">    List&lt;<span class="keyword">string</span>&gt; io = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;(); <span class="comment">//io信号控制</span></span><br><span class="line">    List&lt;<span class="keyword">string</span>&gt; sleep = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;(); <span class="comment">//延时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">string</span> waitTime = <span class="string">"1"</span>; <span class="comment">//电缸运动时间，用时间控制电缸的行程</span></span><br><span class="line">    <span class="keyword">int</span> last_index = pickPos.Count - <span class="number">1</span>; <span class="comment">// 瓷砖的总高度</span></span><br><span class="line">    <span class="keyword">int</span> BranchCount = placePos.BranchCount; <span class="comment">//放置瓷砖的brach个数,可以理解为行数</span></span><br><span class="line">    <span class="keyword">int</span> ListPointNum = placePos.Branch(<span class="number">0</span>).Count;</span><br><span class="line">    <span class="keyword">int</span> index_row = number / ListPointNum; <span class="comment">//判断现在是第几行</span></span><br><span class="line">    <span class="keyword">int</span> index_col = number % ListPointNum; <span class="comment">//判断现在是第几列</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = number;  <span class="comment">//目前贴的是第几块瓷砖</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!reset)&#123;</span><br><span class="line">      count = <span class="number">0</span>;</span><br><span class="line">      robotPath = <span class="keyword">new</span> List&lt;Point3d&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">0</span>)&#123;  <span class="comment">//Robot Path for first pannel</span></span><br><span class="line">      Print(<span class="string">"HELLO FIRST PATH"</span>);</span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(pickPos[<span class="number">0</span>].X, pickPos[<span class="number">0</span>].Y, pickPos[<span class="number">0</span>].Z + height)); <span class="comment">//初始位置高度</span></span><br><span class="line">      robotPath.Add(pickPos[last_index]); <span class="comment">//到达第一个瓷砖位置位置</span></span><br><span class="line">      io.Add(<span class="string">"set_digital_out(3,True)"</span>); <span class="comment">// 电缸回收，吸取瓷砖</span></span><br><span class="line">      sleep.Add(<span class="string">"sleep("</span> + waitTime + <span class="string">")"</span>); <span class="comment">//控制行程</span></span><br><span class="line">      io.Add(<span class="string">"set_digital_out(3,False)"</span>); <span class="comment">//电缸结束控制</span></span><br><span class="line"></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(pickPos[<span class="number">0</span>].X, pickPos[<span class="number">0</span>].Y, pickPos[<span class="number">0</span>].Z + height)); <span class="comment">//回到吸瓷砖的初始高度</span></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(placePos.Branch(<span class="number">0</span>)[<span class="number">0</span>].X, placePos.Branch(<span class="number">0</span>)[<span class="number">0</span>].Y, placePos.Branch(<span class="number">0</span>)[<span class="number">0</span>].Z + height2)); <span class="comment">//到达放瓷砖的一个高度位置</span></span><br><span class="line">      robotPath.Add(placePos.Branch(<span class="number">0</span>)[<span class="number">0</span>]); <span class="comment">//到达放瓷砖的位置</span></span><br><span class="line">      io.Add(<span class="string">"set_digital_out(2,True)"</span>); <span class="comment">//电缸伸出，放置瓷砖</span></span><br><span class="line">      sleep.Add(<span class="string">"sleep(1)"</span>);</span><br><span class="line">      io.Add(<span class="string">"set_digital_out(2,False)"</span>);</span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(placePos.Branch(<span class="number">0</span>)[<span class="number">0</span>].X, placePos.Branch(<span class="number">0</span>)[<span class="number">0</span>].Y, placePos.Branch(<span class="number">0</span>)[<span class="number">0</span>].Z + height2)); <span class="comment">//回到放瓷砖的一个高度位置</span></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(pickPos[<span class="number">0</span>].X, pickPos[<span class="number">0</span>].Y, pickPos[<span class="number">0</span>].Z + height));<span class="comment">//回到吸瓷砖的初始高度</span></span><br><span class="line">      robotPath.Add(pickPos[last_index - <span class="number">1</span>]);<span class="comment">//到达第二块瓷砖吸取位置</span></span><br><span class="line">      io.Add(<span class="string">"set_digital_out(3,True)"</span>); <span class="comment">// 电缸回收，吸取瓷砖</span></span><br><span class="line">      sleep.Add(<span class="string">"sleep("</span> + waitTime + <span class="string">")"</span>); <span class="comment">//控制行程</span></span><br><span class="line">      io.Add(<span class="string">"set_digital_out(3,False)"</span>); <span class="comment">//电缸结束控制</span></span><br><span class="line"></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(pickPos[<span class="number">0</span>].X, pickPos[<span class="number">0</span>].Y, pickPos[<span class="number">0</span>].Z + height));</span><br><span class="line"></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(placePos.Branch(<span class="number">0</span>)[<span class="number">1</span>].X, placePos.Branch(<span class="number">0</span>)[<span class="number">1</span>].Y, placePos.Branch(<span class="number">0</span>)[<span class="number">1</span>].Z + height2));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(count &gt; <span class="number">0</span> &amp;&amp; count &lt; pickPos.Count - <span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">      robotPath = <span class="keyword">new</span> List&lt;Point3d&gt;(); <span class="comment">//clean path</span></span><br><span class="line">      io = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">      sleep = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">      Print(<span class="string">"GOT POSITION FROM PROCESSING !!"</span>);</span><br><span class="line">      io.Add(<span class="string">"set_digital_out(2,True)"</span>); <span class="comment">//电缸伸出，放置瓷砖</span></span><br><span class="line">      sleep.Add(<span class="string">"sleep(1)"</span>);</span><br><span class="line">      io.Add(<span class="string">"set_digital_out(2,False)"</span>);</span><br><span class="line"></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(placePos.Branch(index_row)[index_col].X, placePos.Branch(index_row)[index_col].Y, placePos.Branch(index_row)[index_col].Z + height2));</span><br><span class="line"></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(pickPos[<span class="number">0</span>].X, pickPos[<span class="number">0</span>].Y, pickPos[<span class="number">0</span>].Z + height));</span><br><span class="line"></span><br><span class="line">      robotPath.Add(pickPos[last_index - count - <span class="number">1</span>]);</span><br><span class="line">      io.Add(<span class="string">"set_digital_out(3,True)"</span>); <span class="comment">// 电缸回收，吸取瓷砖</span></span><br><span class="line">      sleep.Add(<span class="string">"sleep("</span> + waitTime + <span class="string">")"</span>); <span class="comment">//控制行程</span></span><br><span class="line">      io.Add(<span class="string">"set_digital_out(3,False)"</span>); <span class="comment">//电缸结束控制</span></span><br><span class="line"></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(pickPos[<span class="number">0</span>].X, pickPos[<span class="number">0</span>].Y, pickPos[<span class="number">0</span>].Z + height));</span><br><span class="line">      <span class="keyword">if</span>(index_col + <span class="number">1</span> &lt; ListPointNum)&#123;</span><br><span class="line">        robotPath.Add(<span class="keyword">new</span> Point3d(placePos.Branch(index_row)[index_col + <span class="number">1</span>].X, placePos.Branch(index_row)[index_col + <span class="number">1</span>].Y, placePos.Branch(index_row)[index_col + <span class="number">1</span>].Z + height2));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        robotPath.Add(<span class="keyword">new</span> Point3d(placePos.Branch(index_row + <span class="number">1</span>)[<span class="number">0</span>].X, placePos.Branch(index_row + <span class="number">1</span>)[<span class="number">0</span>].Y, placePos.Branch(index_row + <span class="number">1</span>)[<span class="number">0</span>].Z + height2));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count == pickPos.Count - <span class="number">1</span>)&#123;</span><br><span class="line">      robotPath = <span class="keyword">new</span> List&lt;Point3d&gt;(); <span class="comment">//clean path</span></span><br><span class="line">      io = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">      sleep = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line">      Print(<span class="string">"GOT POSITION FROM PROCESSING ,the last one!!"</span>);</span><br><span class="line"></span><br><span class="line">      io.Add(<span class="string">"set_digital_out(2,True)"</span>); <span class="comment">//电缸伸出，放置瓷砖</span></span><br><span class="line">      sleep.Add(<span class="string">"sleep(1)"</span>);</span><br><span class="line">      io.Add(<span class="string">"set_digital_out(2,False)"</span>);</span><br><span class="line"></span><br><span class="line">      robotPath.Add(<span class="keyword">new</span> Point3d(pickPos[<span class="number">0</span>].X, pickPos[<span class="number">0</span>].Y, pickPos[<span class="number">0</span>].Z + height)); <span class="comment">//回到吸瓷砖的初始高度</span></span><br><span class="line">    &#125;</span><br><span class="line">    P = robotPath;</span><br><span class="line">    O = io;</span><br><span class="line">    S = sleep;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>最后会输出全部的路径点、I/O信号以及延时信号。<br>关于路径点，简单来说可以分成两个部分，一个部分是贴第一块瓷砖的路径，包含10个点；另一个部分是放下瓷砖后回去取下一个瓷砖并达到指定拍摄位置的路径，这中间包含5个点。</p>
<blockquote>
<p><strong>第一部分</strong></p>
</blockquote>
<p>初始位置是处于较高处的一个平面，最后会停留在第二块瓷砖放置位置的上方进行拍照获得特征信息，由特征信息对机器人姿态进行纠正，到达放置位置，等待放置瓷砖的信号.</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/soogif.gif"/></p>
<p>接收到放置瓷砖的信号后，机器人末端工具头就会放下瓷砖，然后进入第二部分。</p>
<blockquote>
<p><strong>第二部分</strong></p>
</blockquote>
<p>放下瓷砖后，机器人会先进行太高，然后吸取第二块瓷砖，最后到达下一块瓷砖放置位置的上方。</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/urgif.gif"/></p>
<p>之后的每一块瓷砖的放置都是循环第二部分。</p>
<h3 id="1-2-5接收Processing数据"><a href="#1-2-5接收Processing数据" class="headerlink" title="1.2.5接收Processing数据"></a>1.2.5接收Processing数据</h3><p>在接收processing数据部分，目前是设置了两个端口，一个端口用来接收瓷砖的纠正数据，该数据用来旋转或平移瓷砖以达到贴合的目的，但 <strong>注意</strong> 此时的瓷砖还是吸住未放下的状态。另一个端口就是用来接收使吸盘放下瓷砖的信号，同时该信号也包含了该瓷砖的为第几块瓷砖的信息。</p>
<p><strong>纠正数据</strong> 主要包含一下信息：</p>
<blockquote>
<ol>
<li>贴近类型(type)</li>
</ol>
</blockquote>
<p>在之前的多次测试中发现，如果两块瓷砖在相对合适（不是很近也不是很远）的位置进行拍照与靠近时可以达到比较好的效果，所以在这里，会现在processing中判断是否满足条件，如果满足则机器人可以直接贴近，如果不满足则可以适当保持一定的距离。这里使用的盘算条件如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((coord_offset_left &lt; <span class="number">5.2</span>) &amp; (coord_offset_right &lt; <span class="number">0.6</span>) &amp; (angle_delta_real &lt; <span class="number">0.4</span>) &amp; (coord_offset_left &gt; <span class="number">1</span>))&#123;</span><br><span class="line">          send_data_auto(<span class="number">1</span>);  <span class="comment">//说明位置正确可以靠近</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          send_data_auto(<span class="number">2</span>);  <span class="comment">//距离较远 先靠近一点</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<ol>
<li>UR机器人当前位置信息(robot_pose)</li>
</ol>
</blockquote>
<p>机器人位置信息（X,Y,Z,RX,RY,RZ）现在是由processing通过TCP/IP实时地从机箱读取,有了该信息，机器人就可以在该信息的基础上进行运动。</p>
<blockquote>
<ol>
<li>角度偏差(angle_delta_real)</li>
</ol>
</blockquote>
<p>在processing中计算得到两块瓷砖的边缘直线的角度偏差，将角度偏差发送给机器人使其纠正，使两块瓷砖尽量保持平行。目前，无论是哪一种位置类型，都是计算y方向的边缘直线方程，以使该边缘平行。</p>
<blockquote>
<ol>
<li>左拐点位置信息(corner_coord_left)</li>
</ol>
</blockquote>
<p>左拐点就是表示UR末端工具头吸取的那块瓷砖的角点。</p>
<blockquote>
<ol>
<li>右拐点位置信息(corner_coord_right)</li>
</ol>
</blockquote>
<p>右拐点指的时前一块已经放置好的瓷砖的角点，该点就是瓷砖贴合时的参考点。</p>
<blockquote>
<ol>
<li>右拐点参考点位置信息(corner_right_refer)</li>
</ol>
</blockquote>
<p>因为需要使瓷砖和瓷砖之间保持间隙，所以间隙的方向就由该点确定，只需要根据前面算出来的边缘直线就可以计算出参考点的信息。</p>
<p><strong>放置信号</strong> 主要包括以下部分：</p>
<p>这部分主要包含当前瓷砖的数量(number)信息，因为目前图像识别部分和机器人规划部分是分别由processing和GH组成，所以需要在processing中对贴瓷砖的次数进行计数，当得到该信号后就表示机器人应该将瓷砖放下并取下一块瓷砖。</p>
<h3 id="1-2-6贴砖策略"><a href="#1-2-6贴砖策略" class="headerlink" title="1.2.6贴砖策略"></a>1.2.6贴砖策略</h3><p>整个贴砖策略流程图如下：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/贴砖策略示意图.jpg"/></p>
<p>现在放置瓷砖的信号是通过图像来判断，通过点击相关按钮实现瓷砖的放置。</p>
<h3 id="1-2-7-I-O说明"><a href="#1-2-7-I-O说明" class="headerlink" title="1.2.7 I/O说明"></a>1.2.7 I/O说明</h3><p>目前使用的I/O口有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">io4: 用来打开和关闭相机</span><br><span class="line">io2: 电缸伸出，放置瓷砖</span><br><span class="line">io3：电缸回收，吸取瓷砖</span><br></pre></td></tr></table></figure></p>
<p>在<code>C#</code>中写好何时伸出电缸，何时放置电缸的程序。</p>
<h1 id="2-UR视觉"><a href="#2-UR视觉" class="headerlink" title="2.UR视觉"></a>2.UR视觉</h1><p>该部分主要又两部分组成，一个是手眼标定部分，一个是图像处理部分。</p>
<h2 id="2-1-手眼标定"><a href="#2-1-手眼标定" class="headerlink" title="2.1 手眼标定"></a>2.1 手眼标定</h2><p>机器人的运动控制实际上是基于其基座(base)坐标下的点坐标来进行的，所以当相机采集到图像后，需要将图像上的点转换到世界坐标下才可以使机械臂到达指定位置。他们之间的转换涉及到多个转换矩阵，其中最关键的就是工具头末端和相机之间的转换矩阵，也称为手眼转换矩阵。</p>
<p>手眼标定(Hand-eye claibration problem)，可以分为两种情况:<strong>局部手眼</strong>，<strong>全局手眼</strong>。</p>
<p><strong>局部手眼(eye-in-hand)</strong>：也叫随动手眼,相机随着机器人末端进行移动；</p>
<p><strong>全局手眼(eye-to-hand)</strong>：也叫固定手眼，相机是不动的，观察机器人移动。</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20200105135628.png"/></p>
<p>因为在这里，机器人位于移动底盘上，所以相机必须要跟着机器人一起移动，所以采用 <strong>局部手眼(eye-in-hand)</strong> 的方式。</p>
<h3 id="2-1-1-转换矩阵的确定"><a href="#2-1-1-转换矩阵的确定" class="headerlink" title="2.1.1 转换矩阵的确定"></a>2.1.1 转换矩阵的确定</h3><p>主要是三个转换矩阵：</p>
<p>注意：下面讲到的所有世界坐标系都是指UR机器人的的基座坐标系。</p>
<ol>
<li>末端工具头坐标系到世界坐标系的转换矩阵。</li>
<li>相机坐标系到像素坐标系之间的转换矩阵。</li>
<li>相机坐标系到末端工具头坐标系之间的转换矩阵。</li>
</ol>
<blockquote>
<p>末端工具头坐标系到世界坐标系转换矩阵($H^{-1}_{rg}$)</p>
</blockquote>
<p>下标中的r就表示机器人世界坐标系，g表示末端工具头坐标系</p>
<p>这一部分的转换矩阵不需要进行标定，只需要读取末端工具头的位置信息，在这里UR的工具头末端信息是X,Y,Z,RX,RY,RZ。X,Y,Z表示的是位置坐标，RX,RY,RZ表示的<a href="https://en.wikipedia.org/wiki/Rotation_formalisms_in_three_dimensions" target="_blank" rel="noopener">旋转向量</a>。为了便于转换矩阵的计算，需要将这个6个值转换成描述矩阵的形式:</p>
<script type="math/tex; mode=display">H = \begin{bmatrix}R & T\\\\0 &1\end{bmatrix}</script><p>其中$R$为旋转矩阵($3\times3$)，$T$为平移向量($3\times1$)。<br>旋转矩阵由旋转向量经<a href="https://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula" target="_blank" rel="noopener">罗德里格斯变换</a>可以转换而成。在opencv中直接使用<a href="https://docs.opencv.org/3.4.0/d9/d0c/group__calib3d.html#ga61585db663d9da06b68e70cfbf6a1eac" target="_blank" rel="noopener">rodrigues</a>函数就可以进行转换。</p>
<blockquote>
<p>像素坐标系到相机坐标系转换矩阵($H_{pc}$)</p>
</blockquote>
<p>简单来说就是将图像像素坐标上的点转换到相机坐标系。</p>
<p><strong>图像像素坐标：</strong> 图像像素坐标系是以左上角为零点，水平向右为x正方向，垂直向下为y正方向，如下图所示：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/20200105135721.png"/></p>
<p>所以像素坐标系与相机坐标系之间的转换关系其实就是计算相机的内部参数矩阵，而这部分是需要通过标定板来进行标定的。关于相机标定，opencv官方就已经由一些<a href="https://docs.opencv.org/3.4.2/d4/d94/tutorial_camera_calibration.html" target="_blank" rel="noopener">解释</a>，同时在官方github中也有了calibrate的<a href="https://github.com/opencv/opencv/blob/3.4/samples/python/calibrate.py" target="_blank" rel="noopener">例子</a>，参考这些就可以把内部参数求解出来。当我们使用相机标定矩阵时，注意标定板应该在固定位置保持不变，使机器人在大概12个不同的位置角度对其进行拍摄。</p>
<p>这里$H_{pc}$是相机内部参数矩阵的增广矩阵:</p>
<script type="math/tex; mode=display">H_{pc} = \begin{bmatrix} cameraMatrix \mid 0\end{bmatrix}_{3 \times 4}</script><blockquote>
<p>相机坐标系到工具头坐标系转换矩阵($H_{cg}$)</p>
</blockquote>
<p>相机坐标系与工具头坐标系之间的转换就是所谓的手眼转换。（前提是相机与工具头之间的关系是固定的）</p>
<p><img src="https://torsteinmyhre.name/snippets/robcam_calibration/images/extrinsic-camera-calibration-eye-in-hand-651px.png" alt="calibrate eye in hand"></p>
<p>手眼标定的主要目的就是标定相机和工具头末端之间的转换矩阵($H_{cg}$)，在上图中为$X$。</p>
<p><strong>求解思路：</strong></p>
<p>为了便于解释，使用如下图：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/calibrate1.png"/></p>
<p>如图所示，</p>
<p>$C_i$：相机的位置坐标（由opencv中的张氏标定可以算出相机的外部参数矩阵，即为相机的位置）</p>
<p>$G_i$：工具头末端位置坐标（可由机箱直接读到此时的位置信息）</p>
<p>$CW$：标定板坐标系</p>
<p>$RW$: 机器人坐标系</p>
<p>上图表示的是工具头和相机分别在$n$个位置对标定板进行拍摄。</p>
<p>进一步的：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/calibrate2.png"/></p>
<p>$H_{ci}$：从$CW$到$C_i$的坐标转换</p>
<p>$H_{gi}$：从$G_i$到$RW$的坐标转换</p>
<p>$H_{gij}$：从$G_i$到$G_j$的坐标转换</p>
<p>$H_{cij}$：从$C_i$到$C_j$的坐标转换</p>
<p>$H_{cg}$：从$C_i$到$G_j$的坐标转换</p>
<p>其中：</p>
<script type="math/tex; mode=display">H = \begin{bmatrix}R & T\\\\0 &1\end{bmatrix}</script><p>$R$为旋转矩阵($3\times3$)，$T$为平移向量($3\times1$)。</p>
<p>因为：</p>
<script type="math/tex; mode=display">
\begin{cases}
H_{gi}=H_{cg}H_{ci} \\\\
H_{gj}=H_{gij}H_{gi} \\\\
H_{cj}=H_{cij}H_{ci}
\end{cases}</script><p>所以可以得到：</p>
<script type="math/tex; mode=display">H_{gij}H_{cg} = H_{cg}H_{cij}</script><p>所以实际只要三个位置就可以计算出手眼转换矩阵$H_{cg}$，但因为通常需要10个位置左右才能得到比较准确的得到相机的外部参数矩阵，所以实际上还是需要在10个以上位置拍摄标定板。</p>
<p>求解$H_{cg}$也是比较麻烦的一个部分，这里我参考的是<a href="https://blog.csdn.net/Xiongchao99/article/details/52850990" target="_blank" rel="noopener">这篇博客</a>中介绍的求解方式。</p>
<p>求解$H_{cg}$的java代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.opencv.core.*;</span><br><span class="line"><span class="keyword">import</span> org.opencv.imgproc.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math3.linear.Array2DRowRealMatrix;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math3.linear.LUDecomposition;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math3.linear.RealMatrix;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math3.analysis.function.Acos;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math3.analysis.function.Sin;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.math3.geometry.euclidean.threed.Vector3D;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculate_Hcg</span></span>&#123;</span><br><span class="line">  Acos acos;</span><br><span class="line">  Sin sin;</span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt; Hc;<span class="comment">//相机描述矩阵</span></span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt; Hcij;<span class="comment">//相机ij位置的转换矩阵</span></span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt; Hg;<span class="comment">//工具描述矩阵</span></span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt; Hgij;<span class="comment">//相机ij位置的转换矩阵</span></span><br><span class="line">  <span class="keyword">public</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt; Hcg;<span class="comment">//相机ij位置的转换矩阵</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hcg</span><span class="params">(List&lt;Mat&gt; rc_vec,List&lt;Mat&gt; tc_vec,List&lt;Mat&gt; rg_vec,List&lt;Mat&gt; tg_vec)</span></span>&#123;</span><br><span class="line">  <span class="comment">//传入的参数分别是图像的旋转和平移向量，工具手的旋转和平移向量</span></span><br><span class="line">    <span class="keyword">double</span>[][] hcg_temp;</span><br><span class="line">    get_hcij(rc_vec,tc_vec);</span><br><span class="line">    get_hgij(rg_vec,tg_vec);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;Hgij.size()-<span class="number">1</span>;i++)&#123;</span><br><span class="line">      hcg_temp = caluate_Hcg(Hcij.get(i),Hcij.get(i+<span class="number">1</span>),Hgij.get(i),Hgij.get(i+<span class="number">1</span>));</span><br><span class="line">      Hcg.add(hcg_temp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> Vector3D <span class="title">caluate_k</span><span class="params">(<span class="keyword">double</span>[][] data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> R[][] = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">        R[i][j] = data[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> w_temp[]= <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">double</span> trace = R[<span class="number">0</span>][<span class="number">0</span>]+R[<span class="number">1</span>][<span class="number">1</span>]+R[<span class="number">2</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">float</span> trace_f = (<span class="keyword">float</span>) trace;</span><br><span class="line">    <span class="keyword">double</span> q = acos((trace_f - <span class="number">1</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">float</span> q_f = (<span class="keyword">float</span>) q;</span><br><span class="line">    w_temp[<span class="number">0</span>] = q/(<span class="number">2</span>*sin(q_f))*(R[<span class="number">2</span>][<span class="number">1</span>] - R[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">    w_temp[<span class="number">1</span>] = q/(<span class="number">2</span>*sin(q_f))*(R[<span class="number">0</span>][<span class="number">2</span>] - R[<span class="number">2</span>][<span class="number">0</span>]);</span><br><span class="line">    w_temp[<span class="number">2</span>] = q/(<span class="number">2</span>*sin(q_f))*(R[<span class="number">1</span>][<span class="number">0</span>] - R[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    Vector3D w = <span class="keyword">new</span> Vector3D(w_temp);</span><br><span class="line">   <span class="keyword">return</span> w;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealMatrix <span class="title">vect2mat</span><span class="params">(Vector3D k1,Vector3D k2,Vector3D k3)</span></span>&#123;  <span class="comment">//向量转换成矩阵</span></span><br><span class="line">    <span class="keyword">double</span> mat[][] = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    mat[<span class="number">0</span>][<span class="number">0</span>] =   k1.getX();</span><br><span class="line">    mat[<span class="number">1</span>][<span class="number">0</span>] =   k1.getY();</span><br><span class="line">    mat[<span class="number">2</span>][<span class="number">0</span>] =   k1.getZ();</span><br><span class="line">    mat[<span class="number">0</span>][<span class="number">1</span>] =   k2.getX();</span><br><span class="line">    mat[<span class="number">1</span>][<span class="number">1</span>] =   k2.getY();</span><br><span class="line">    mat[<span class="number">2</span>][<span class="number">1</span>] =   k2.getZ();</span><br><span class="line">    mat[<span class="number">0</span>][<span class="number">2</span>] =   k3.getX();</span><br><span class="line">    mat[<span class="number">1</span>][<span class="number">2</span>] =   k3.getY();</span><br><span class="line">    mat[<span class="number">2</span>][<span class="number">2</span>] =   k3.getZ();</span><br><span class="line">    RealMatrix realmat = <span class="keyword">new</span> Array2DRowRealMatrix(mat);</span><br><span class="line">    <span class="keyword">return</span> realmat;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealMatrix <span class="title">get_tvec</span><span class="params">(<span class="keyword">double</span>[][] Hij)</span></span>&#123; <span class="comment">//得到平移向量</span></span><br><span class="line">    <span class="keyword">double</span> tvecs[][] = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>][<span class="number">1</span>];</span><br><span class="line">    tvecs[<span class="number">0</span>][<span class="number">0</span>] = Hij[<span class="number">0</span>][<span class="number">3</span>];</span><br><span class="line">    tvecs[<span class="number">1</span>][<span class="number">0</span>] = Hij[<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">    tvecs[<span class="number">2</span>][<span class="number">0</span>] = Hij[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    RealMatrix tvecs_mat = <span class="keyword">new</span> Array2DRowRealMatrix(tvecs);</span><br><span class="line">    <span class="keyword">return</span> tvecs_mat;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealMatrix <span class="title">matrix_sub</span><span class="params">(RealMatrix v1,RealMatrix v2)</span></span>&#123; <span class="comment">//矩阵相减</span></span><br><span class="line">    <span class="keyword">assert</span>(v1.getColumnDimension()== v2.getColumnDimension());</span><br><span class="line">    <span class="keyword">assert</span>(v1.getRowDimension()== v2.getRowDimension());</span><br><span class="line">    <span class="keyword">int</span> row = (<span class="keyword">int</span>) v1.getRowDimension();</span><br><span class="line">    <span class="keyword">int</span> col = (<span class="keyword">int</span>) v1.getColumnDimension();</span><br><span class="line">    <span class="keyword">double</span> sub_mat[][] = <span class="keyword">new</span> <span class="keyword">double</span>[row][col];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i  = <span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;col;j++)&#123;</span><br><span class="line">        sub_mat[i][j] = v1.getData()[i][j] - v2.getData()[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RealMatrix sub_realmat = <span class="keyword">new</span> Array2DRowRealMatrix(sub_mat);</span><br><span class="line">    <span class="keyword">return</span> sub_realmat;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealMatrix <span class="title">doublearr_sub_eye</span><span class="params">(<span class="keyword">double</span>[][] H)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> H_size3[][] = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">3</span>;j++)&#123;</span><br><span class="line">        H_size3[i][j] = H[i][j];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    H_size3[<span class="number">0</span>][<span class="number">0</span>] = H_size3[<span class="number">0</span>][<span class="number">0</span>] -<span class="number">1</span>;</span><br><span class="line">    H_size3[<span class="number">1</span>][<span class="number">1</span>] = H_size3[<span class="number">1</span>][<span class="number">1</span>] -<span class="number">1</span>;</span><br><span class="line">    H_size3[<span class="number">2</span>][<span class="number">2</span>] = H_size3[<span class="number">2</span>][<span class="number">2</span>] -<span class="number">1</span>;</span><br><span class="line">    RealMatrix H_mat = <span class="keyword">new</span> Array2DRowRealMatrix(H_size3);</span><br><span class="line">    <span class="keyword">return</span> H_mat;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealMatrix <span class="title">appendmat</span><span class="params">(RealMatrix m1,RealMatrix m2)</span></span>&#123; <span class="comment">//两个矩阵append</span></span><br><span class="line">    <span class="keyword">int</span> row1 = (<span class="keyword">int</span>) m1.getRowDimension();</span><br><span class="line">    <span class="keyword">int</span> row2 = (<span class="keyword">int</span>) m2.getRowDimension();</span><br><span class="line">    <span class="keyword">int</span> col1 = (<span class="keyword">int</span>) m1.getColumnDimension();</span><br><span class="line">    <span class="keyword">int</span> col2 = (<span class="keyword">int</span>) m2.getColumnDimension();</span><br><span class="line">    <span class="keyword">int</span> new_row = row1+row2;</span><br><span class="line">    <span class="keyword">assert</span>(col1==col2);</span><br><span class="line">    <span class="keyword">double</span> new_mat[][] = <span class="keyword">new</span> <span class="keyword">double</span>[row1+row2][col1];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;new_row;i++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i&lt;row1)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;col1;j++)&#123;</span><br><span class="line">          new_mat[i][j] = m1.getData()[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;col1;k++)&#123;</span><br><span class="line">          new_mat[i][k] = m2.getData()[i-row1][k];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    RealMatrix H_mat = <span class="keyword">new</span> Array2DRowRealMatrix(new_mat);</span><br><span class="line">    <span class="keyword">return</span> H_mat;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span>[][] get_hcg(RealMatrix R,RealMatrix t)&#123; </span><br><span class="line">    <span class="keyword">double</span> Hcg[][] = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;<span class="number">3</span>)&#123;</span><br><span class="line">          Hcg[i][j] = R.getData()[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          Hcg[i][j] = t.getData()[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Hcg[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    Hcg[<span class="number">3</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    Hcg[<span class="number">3</span>][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    Hcg[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> Hcg;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span>[][] caluate_Hcg(<span class="keyword">double</span>[][] hcij1,<span class="keyword">double</span>[][] hcij2,<span class="keyword">double</span>[][] hgij1,<span class="keyword">double</span>[][] hgij2)&#123;</span><br><span class="line">    Vector3D kc1 = caluate_k(hcij1);  <span class="comment">//3x1列向量</span></span><br><span class="line">    Vector3D kc2 = caluate_k(hcij2);</span><br><span class="line">    Vector3D kd1 = caluate_k(hgij1);</span><br><span class="line">    Vector3D kd2 = caluate_k(hgij2);</span><br><span class="line">    Vector3D kc3 = Vector3D.crossProduct(kc1,kc2); <span class="comment">//1x3</span></span><br><span class="line">    Vector3D kd3 = Vector3D.crossProduct(kd1,kd2);</span><br><span class="line">    RealMatrix a_temp = vect2mat(kc1,kc2,kc3);</span><br><span class="line">    RealMatrix b_temp = vect2mat(kd1,kd2,kd3);</span><br><span class="line">    RealMatrix R = a_temp.multiply(inverseMatrix(b_temp));  <span class="comment">//  旋转矩阵3x3</span></span><br><span class="line">    RealMatrix tc1 = get_tvec(hcij1);</span><br><span class="line">    RealMatrix tc2 = get_tvec(hcij2);</span><br><span class="line">    RealMatrix td1 = get_tvec(hgij1);</span><br><span class="line">    RealMatrix td2 = get_tvec(hgij2);</span><br><span class="line">    RealMatrix c = matrix_sub(R.multiply(td1),tc1); <span class="comment">//3X1</span></span><br><span class="line">    RealMatrix d = matrix_sub(R.multiply(td2),tc2);</span><br><span class="line">    RealMatrix a = doublearr_sub_eye(hcij1);  <span class="comment">//3x3</span></span><br><span class="line">    RealMatrix b = doublearr_sub_eye(hcij2);</span><br><span class="line">    RealMatrix h = appendmat(a,b);</span><br><span class="line">    RealMatrix y = appendmat(c,d);</span><br><span class="line">    RealMatrix t = inverseMatrix(h.transpose().multiply(h)).multiply(h.transpose()).multiply(y); <span class="comment">//平移向量3x1</span></span><br><span class="line">    <span class="keyword">double</span>[][] Hcg = get_hcg(R,t);</span><br><span class="line">    <span class="keyword">return</span> Hcg;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">get_hcij</span><span class="params">(List&lt;Mat&gt; rc_vec,List&lt;Mat&gt; tc_vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] h_temp;<span class="comment">//存放描述矩阵的临时值</span></span><br><span class="line">    RealMatrix hcij;<span class="comment">//计算ij矩阵</span></span><br><span class="line">    Hc = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt;();  <span class="comment">//相机的描述矩阵</span></span><br><span class="line">    Hcij = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt;(); <span class="comment">//相机ij位置的转换矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rc_vec.size();i++)&#123;</span><br><span class="line">      h_temp = getH(rc_vec.get(i),tc_vec.get(i));<span class="comment">//4x4的数组,double[][]类型</span></span><br><span class="line">     <span class="comment">// double htoarray[][]=h_temp.getData();//转换成数组</span></span><br><span class="line">      Hc.add(h_temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;rc_vec.size()-<span class="number">1</span>;j++)&#123;</span><br><span class="line">     <span class="comment">// double[][] b = Hc.get(j);  //还需要将数组转换成矩阵的形式</span></span><br><span class="line">      RealMatrix mat1 = <span class="keyword">new</span> Array2DRowRealMatrix(Hc.get(j));<span class="comment">//还需要将数组转换成矩阵的形式</span></span><br><span class="line">      RealMatrix mat2 = <span class="keyword">new</span> Array2DRowRealMatrix(Hc.get(j+<span class="number">1</span>));</span><br><span class="line">      hcij = mat1.multiply(inverseMatrix(mat2)); <span class="comment">//matrix格式</span></span><br><span class="line">      <span class="keyword">double</span> hcijtoarray[][]=hcij.getData();<span class="comment">//转换成数组</span></span><br><span class="line">      Hcij.add(hcijtoarray);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">get_hgij</span><span class="params">(List&lt;Mat&gt; rg_vec,List&lt;Mat&gt; tg_vec)</span></span>&#123;</span><br><span class="line">    <span class="keyword">double</span>[][] h_temp;<span class="comment">//存放描述矩阵的临时值</span></span><br><span class="line">    RealMatrix hgij;<span class="comment">//计算ij矩阵</span></span><br><span class="line">    Hg = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt;();  <span class="comment">//机械臂的描述矩阵</span></span><br><span class="line">    Hgij = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">double</span>[][]&gt;(); <span class="comment">//机械臂ij位置的转换矩阵</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rg_vec.size();i++)&#123;</span><br><span class="line">      h_temp = getH(rg_vec.get(i),tg_vec.get(i));<span class="comment">//4x4的数组,double[][]类型</span></span><br><span class="line">      Hg.add(h_temp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;rg_vec.size()-<span class="number">1</span>;j++)&#123;</span><br><span class="line">     <span class="comment">// double[][] b = Hc.get(j);  //还需要将数组转换成矩阵的形式</span></span><br><span class="line">      RealMatrix mat1 = <span class="keyword">new</span> Array2DRowRealMatrix(Hg.get(j));<span class="comment">//还需要将数组转换成矩阵的形式</span></span><br><span class="line">      RealMatrix mat2 = <span class="keyword">new</span> Array2DRowRealMatrix(Hg.get(j+<span class="number">1</span>));</span><br><span class="line">      hgij = inverseMatrix(mat1).multiply(mat2); <span class="comment">//matrix格式</span></span><br><span class="line">      <span class="keyword">double</span> hgijtoarray[][]=hgij.getData();<span class="comment">//转换成数组</span></span><br><span class="line">      Hgij.add(hgijtoarray);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">double</span>[][] getH(Mat rvecs,Mat tvecs) &#123;<span class="comment">//将旋转向量和平移向量转换成矩阵</span></span><br><span class="line">    Mat rota_mat = <span class="keyword">new</span> Mat(<span class="number">3</span>, <span class="number">3</span>, CvType.CV_32FC1);</span><br><span class="line">    <span class="keyword">double</span> [] result;</span><br><span class="line">    Calib3d.Rodrigues(rvecs,rota_mat);</span><br><span class="line">    <span class="keyword">double</span> exterarr[][] = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">3</span>;i++)&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j&lt;<span class="number">4</span>;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;<span class="number">3</span>)&#123;</span><br><span class="line">          result = rota_mat.get(i,j);</span><br><span class="line">          exterarr[i][j] = result[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            exterarr[i][j] = tvecs.get(i,<span class="number">0</span>)[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    exterarr[<span class="number">3</span>][<span class="number">3</span>] = <span class="number">1.0</span>;  </span><br><span class="line">    <span class="comment">//extermat = new Array2DRowRealMatrix(exterarr);</span></span><br><span class="line">    <span class="keyword">return</span> exterarr;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> RealMatrix <span class="title">inverseMatrix</span><span class="params">(RealMatrix A)</span> </span>&#123;<span class="comment">//求逆矩阵</span></span><br><span class="line">    RealMatrix result = <span class="keyword">new</span> LUDecomposition(A).getSolver().getInverse();</span><br><span class="line">    <span class="keyword">return</span> result; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-2-像素坐标转换到世界坐标"><a href="#2-1-2-像素坐标转换到世界坐标" class="headerlink" title="2.1.2 像素坐标转换到世界坐标"></a>2.1.2 像素坐标转换到世界坐标</h3><p>得到前面三个转换矩阵后，就可以通过下面的公式将图像上的点$(u,v)$转换成世界坐标下的点$(x,y,z)$（注意：高度$z$是给定的）：</p>
<script type="math/tex; mode=display">z \begin{bmatrix}u\\\\v\\\\1\end{bmatrix} = H_{pc}H_{cg}H^{-1}_{rg} \begin{bmatrix}x\\\\y\\\\z\\\\1\end{bmatrix}</script><p>设：</p>
<script type="math/tex; mode=display">H_{pc}H_{cg}H^{-1}_{rg} = \begin{bmatrix}a_0&b_0&c_0&d_0\\\\a_1&b_1&c_1&d_1\\\\a_2&b_2&c_2&d_2\\\\a_3&b_3&c_3&d_3 \end{bmatrix}</script><p>则：</p>
<script type="math/tex; mode=display">\begin{bmatrix} x \\\\y  \end{bmatrix} = \begin{bmatrix} ua_2 - a_0 &ub_2 - b_0 \\\\va_2 - a_1 &vb_2-b_1  \end{bmatrix}^{-1}\begin{bmatrix} d_0-ud_2-(uc_2-c_0)z \\\\d_1-vd_2-(vc_2-c_1)z \end{bmatrix}</script><p>这样就把图像上的点转换到了机器人坐标系下的点。</p>
<h2 id="2-2-瓷砖特征信息提取"><a href="#2-2-瓷砖特征信息提取" class="headerlink" title="2.2 瓷砖特征信息提取"></a>2.2 瓷砖特征信息提取</h2><p><strong>图像算法</strong></p>
<hr>
<ul>
<li><p>输入：</p>
<p>图片src</p>
</li>
<li><p>输出过程</p>
<ol>
<li><p>对<code>图像src预处理</code>（高斯模糊、开操作），及canny边缘检测，得到处理后的图像img_canny</p>
</li>
<li><p>对img_canny进行<code>轮廓检测</code>，得到轮廓点集contours</p>
</li>
<li><p>根据各轮廓面积，对轮廓进行<code>过滤筛选</code>，对保留下的轮廓点集由Hu矩计算得到各轮廓质心</p>
</li>
<li><p>根据轮廓质心得到<code>edge_tile_flag</code>，同时将轮廓点集区分为左右点集（分别表示吸取的和地面的瓷砖）points_left,points_right</p>
</li>
<li><p>对points_left,points_right使用<code>最大距离法</code>计算出轮廓的拐点corner_left,corner_right</p>
</li>
<li><p>由corner_left,corner_right<code>筛选</code>出points_left,points_right中的边缘直线点集line_left,line_right，并由<code>PCA最小二乘法</code>拟合直线</p>
</li>
</ol>
</li>
<li><p>输出</p>
<p>line_left,line_right,corner_left,corner_right</p>
</li>
</ul>
<hr>
<h3 id="2-2-1-图像预处理"><a href="#2-2-1-图像预处理" class="headerlink" title="2.2.1 图像预处理"></a>2.2.1 图像预处理</h3><p>特征信息最关键的地方就在边缘检测，目前使用的是<a href="https://zh.wikipedia.org/wiki/Canny%E7%AE%97%E5%AD%90" target="_blank" rel="noopener">canny边缘检测</a>算法,opencv中可以直接使用<a href="https://docs.opencv.org/3.4.2/dd/d1a/group__imgproc__feature.html#ga2a671611e104c093843d7b7fc46d24af" target="_blank" rel="noopener">canny函数</a>（在写这篇文章时，其实已经发现了一种效果更好的边缘检测算法-<a href="https://www.ipol.im/pub/art/2016/175/" target="_blank" rel="noopener">Unsupervised Smooth Contour Detection</a>，但还时间将其应用在图像识别算法中，之后会再整理）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Mat <span class="title">preprocess_image</span><span class="params">(Mat img)</span></span>&#123; <span class="comment">//图像预处理</span></span><br><span class="line">    Size size = <span class="keyword">new</span> Size(<span class="number">3</span>,<span class="number">3</span>); <span class="comment">//模糊图像用的核函数的尺寸大小</span></span><br><span class="line">    Size size2 = <span class="keyword">new</span> Size(<span class="number">5</span>,<span class="number">5</span>); <span class="comment">//形态学转换的核函数的尺寸大小</span></span><br><span class="line">    Mat img_canny = <span class="keyword">new</span> Mat(); <span class="comment">//存储canny边缘检测后的图片</span></span><br><span class="line">    Mat img_gray = <span class="keyword">new</span> Mat();<span class="comment">//存储灰度图</span></span><br><span class="line">    Imgproc.cvtColor(img,img_gray,Imgproc.COLOR_BGR2GRAY); <span class="comment">//转换成灰度图</span></span><br><span class="line">    Imgproc.blur(img_gray,img_gray,size);   <span class="comment">//图像平滑</span></span><br><span class="line">    Mat element;</span><br><span class="line">    element = Imgproc.getStructuringElement(Imgproc.MORPH_RECT,size2);</span><br><span class="line">    Imgproc.morphologyEx(img_gray,img_gray,<span class="number">1</span>,element); <span class="comment">//形态学转换  1：开操作</span></span><br><span class="line">    Imgproc.Canny(img_gray,img_canny,g_nThresh,g_nThresh*<span class="number">2</span>); <span class="comment">//canny边缘检测</span></span><br><span class="line">    <span class="keyword">return</span> img_canny;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-2-轮廓检测"><a href="#2-2-2-轮廓检测" class="headerlink" title="2.2.2 轮廓检测"></a>2.2.2 轮廓检测</h3><p>在canny边缘检测算法之后由<a href="https://docs.opencv.org/3.4.2/d3/dc0/group__imgproc__shape.html#ga17ed9f5d79ae97bd4c7cf18403e1689a" target="_blank" rel="noopener">findcontours</a>可以得到其检测到的所有边缘轮廓的点集，接下来利用opencv的<a href="https://docs.opencv.org/3.4.2/d3/dc0/group__imgproc__shape.html#ga3d476a3417130ae5154aea421ca7ead9" target="_blank" rel="noopener">minAreaRect</a>函数可以算出轮廓的最小外接矩形。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cnt_info</span><span class="params">(List&lt;MatOfPoint&gt; contours)</span></span>&#123; <span class="comment">//获得详细的边缘轮廓信息</span></span><br><span class="line">    boxcontours_list = <span class="keyword">new</span> ArrayList&lt;org.opencv.core.Point[]&gt;(); <span class="comment">//轮廓外接矩形的四个定点</span></span><br><span class="line">    area_list = <span class="keyword">new</span> ArrayList&lt;Double&gt;();  <span class="comment">//外接矩形面积</span></span><br><span class="line">    rect_list = <span class="keyword">new</span> ArrayList&lt;RotatedRect&gt;(); <span class="comment">//外接矩形</span></span><br><span class="line">    contours_appro = <span class="keyword">new</span> ArrayList&lt;MatOfPoint&gt;();</span><br><span class="line">    box_appro = <span class="keyword">new</span> ArrayList&lt;org.opencv.core.Point[]&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; contours.size();i++)&#123;</span><br><span class="line">       MatOfPoint cnt = contours.get(i);</span><br><span class="line">       MatOfPoint2f  newcnt = <span class="keyword">new</span> MatOfPoint2f(cnt.toArray()); <span class="comment">//将MatOfPoint转换成MatOfPoint2f</span></span><br><span class="line">       RotatedRect rect = Imgproc.minAreaRect(newcnt);</span><br><span class="line">       Size size_area = rect.size;</span><br><span class="line">       <span class="keyword">double</span> area = size_area.area();</span><br><span class="line">       org.opencv.core.Point vertices[] = <span class="keyword">new</span> org.opencv.core.Point[<span class="number">4</span>];<span class="comment">//定义四个顶点</span></span><br><span class="line">       rect.points(vertices); <span class="comment">//将rect中的定点赋值给vertices</span></span><br><span class="line">       boxcontours_list.add(vertices); <span class="comment">//将四个顶点存入list中</span></span><br><span class="line">       area_list.add(area);</span><br><span class="line">       rect_list.add(rect);</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-3-轮廓筛选与质心计算"><a href="#2-2-3-轮廓筛选与质心计算" class="headerlink" title="2.2.3 轮廓筛选与质心计算"></a>2.2.3 轮廓筛选与质心计算</h3><p>接下来可以先根据轮廓面积过滤掉一些面积小于某一阈值的轮廓。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//java</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;Integer&gt; <span class="title">get_indexarea</span><span class="params">(List&lt;MatOfPoint&gt; contours,List&lt;Double&gt; area_list)</span></span>&#123; <span class="comment">//根据轮廓面积进行筛选</span></span><br><span class="line">    ArrayList&lt;Integer&gt; index_area_appro = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    ArrayList&lt;Integer&gt; index_area_list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      List&lt;Double&gt; area_list_temp = deepCopy(area_list); <span class="comment">//深拷贝</span></span><br><span class="line">      <span class="keyword">int</span> len = area_list.size(); <span class="comment">//获得此时寻找到的轮廓列表的大小 这里是可以保证len &gt; 2的</span></span><br><span class="line">      <span class="keyword">int</span> index_area;</span><br><span class="line">      Collections.sort(area_list);  <span class="comment">//先升序再降序</span></span><br><span class="line">      Collections.reverse(area_list);</span><br><span class="line">      <span class="keyword">if</span>(len &lt; <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len;i++)&#123;</span><br><span class="line">          Double area = area_list.get(i);</span><br><span class="line">          <span class="keyword">if</span>(area &gt; <span class="number">5000</span>)&#123;</span><br><span class="line">            index_area = area_list_temp.indexOf(area);</span><br><span class="line">            index_area_list.add(index_area);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)&#123;</span><br><span class="line">          Double area = area_list.get(i);</span><br><span class="line">          <span class="keyword">if</span>(area &gt; <span class="number">5000</span>)&#123;</span><br><span class="line">            index_area = area_list_temp.indexOf(area);</span><br><span class="line">            index_area_list.add(index_area);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">       e.printStackTrace();  </span><br><span class="line">     &#125;</span><br><span class="line">   <span class="keyword">if</span>(index_area_list.size() == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> error = -<span class="number">1</span>;</span><br><span class="line">      index_area_appro.add(error);</span><br><span class="line">      <span class="keyword">return</span> index_area_appro;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      index_area_appro = GetCenterPoint(contours,index_area_list);    </span><br><span class="line">      <span class="keyword">return</span> index_area_appro;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在上面函数可以看到还有一个函数<code>GetCenterPoint(contours,index_area_list)</code>，根据得到的轮廓面积，可以由<a href="https://docs.opencv.org/3.4.2/d8/d23/classcv_1_1Moments.html#a0382b98fdb23acdcb05c91a2a44e5a1f" target="_blank" rel="noopener">moments</a>函数得到轮廓<a href="https://blog.csdn.net/chaipp0607/article/details/70256892" target="_blank" rel="noopener">Hu矩</a>，并由Hu矩得到轮廓的质心。</p>
<h3 id="2-2-4-edge-tile-flag"><a href="#2-2-4-edge-tile-flag" class="headerlink" title="2.2.4 edge_tile_flag"></a>2.2.4 edge_tile_flag</h3><p>瓷砖主要会以以下三种情况出现在画面中：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/threetype.PNG"/></p>
<p>所以由各轮廓质心的相对关系可以确定在图像中那一块瓷砖是被机器人吸取的，哪一块是平面上需要去靠近的。同时，有了这些信息才能便于之后的轮廓直线拟合与机器人的运动控制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ArrayList&lt;Integer&gt; <span class="title">GetCenterPoint</span><span class="params">(List&lt;MatOfPoint&gt; contours,ArrayList&lt;Integer&gt; index_area_list)</span></span>&#123; <span class="comment">//计算得到轮廓的重心点,并对其进行分类，得到左右轮廓的索引</span></span><br><span class="line">     <span class="comment">//ArrayList&lt;org.opencv.core.Point&gt; gravity_point = new  ArrayList&lt;org.opencv.core.Point&gt;();</span></span><br><span class="line">     ArrayList&lt;Integer&gt; index_appro = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">     <span class="keyword">int</span> len = index_area_list.size();</span><br><span class="line">     <span class="keyword">int</span> max_x = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> max_y = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> index_l = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">int</span> index_r = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">if</span>(len == <span class="number">2</span>)&#123;</span><br><span class="line">       <span class="comment">//这里需要去判断当瓷砖是某一行的第一块转时的情况</span></span><br><span class="line">       MatOfPoint cnt1 = contours.get(index_area_list.get(<span class="number">0</span>));</span><br><span class="line">       Moments p1 = Imgproc.moments(cnt1);</span><br><span class="line">       <span class="keyword">int</span> y1 = (<span class="keyword">int</span>) (p1.get_m01() / p1.get_m00());</span><br><span class="line">       MatOfPoint cnt2 = contours.get(index_area_list.get(<span class="number">1</span>));</span><br><span class="line">       Moments p2 = Imgproc.moments(cnt2);</span><br><span class="line">       <span class="keyword">int</span> y2 = (<span class="keyword">int</span>) (p2.get_m01() / p2.get_m00());</span><br><span class="line">       index_l = (y1 &gt; y2) ? <span class="number">0</span>:<span class="number">1</span>;</span><br><span class="line">       index_r = <span class="number">1</span>-index_l;</span><br><span class="line">       MatOfPoint cnt_r = contours.get(index_area_list.get(index_r));</span><br><span class="line">       MatOfPoint cnt_l = contours.get(index_area_list.get(index_l));</span><br><span class="line">       Moments p_r = Imgproc.moments(cnt_r);</span><br><span class="line">       Moments p_l = Imgproc.moments(cnt_l);</span><br><span class="line">       <span class="keyword">int</span> x_r = (<span class="keyword">int</span>) (p_r.get_m10() / p_r.get_m00());</span><br><span class="line">       <span class="keyword">int</span> x_l = (<span class="keyword">int</span>) (p_l.get_m10() / p_l.get_m00());</span><br><span class="line">       <span class="keyword">if</span>(x_r &gt; x_l)&#123;</span><br><span class="line">         edge_tile_flag = <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">         edge_tile_flag = <span class="number">1</span>;<span class="comment">//说明此时的位于每行的第一个</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span>&#123;</span><br><span class="line">       edge_tile_flag = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i ++)&#123;</span><br><span class="line">         MatOfPoint cnt = contours.get(index_area_list.get(i));</span><br><span class="line">         Moments p = Imgproc.moments(cnt);</span><br><span class="line">         <span class="keyword">int</span> x = (<span class="keyword">int</span>) (p.get_m10() / p.get_m00());</span><br><span class="line">         <span class="keyword">int</span> y = (<span class="keyword">int</span>) (p.get_m01() / p.get_m00());</span><br><span class="line">         <span class="keyword">if</span>( y &gt; max_y)&#123;</span><br><span class="line">           max_y = y;</span><br><span class="line">           index_l = i;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">if</span>( x &gt; max_x)&#123;</span><br><span class="line">           max_x = x;</span><br><span class="line">           index_r = i;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     index_appro.add(index_area_list.get(index_l));</span><br><span class="line">     index_appro.add(index_area_list.get(index_r));</span><br><span class="line">     <span class="keyword">return</span> index_appro;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p><code>edge_tile_flag</code>变量表示的是一个标记，主要用来标记此时瓷砖是否为每行的首列。因为如果瓷砖在首列时所用的图像算法是不一样的。<br>对于前面的三种形式：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/threetype.PNG"/></p>
<p><code>edge_tile_flag</code>分别为<code>0,1,0</code>，1,0和分别对应如下的贴砖策略：</p>
<p>一类是瓷砖放置位置在首列，另一种是瓷砖放置位置非首列。通过图像识别算法可以判断出当前属于哪一种类型，但是当需要瓷砖与瓷砖之间保持一定的间隙时，需要知道往哪一个方向保持间隙，所以需要知道当前位置的类型。</p>
<p>瓷砖放置位置在首列的情况：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/postype1.jpg"/></p>
<p>这种情况下，瓷砖与瓷砖之间应该在y方向下保持特定间隙，x方向应该尽量减小间隙。</p>
<p>瓷砖放置位置在非首列的情况：</p>
<p><img src="https://qipccc-alipic.oss-cn-shanghai.aliyuncs.com/images/postype0.jpg"/></p>
<p>在非首列情况下，瓷砖与瓷砖之间应该在x方向下保持特定间隙，y方向应该尽量减小间隙。</p>
<p>有了以上这些信息,就可以将合适的轮廓点集以及各轮廓的最小外接矩形的四个角点信息进行保存输出：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Mat <span class="title">get_contours_info</span><span class="params">(Mat g_srcimg)</span></span>&#123; <span class="comment">//获得轮廓信息的函数</span></span><br><span class="line">    List&lt;MatOfPoint&gt; contours = <span class="keyword">new</span> ArrayList&lt;MatOfPoint&gt;();<span class="comment">//保存轮廓的点集</span></span><br><span class="line">    Mat hierarchy = <span class="keyword">new</span> Mat();</span><br><span class="line">    Mat img_canny = preprocess_image(g_srcimg); <span class="comment">//图像预处理</span></span><br><span class="line">    Imgproc.findContours(img_canny,contours,hierarchy,<span class="number">1</span>,<span class="number">2</span>); <span class="comment">//寻找轮廓</span></span><br><span class="line">    <span class="keyword">if</span>(contours.size() &lt; <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">double</span> neg = -<span class="number">1</span>;</span><br><span class="line">      rate.add(neg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      cnt_info(contours);</span><br><span class="line">      <span class="keyword">double</span> rate1,rate2;</span><br><span class="line">        index_area_appro = get_indexarea(contours,area_list); <span class="comment">//这里面是合适的轮廓的索引</span></span><br><span class="line">        <span class="keyword">if</span>(index_area_appro.get(<span class="number">0</span>) == -<span class="number">1</span>)&#123;</span><br><span class="line">          <span class="keyword">double</span> neg = -<span class="number">1</span>;</span><br><span class="line">          rate.add(neg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">          RotatedRect rect_max_temp = rect_list.get(index_area_appro.get(<span class="number">0</span>));</span><br><span class="line">          RotatedRect rect_max_sec_temp = rect_list.get(index_area_appro.get(<span class="number">1</span>));</span><br><span class="line">          <span class="keyword">if</span>((rect_max_temp.size.width == <span class="number">0</span>) | (rect_max_temp.size.height == <span class="number">0</span>))&#123;</span><br><span class="line">            rate1 = <span class="number">100</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">            rate1 = max_value(rect_max_temp.size.width / rect_max_temp.size.height,rect_max_temp.size.height / rect_max_temp.size.width); <span class="comment">//返回两个数中的较大值</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span>((rect_max_sec_temp.size.width == <span class="number">0</span>) | (rect_max_sec_temp.size.height == <span class="number">0</span>))&#123;</span><br><span class="line">            rate2 = <span class="number">100</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span>&#123;</span><br><span class="line">            rate2 = max_value(rect_max_sec_temp.size.width / rect_max_sec_temp.size.height,rect_max_sec_temp.size.height / rect_max_sec_temp.size.width); <span class="comment">//返回两个数中的较大值</span></span><br><span class="line">         &#125;</span><br><span class="line">         rate.add(rate1);</span><br><span class="line">         rate.add(rate2);</span><br><span class="line">         contours_appro.add(contours.get(index_area_appro.get(<span class="number">0</span>)));</span><br><span class="line">         contours_appro.add(contours.get(index_area_appro.get(<span class="number">1</span>)));</span><br><span class="line">         box_appro.add(boxcontours_list.get(index_area_appro.get(<span class="number">0</span>)));</span><br><span class="line">         box_appro.add(boxcontours_list.get(index_area_appro.get(<span class="number">1</span>)));  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> img_canny;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>由之前的代码可以看出来，提取轮廓特征信息只使用两个轮廓点集即可。</p>
<h3 id="2-2-5-最大距离法"><a href="#2-2-5-最大距离法" class="headerlink" title="2.2.5 最大距离法"></a>2.2.5 最大距离法</h3><p>得到合适的轮廓点集之后，就可以计算瓷砖的角点，这里使用最大距离法计算瓷砖的角点。最大距离法的主要思想是，对于一条折现，先找出整个点集的首尾两个点，然后找到整个点集中距离首尾两点连线的距离最大的点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">get_cornerpoints</span><span class="params">()</span></span>&#123; <span class="comment">//使用最大距离法，获得轮廓点集的拐点</span></span><br><span class="line">    points_left = contours_appro.get(<span class="number">0</span>).toList();</span><br><span class="line">    points_right = contours_appro.get(<span class="number">1</span>).toList();</span><br><span class="line">    Double points_left_arr[][] = get_points_array(points_left); <span class="comment">//转换成数组，用来进行排序</span></span><br><span class="line">    Double points_right_arr[][] = get_points_array(points_right);</span><br><span class="line">    sort(points_left_arr, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>,<span class="number">1</span>&#125;); <span class="comment">//按横坐标升序</span></span><br><span class="line">    sort(points_right_arr, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">0</span>,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">int</span> len_left = points_left_arr.length;</span><br><span class="line">    <span class="keyword">int</span> len_right = points_right_arr.length;</span><br><span class="line">    org.opencv.core.Point pointl_1 = <span class="keyword">new</span> org.opencv.core.Point(points_left_arr[<span class="number">0</span>][<span class="number">0</span>],points_left_arr[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">// 按横坐标升序，得到第一个点坐标，记为轮廓1的第一个参考点</span></span><br><span class="line">    org.opencv.core.Point pointl_2 = <span class="keyword">new</span> org.opencv.core.Point(points_left_arr[len_left-<span class="number">1</span>][<span class="number">0</span>],points_left_arr[len_left-<span class="number">1</span>][<span class="number">1</span>]); <span class="comment">//继续按横坐标升序，取最后一个点集，作为第二个参考点</span></span><br><span class="line">    sort(points_left_arr, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">0</span>&#125;); <span class="comment">//按纵坐标升序</span></span><br><span class="line">    sort(points_right_arr, <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;<span class="number">1</span>,<span class="number">0</span>&#125;);</span><br><span class="line">    org.opencv.core.Point pointr_1 = <span class="keyword">new</span> org.opencv.core.Point(points_right_arr[<span class="number">0</span>][<span class="number">0</span>],points_right_arr[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">    org.opencv.core.Point pointr_2 = <span class="keyword">new</span> org.opencv.core.Point(points_right_arr[len_right-<span class="number">1</span>][<span class="number">0</span>],points_right_arr[len_right-<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>((pointl_2.x - pointl_1.x) == <span class="number">0</span>)&#123; <span class="comment">//垂直直线</span></span><br><span class="line">      corner_point_left.x = <span class="number">0</span>;</span><br><span class="line">      corner_point_left.y = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">double</span> k1 = (pointl_2.y - pointl_1.y) / (pointl_2.x - pointl_1.x);</span><br><span class="line">      <span class="keyword">double</span> b1 = pointl_2.y - k1 * pointl_2.x;</span><br><span class="line">      <span class="keyword">int</span> index1 = calculate_distance(points_left,k1,b1);</span><br><span class="line">      corner_point_left.x = points_left.get(index1).x;</span><br><span class="line">      corner_point_left.y = points_left.get(index1).y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>((pointr_2.x - pointr_1.x) == <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">double</span> b2 = pointr_1.x;</span><br><span class="line">      <span class="keyword">int</span> index2 = calculate_distance_infinate(points_right,b2);</span><br><span class="line">      corner_point_right.x = points_right.get(index2).x;</span><br><span class="line">      corner_point_right.y = points_right.get(index2).y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">double</span> k2 = (pointr_2.y - pointr_1.y) / (pointr_2.x - pointr_1.x);</span><br><span class="line">      <span class="keyword">double</span> b2 = pointr_2.y - k2 * pointr_2.x;</span><br><span class="line">      <span class="keyword">int</span> index2 = calculate_distance(points_right,k2,b2);</span><br><span class="line">      corner_point_right.x = points_right.get(index2).x;</span><br><span class="line">      corner_point_right.y = points_right.get(index2).y;</span><br><span class="line">    &#125;</span><br><span class="line">    corner_point.add(corner_point_left);</span><br><span class="line">    corner_point.add(corner_point_right);</span><br><span class="line">  &#125;  </span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">calculate_distance</span><span class="params">(List&lt;org.opencv.core.Point&gt; points,<span class="keyword">double</span> k,<span class="keyword">double</span> b)</span></span>&#123; <span class="comment">//计算到某一直线最大距离的点</span></span><br><span class="line">    <span class="keyword">double</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; points.size();i++)&#123;</span><br><span class="line">      <span class="keyword">double</span> d = FastMath.abs(points.get(i).x * k - points.get(i).y + b);</span><br><span class="line">      <span class="keyword">if</span>(d &gt; max)&#123;</span><br><span class="line">        max = d;</span><br><span class="line">        index = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">calculate_distance_infinate</span><span class="params">(List&lt;org.opencv.core.Point&gt; points,<span class="keyword">double</span> b)</span></span>&#123; <span class="comment">//计算到斜率为无穷大直线最大距离的点</span></span><br><span class="line">    <span class="keyword">double</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; points.size();i++)&#123;</span><br><span class="line">      <span class="keyword">double</span> d = FastMath.abs(points.get(i).x - b);</span><br><span class="line">      <span class="keyword">if</span>(d &gt; max)&#123;</span><br><span class="line">        max = d;</span><br><span class="line">        index = i;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-2-6-点集筛选"><a href="#2-2-6-点集筛选" class="headerlink" title="2.2.6 点集筛选"></a>2.2.6 点集筛选</h3><p>得到角点信息后，两个瓷砖可以进行靠近，但是再靠近之前还需要将两块瓷砖调整至平行，实际上调整平行是再瓷砖靠近之前进行的，但是在这里，为了得到合适的边缘直线的直线方程，需要由角点对轮廓点集进行筛选，仅保留有用的轮廓点集,然后有该点集拟合边缘直线，以获得直线角度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;org.opencv.core.Point&gt; roi_points_r(List&lt;org.opencv.core.Point&gt; points)&#123; <span class="comment">//得到新的点集</span></span><br><span class="line">    List&lt;org.opencv.core.Point&gt; points_new = <span class="keyword">new</span> ArrayList&lt;org.opencv.core.Point&gt;();</span><br><span class="line">    <span class="keyword">if</span>(points.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(edge_tile_flag == <span class="number">0</span>)&#123;  <span class="comment">//需要判断是否是该行的第一块瓷砖</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;points.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(points.get(i).y &gt; corner_point_right.y + <span class="number">5</span>)&#123;</span><br><span class="line">            points_new.add(points.get(i));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;points.size();i++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(points.get(i).y &lt; corner_point_right.y - <span class="number">5</span>)&#123;</span><br><span class="line">            points_new.add(points.get(i));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      points_new = points;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> points_new;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> List&lt;org.opencv.core.Point&gt; roi_points_l(List&lt;org.opencv.core.Point&gt; points)&#123; <span class="comment">//得到新的点集</span></span><br><span class="line">    List&lt;org.opencv.core.Point&gt; points_new = <span class="keyword">new</span> ArrayList&lt;org.opencv.core.Point&gt;();</span><br><span class="line">    <span class="keyword">if</span>(points.size() &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i&lt;points.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.get(i).x &gt; corner_point_left.x + <span class="number">5</span>)&#123;</span><br><span class="line">          points_new.add(points.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      points_new = points;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">return</span> points_new;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>roi_points_r</code>和<code>roi_points_l</code>分别表示的地面放置瓷砖的轮廓点集和机器人吸取末端瓷砖的点集。<br>从代码中可以看出来点集为<code>roi_points_r</code>时，当点集的纵坐标大于角点坐标的纵坐标时保留；点集为<code>roi_points_l</code>时，当点集的横坐标大于角点坐标的横坐标时保留。</p>
<h3 id="2-2-7-基于PCA的最小二乘方式"><a href="#2-2-7-基于PCA的最小二乘方式" class="headerlink" title="2.2.7 基于PCA的最小二乘方式"></a>2.2.7 基于PCA的最小二乘方式</h3><p>对于保留的点集接下来既可以进行直线的拟合，这里使用的时基于PCA的最小二乘方式，之所以采用这种算法，可以参考<a href="https://zhuanlan.zhihu.com/p/36429715" target="_blank" rel="noopener">这里</a>，简单的解释如下：</p>
<blockquote>
<p>对于当x被认为是没有误差时的单变量输入的点集时，最小二乘是没有问题的（即使是数据扰动很大的斜椭圆情况）。当变量是两个的情况下，例如由平面点集拟合直线时，由于x和y都可能存在误差，故pca法得到更佳的拟合效果</p>
</blockquote>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Double&gt; <span class="title">least_square_pca</span><span class="params">(List&lt;org.opencv.core.Point&gt; points)</span></span>&#123;<span class="comment">//PCA最小</span></span><br><span class="line">    List&lt;Double&gt; Theta = <span class="keyword">new</span> ArrayList&lt;Double&gt;();</span><br><span class="line">    <span class="keyword">int</span> len = points.size();</span><br><span class="line">    <span class="keyword">double</span> k_infinite = <span class="number">99999999</span>; <span class="comment">//表示无穷大的斜率</span></span><br><span class="line">    <span class="keyword">double</span> data [][] = <span class="keyword">new</span> <span class="keyword">double</span>[len][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">double</span> sum_x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> sum_y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i&lt; len;i++)&#123;</span><br><span class="line">      data[i][<span class="number">0</span>] = points.get(i).x;</span><br><span class="line">      data[i][<span class="number">1</span>] = points.get(i).y;</span><br><span class="line">      sum_x = sum_x + points.get(i).x;</span><br><span class="line">      sum_y = sum_y + points.get(i).y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">      data[i][<span class="number">0</span>] = data[i][<span class="number">0</span>] - sum_x/len;</span><br><span class="line">      data[i][<span class="number">1</span>] = data[i][<span class="number">1</span>] - sum_y/len;</span><br><span class="line">    &#125;</span><br><span class="line">    RealMatrix data_matrix = <span class="keyword">new</span> Array2DRowRealMatrix(data);</span><br><span class="line">    RealMatrix datamatrix2 = data_matrix.transpose().multiply(data_matrix);</span><br><span class="line">    RealMatrix u = <span class="keyword">new</span> SingularValueDecomposition(datamatrix2).getU();</span><br><span class="line">    RealMatrix n = u.getColumnMatrix(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">double</span> n_arr[][] = n.getData();</span><br><span class="line">    <span class="keyword">if</span>(n_arr[<span class="number">1</span>][<span class="number">0</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">      Theta.add(points.get(<span class="number">0</span>).x);</span><br><span class="line">      Theta.add(k_infinite);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">      <span class="keyword">double</span> k2 = -n_arr[<span class="number">0</span>][<span class="number">0</span>] / n_arr[<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">double</span> b2 = sum_y / len - k2 * sum_x / len;</span><br><span class="line">      Theta.add(b2); <span class="comment">//直线方程的截距</span></span><br><span class="line">      Theta.add(k2); <span class="comment">//直线方程的斜率</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Theta;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>直线拟合之后就可以计算出两条直线的角度及其偏差。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%9C%BA%E6%A2%B0%E8%87%82/" rel="tag"># 机械臂</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-next post-nav-item">
                <a href="/2019/11/24/CPP%E5%B9%B6%E5%8F%91-04%E5%90%8C%E6%AD%A5%E5%B9%B6%E5%8F%91%E6%93%8D%E4%BD%9C/" rel="next" title="CPP并发_04同步并发操作">
                  <i class="fa fa-chevron-left"></i> CPP并发_04同步并发操作
                </a>
            </div>

            <span class="post-nav-divider"></span>

            <div class="post-nav-prev post-nav-item">
                <a href="/2020/01/05/ROS%E9%85%8D%E7%BD%AE%E4%B8%8EDaocloud%E9%83%A8%E7%BD%B2/" rel="prev" title="在Docker中进行ROS配置与Daocloud部署以及Win下ROS使用">
                  在Docker中进行ROS配置与Daocloud部署以及Win下ROS使用 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          
    
  <div class="comments" id="comments">
    <div id="lv-container" data-id="city" data-uid="MTAyMC80NzM3My8yMzg3Mw=="></div>
  </div>
  

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#0-基于视觉的UR10机器人贴砖系统"><span class="nav-text">0. 基于视觉的UR10机器人贴砖系统</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#1-UR控制"><span class="nav-text">1.UR控制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1读取数据"><span class="nav-text">1.1读取数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2发送数据-机器人规划"><span class="nav-text">1.2发送数据(机器人规划)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1初始化"><span class="nav-text">1.2.1初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-生成瓷砖吸取位置"><span class="nav-text">1.2.2 生成瓷砖吸取位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3生成放置瓷砖位置"><span class="nav-text">1.2.3生成放置瓷砖位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4由点生成路径"><span class="nav-text">1.2.4由点生成路径</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-5接收Processing数据"><span class="nav-text">1.2.5接收Processing数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-6贴砖策略"><span class="nav-text">1.2.6贴砖策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-7-I-O说明"><span class="nav-text">1.2.7 I/O说明</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-UR视觉"><span class="nav-text">2.UR视觉</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-手眼标定"><span class="nav-text">2.1 手眼标定</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-转换矩阵的确定"><span class="nav-text">2.1.1 转换矩阵的确定</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-像素坐标转换到世界坐标"><span class="nav-text">2.1.2 像素坐标转换到世界坐标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-瓷砖特征信息提取"><span class="nav-text">2.2 瓷砖特征信息提取</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-图像预处理"><span class="nav-text">2.2.1 图像预处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-轮廓检测"><span class="nav-text">2.2.2 轮廓检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-轮廓筛选与质心计算"><span class="nav-text">2.2.3 轮廓筛选与质心计算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-edge-tile-flag"><span class="nav-text">2.2.4 edge_tile_flag</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-5-最大距离法"><span class="nav-text">2.2.5 最大距离法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-6-点集筛选"><span class="nav-text">2.2.6 点集筛选</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-7-基于PCA的最小二乘方式"><span class="nav-text">2.2.7 基于PCA的最小二乘方式</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="site-author-image" itemprop="image" alt="qipccc"
    src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">qipccc</p>
  <div class="site-description" itemprop="description">风雨兼程</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="feed-link motion-element">
    <a href="/atom.xml" rel="alternate">
      <i class="fa fa-rss"></i>RSS
    </a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">qipccc</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    <span title="站点总字数">108k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:01</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>












        
      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">
    MathJax.Ajax.config.path['mhchem'] = '//cdn.jsdelivr.net/npm/mathjax-mhchem@3';

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
        extensions: ['[mhchem]/mhchem.js'],
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  

<script>
  window.livereOptions = {
    refer: location.pathname.replace(CONFIG.root, '').replace('index.html', '')
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script><!-- hexo-inject:begin --><!-- hexo-inject:end -->

</body>
</html>
